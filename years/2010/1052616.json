{
 "awd_id": "1052616",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Foundational Principles to Support Evolution in Domain-Specific Modeling",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2010-07-01",
 "awd_exp_date": "2013-03-31",
 "tot_intn_awd_amt": 183466.0,
 "awd_amount": 183466.0,
 "awd_min_amd_letter_date": "2010-09-27",
 "awd_max_amd_letter_date": "2011-07-13",
 "awd_abstract_narration": "Despite advances in programming languages and runtime platforms, most software is developed at a low-level of abstraction relative to the concepts and concerns within the problem space of an application domain. Domain-Specific Modeling (DSM) is a design approach that uses a metamodel to define a modeling language capturing the essential characteristics of a problem space in a manner that is decoupled from the details of a specific solution space. However, the current DSM practice lacks fundamental concepts to support a broad range of tasks needed for model-driven evolution of software. The proposed research will extend the capabilities of DSM by investigating the synergy of model transformation and program transformation as methods to support the necessary evolution of software artifacts as reflected by changes in high-level models. Specific topics of investigation include model-driven program transformation, reverse engineering of legacy source code into domain-specific models, model difference algorithms that support a new class of version control tools focused on visual modeling concerns, and a technique to analyze a user's intention among edit changes within a modeling tool. The proposed research agenda is integrated with educational activities, including undergraduate mentoring and graduate education, with an emphasis on K-12 outreach activities.\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jeffrey",
   "pi_last_name": "Gray",
   "pi_mid_init": "G",
   "pi_sufx_name": "",
   "pi_full_name": "Jeffrey G Gray",
   "pi_email_addr": "gray@cs.ua.edu",
   "nsf_id": "000247328",
   "pi_start_date": "2010-09-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Alabama Tuscaloosa",
  "inst_street_address": "801 UNIVERSITY BLVD",
  "inst_street_address_2": "",
  "inst_city_name": "TUSCALOOSA",
  "inst_state_code": "AL",
  "inst_state_name": "Alabama",
  "inst_phone_num": "2053485152",
  "inst_zip_code": "354012029",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "AL07",
  "org_lgl_bus_name": "UNIVERSITY OF ALABAMA",
  "org_prnt_uei_num": "TWJWHYEM8T63",
  "org_uei_num": "RCNJEHZ83EV6"
 },
 "perf_inst": {
  "perf_inst_name": "University of Alabama Tuscaloosa",
  "perf_str_addr": "801 UNIVERSITY BLVD",
  "perf_city_name": "TUSCALOOSA",
  "perf_st_code": "AL",
  "perf_st_name": "Alabama",
  "perf_zip_code": "354012029",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "AL07",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "915000",
   "pgm_ele_name": "EPSCoR Co-Funding"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0407",
   "app_name": "NSF,Education & Human Resource",
   "app_symb_id": "490106",
   "fund_code": "0400999999",
   "fund_name": "NSF Education & Human Resource",
   "fund_symb_id": "040106"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 20354.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 82779.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 80333.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>&nbsp;</p>\n<p><span style=\"text-decoration: underline;\"><strong>General Overview:&nbsp;</strong></span></p>\n<p>Domain-specific modeling (DSM) provides a solution to demands for higher productivity by constricting the gap between the essence of a problem and the accidental complexities of its solution space. In the past, productivity gains have been sought from new programming languages. Domain-specific modeling languages provide a viable solution for continuing to raise the level of abstraction beyond coding. In DSM, the models are constructed using concepts that represent things in the application domain, not concepts of a given programming language. The modeling language follows the domain abstractions and semantics, allowing developers (potentially end-users with no programming experience) to perceive themselves as working directly with domain concepts. In a number of cases, the final products can be generated automatically from these high-level specifications with domain-specific code generators. This automation is possible because of domain-specificity: both the modeling language and code generators fit to the requirements of a narrowly defined domain.&nbsp;</p>\n<p>Like all software, models are also subject to evolve based on external requirements and the need for engineering changes. To express such changes, model transformation languages have been designed to specify and automate modifications across a model that would be too challenging to perform manually (e.g., due to the error prone and tedious nature of making a crosscutting change across a large model space). Much of the focus of this project, as described in the next section, concentrated on support that allows end-users to create their own modeling languages and to specify transformations on their models using a by-demonstration technique. Adopting a by-demonstration approach allows end-users to remain in their comfort level with abstractions they are familiar with, rather than the need to learn complex transformation languages and metamodel formalisms.</p>\n<p>&nbsp;</p>\n<p><span style=\"text-decoration: underline;\"><strong>Intellectual Merit:&nbsp;</strong></span></p>\n<p>The core contributions of this CAREER project include the results of the following investigations:&nbsp;</p>\n<p>The early years of the project produced specific contributions in the areas of model comparison (i.e., automated analysis to compare the differences between two models, such as for supporting model version control), model inferencing (i.e., infer a metamodel for a modeling language from specific model instances), and an understanding of the manner in which model transformation can assist in the scalability of modeling artifacts.&nbsp;</p>\n<p>The core contributions of the project were focused on applying a by-demonstration technique (where a user demonstrates their desire using artifacts common to them, similar to by-example approaches, such as Query By Example in databases) to specify modeling languages and model transformations. The idea of Model Transformation by Demonstration (MTBD) allows the user to press a &ldquo;record&rdquo; button in a modeling tool, whereby they could demonstrate the operational changes to a model that were captured in a formal representation as a model transformation. The MTBD idea was applied to several contexts (e.g., aspect-oriented modeling, model refactoring, model scalability, and even model layout algorithms) with support for debugging at the end-user abstraction level. The final years of the project focused on allowing the user to define their own modeling language by demonstrating instances of the language (e.g., allowing the user to sketch out sample instances that were then used to infer the language rules).&nbsp;</p>\n<p>Software prototypes developed in support of the project include: a tool for model differencing and visualization, model inferencing software to build metamodels from i...",
  "por_txt_cntn": "\n \n\nGeneral Overview: \n\nDomain-specific modeling (DSM) provides a solution to demands for higher productivity by constricting the gap between the essence of a problem and the accidental complexities of its solution space. In the past, productivity gains have been sought from new programming languages. Domain-specific modeling languages provide a viable solution for continuing to raise the level of abstraction beyond coding. In DSM, the models are constructed using concepts that represent things in the application domain, not concepts of a given programming language. The modeling language follows the domain abstractions and semantics, allowing developers (potentially end-users with no programming experience) to perceive themselves as working directly with domain concepts. In a number of cases, the final products can be generated automatically from these high-level specifications with domain-specific code generators. This automation is possible because of domain-specificity: both the modeling language and code generators fit to the requirements of a narrowly defined domain. \n\nLike all software, models are also subject to evolve based on external requirements and the need for engineering changes. To express such changes, model transformation languages have been designed to specify and automate modifications across a model that would be too challenging to perform manually (e.g., due to the error prone and tedious nature of making a crosscutting change across a large model space). Much of the focus of this project, as described in the next section, concentrated on support that allows end-users to create their own modeling languages and to specify transformations on their models using a by-demonstration technique. Adopting a by-demonstration approach allows end-users to remain in their comfort level with abstractions they are familiar with, rather than the need to learn complex transformation languages and metamodel formalisms.\n\n \n\nIntellectual Merit: \n\nThe core contributions of this CAREER project include the results of the following investigations: \n\nThe early years of the project produced specific contributions in the areas of model comparison (i.e., automated analysis to compare the differences between two models, such as for supporting model version control), model inferencing (i.e., infer a metamodel for a modeling language from specific model instances), and an understanding of the manner in which model transformation can assist in the scalability of modeling artifacts. \n\nThe core contributions of the project were focused on applying a by-demonstration technique (where a user demonstrates their desire using artifacts common to them, similar to by-example approaches, such as Query By Example in databases) to specify modeling languages and model transformations. The idea of Model Transformation by Demonstration (MTBD) allows the user to press a \"record\" button in a modeling tool, whereby they could demonstrate the operational changes to a model that were captured in a formal representation as a model transformation. The MTBD idea was applied to several contexts (e.g., aspect-oriented modeling, model refactoring, model scalability, and even model layout algorithms) with support for debugging at the end-user abstraction level. The final years of the project focused on allowing the user to define their own modeling language by demonstrating instances of the language (e.g., allowing the user to sketch out sample instances that were then used to infer the language rules). \n\nSoftware prototypes developed in support of the project include: a tool for model differencing and visualization, model inferencing software to build metamodels from instances, the MTBD engine and debugger (within the GEMS plugin for Eclipse), and a Visio plug-in that supports demonstration of models that are used to infer a new metamodel.\n\n \n\nBroader Impacts:\n\nThe broader impacts of this project include deep collaboration with colleagues from throughout the US a..."
 }
}