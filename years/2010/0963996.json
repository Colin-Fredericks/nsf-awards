{
 "awd_id": "0963996",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF:  Medium: Programmable Monitoring Framework for Multicore Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2010-09-01",
 "awd_exp_date": "2014-08-31",
 "tot_intn_awd_amt": 576840.0,
 "awd_amount": 734040.0,
 "awd_min_amd_letter_date": "2010-07-22",
 "awd_max_amd_letter_date": "2012-06-20",
 "awd_abstract_narration": "The advent of multicore processors has introduced new opportunities for achieving\r\nincreased software performance, reliability, security, and availability. However,\r\npowerful dynamic execution monitoring capabilities are required to realize these\r\nopportunities. This project addresses the challenges of developing a Dynamic\r\nBinary Translation based monitoring framework for parallel applications running on\r\nmulticore systems. The programmability of the framework will enable realization of \r\nbenefits in achieving enhanced performance, reliability, security, and availability.\r\n\r\n\tSome of the instrumentation code required in context of parallel applications \r\nmust be executed by a core in response to events that involve other cores. In particular, \r\nevents relevant to many performance, reliability, and security related tasks correspond \r\nto the manifestation of interprocessor data dependences due to updates of shared \r\nmemory locations by multiple cores. Based upon this observation programmable \r\narchitectural mechanisms will be provided that not only enable the detection of \r\ninterprocessor dependence events but also enable the triggering of the execution of \r\napplication specific monitoring code. This project will then employ these mechanisms \r\nfor improving performance via speculative parallelism, enabling debugging via a\r\nnovel strategy of execution suppression, improving reliability via an approach that\r\nallows applications to automatically recover from failures, providing security via\r\ndynamic detection of mutating viruses, and software availability via dynamic updates.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Rajiv",
   "pi_last_name": "Gupta",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Rajiv Gupta",
   "pi_email_addr": "gupta@cs.ucr.edu",
   "nsf_id": "000077772",
   "pi_start_date": "2010-07-22",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Iulian",
   "pi_last_name": "Neamtiu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Iulian Neamtiu",
   "pi_email_addr": "ineamtiu@njit.edu",
   "nsf_id": "000537180",
   "pi_start_date": "2010-07-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Riverside",
  "inst_street_address": "200 UNIVERSTY OFC BUILDING",
  "inst_street_address_2": "",
  "inst_city_name": "RIVERSIDE",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "9518275535",
  "inst_zip_code": "925210001",
  "inst_country_name": "United States",
  "cong_dist_code": "39",
  "st_cong_dist_code": "CA39",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA AT RIVERSIDE",
  "org_prnt_uei_num": "",
  "org_uei_num": "MR5QC5FCAVH5"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Riverside",
  "perf_str_addr": "200 UNIVERSTY OFC BUILDING",
  "perf_city_name": "RIVERSIDE",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "925210001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "39",
  "perf_st_cong_dist": "CA39",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "732900",
   "pgm_ele_name": "COMPILERS"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794100",
   "pgm_ele_name": "COMPUTER ARCHITECTURE"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7941",
   "pgm_ref_txt": "COMPUTER ARCHITECTURE"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 363000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 346840.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 24200.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>With the widespread use of computing devices and software in critical tasks, high software reliability and performance are paramount. To ensure that software is running reliably, it is important to monitor its execution to identify faulty behavior and then correct it. Also, since deployed software must handle a wide range of situations, it is important to monitor program's input and dependence characteristics during execution and adapt it to deliver high performance. The research project has delivered techniques to enable efficient runtime monitoring of software, tools for debugging of parallel programs to improve their reliability, and runtime techniques for improving performance of complex real-world applications.<br /><br />1. Efficient Runtime Monitoring.<br />Continuous monitoring of running software can result in high runtime overhead, since a significant portion of the compute cycles can be taken up by monitoring activities. In this work we designed lightweight hardware support that can be programmed to perform a wide range of monitoring tasks with minimal runtime overhead. The effectiveness of programmable hardware was demonstrated by using it to perform monitoring needed for software reliability (e.g., record-and-replay) and software performance (e.g., speculative parallel execution). An important contribution of the above work is that it considers the relationship between memory models and runtime monitoring of memory accesses. We have solved the long standing problem of efficiently supporting the sequential consistency memory model which makes the task of producing reliable software much more manageable.<br /><br />2. Debugging Tools for Parallel Software.<br />Existing debugging tools provide little guidance for the programmers towards locating the bug source. We have developed a new tool, DrDebug, for efficiently debugging multithreaded programs. By providing several new commands we make the task of examining and analyzing the state of a running program much easier. The insights gained by using these commands helps the user track down the root cause of faulty behavior and improve program understanding, allowing the programmer to modify the program to eliminate faulty behavior. DrDebug works for parallel programs and can efficiently monitor long program runs. Additional support for replaying parts of program execution is provided so that the user can efficiently explore and understand program behavior. The effectiveness of DrDebug was demonstrated by monitoring and debugging of real-world programs containing bugs.<br /><br />3. Exploiting Parallelism in Real-world Applications.<br />Modern applications in important domains such as genomics and data mining are characterized by their need for massive computing power both due to their computational complexity and their handling of massive amounts of data. We have observed that the massive amounts of input, intermediate, and output data that these applications must handle causes programmers to develop code which continuously carries out data transfers between files and memory to make the best use of limited available memory. Frequent I/O operations that perform these data transfers introduce dependences that greatly limit our ability to exploit parallelism in hybrid loops (i.e., loops containing a mix of computation and I/O). While much research has been carried out over past several decades on exploiting parallelism, these techniques are mostly applicable to computations that are free of I/O operations. We have developed a novel technique that breaks I/O caused dependences and greatly enhances our ability to exploit parallelism for real-world applications. As an example we studied Velvet, a popular de novo genomic assembler. Velvet must deal with large input sizes and large amounts of intermediate data. For example, for processing of the wheat genome, Velvet must handle an input file that is 15 Gb in size ...",
  "por_txt_cntn": "\nWith the widespread use of computing devices and software in critical tasks, high software reliability and performance are paramount. To ensure that software is running reliably, it is important to monitor its execution to identify faulty behavior and then correct it. Also, since deployed software must handle a wide range of situations, it is important to monitor program's input and dependence characteristics during execution and adapt it to deliver high performance. The research project has delivered techniques to enable efficient runtime monitoring of software, tools for debugging of parallel programs to improve their reliability, and runtime techniques for improving performance of complex real-world applications.\n\n1. Efficient Runtime Monitoring.\nContinuous monitoring of running software can result in high runtime overhead, since a significant portion of the compute cycles can be taken up by monitoring activities. In this work we designed lightweight hardware support that can be programmed to perform a wide range of monitoring tasks with minimal runtime overhead. The effectiveness of programmable hardware was demonstrated by using it to perform monitoring needed for software reliability (e.g., record-and-replay) and software performance (e.g., speculative parallel execution). An important contribution of the above work is that it considers the relationship between memory models and runtime monitoring of memory accesses. We have solved the long standing problem of efficiently supporting the sequential consistency memory model which makes the task of producing reliable software much more manageable.\n\n2. Debugging Tools for Parallel Software.\nExisting debugging tools provide little guidance for the programmers towards locating the bug source. We have developed a new tool, DrDebug, for efficiently debugging multithreaded programs. By providing several new commands we make the task of examining and analyzing the state of a running program much easier. The insights gained by using these commands helps the user track down the root cause of faulty behavior and improve program understanding, allowing the programmer to modify the program to eliminate faulty behavior. DrDebug works for parallel programs and can efficiently monitor long program runs. Additional support for replaying parts of program execution is provided so that the user can efficiently explore and understand program behavior. The effectiveness of DrDebug was demonstrated by monitoring and debugging of real-world programs containing bugs.\n\n3. Exploiting Parallelism in Real-world Applications.\nModern applications in important domains such as genomics and data mining are characterized by their need for massive computing power both due to their computational complexity and their handling of massive amounts of data. We have observed that the massive amounts of input, intermediate, and output data that these applications must handle causes programmers to develop code which continuously carries out data transfers between files and memory to make the best use of limited available memory. Frequent I/O operations that perform these data transfers introduce dependences that greatly limit our ability to exploit parallelism in hybrid loops (i.e., loops containing a mix of computation and I/O). While much research has been carried out over past several decades on exploiting parallelism, these techniques are mostly applicable to computations that are free of I/O operations. We have developed a novel technique that breaks I/O caused dependences and greatly enhances our ability to exploit parallelism for real-world applications. As an example we studied Velvet, a popular de novo genomic assembler. Velvet must deal with large input sizes and large amounts of intermediate data. For example, for processing of the wheat genome, Velvet must handle an input file that is 15 Gb in size and intermediate data that exceeds 10 Gb.  Therefore I/O operations appear frequently in the program and li..."
 }
}