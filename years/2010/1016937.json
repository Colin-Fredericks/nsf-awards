{
 "awd_id": "1016937",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF:Small:Language Support for Ad Hoc Data Processing",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2010-08-15",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2010-08-05",
 "awd_max_amd_letter_date": "2012-06-27",
 "awd_abstract_narration": "In every business, engineering endeavour and scientific discipline, workers are digitizing their knowledge with the hope of using computational methods to categorize, query, filter, search, diagnose, and visualize their data. While this effort is leading to remarkable industrial and scientific advances, it is also generating enormous amounts of ad hoc data (i.e., that data for which standard data processing tools such as query engines, statistical packages, graphing tools, or other software is not readily available). Ad hoc data poses tremendous challenges to its users because it is often highly varied, poorly documented, filled with errors, and continuously evolving --- yet ad hoc data also contains much valuable information.  The goal of this research is to develop general-purpose software tools and techniques capable of managing ad hoc data efficiently.  This research has the potential for a broad impact on society by dramatically improving the productivity of industrial data analysts, computer systems administrators and academics who must deal with ad hoc data on a day-to-day basis.\r\n\r\nThe central technical challenge of the research involves designing, implementing and evaluating a new domain-specific programming language that facilitates the management of ad hoc data sets.  This new programming language will allow data analysts to specify the structure of ad hoc data files, how those files are arranged in a file system and what meta-data is associated with them.  Once a specification is complete, it will be possible to use it as documentation for the data set or for generating data-processing tools.  The research will also involve developing new methods for enabling users to generate specifications quickly and accurately, without actually having to write down all of the details by hand.  Finally, the research will develop new algorithms for implementing the generated data-processing tools efficiently.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "David",
   "pi_last_name": "Walker",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "David Walker",
   "pi_email_addr": "dpw@cs.princeton.edu",
   "nsf_id": "000167001",
   "pi_start_date": "2010-08-05",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Princeton University",
  "inst_street_address": "1 NASSAU HALL",
  "inst_street_address_2": "",
  "inst_city_name": "PRINCETON",
  "inst_state_code": "NJ",
  "inst_state_name": "New Jersey",
  "inst_phone_num": "6092583090",
  "inst_zip_code": "085442001",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "NJ12",
  "org_lgl_bus_name": "THE TRUSTEES OF PRINCETON UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "NJ1YPQXQG7U5"
 },
 "perf_inst": {
  "perf_inst_name": "Princeton University",
  "perf_str_addr": "1 NASSAU HALL",
  "perf_city_name": "PRINCETON",
  "perf_st_code": "NJ",
  "perf_st_name": "New Jersey",
  "perf_zip_code": "085442001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "NJ12",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 330382.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 169618.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>We are currently in the midst of the \"big data\" revolution. &nbsp;In other&nbsp;words, we have, all around us, a growing number of computational&nbsp;processes that are each generating enormous amounts information and&nbsp;storing it away for future analysis. &nbsp;This data can be used to help us&nbsp;investigate the causes of disease, understand the formation of our&nbsp;universe, improve the efficiency of our energy grid, or discover&nbsp;which products are most popular amongst our customers. &nbsp;Of course, to&nbsp;make use of this data, software engineers must write programs to&nbsp;parse, transform, analyze, query and communicate this data from place&nbsp;to place. &nbsp;The purpose of this research project was to investigate new&nbsp;kinds of programming languages and programming tools that will help&nbsp;software engineers manage this data more easily, more efficiently, and&nbsp;more reliably.&nbsp;</p>\n<p><br />The study of languages, like the ones developed in this project,&nbsp;involves a number of inter-related activities. &nbsp;First, it requires&nbsp;some design: the primitives of the language must be defined so they&nbsp;fit together effectively, and allow software engineers to construct an&nbsp;infinite spectrum of useful programs. &nbsp;Second, each primitive must&nbsp;have a clear semantics &mdash; i.e., a &ldquo;meaning&rdquo; or &ldquo;definition.&rdquo; &nbsp;These&nbsp;meanings are typically expressed in mathematical terms, and doing so&nbsp;allows language designers to prove strong properties of some, or&nbsp;possibly all, of the infinitely many programs that can be written in&nbsp;the language. &nbsp;Indeed, well-designed languages possess many useful&nbsp;safety properties that help programmers avoid errors in program&nbsp;construction. &nbsp;A language semantics is also useful to the engineers&nbsp;who develop the compilers or program analysis tools, and to the&nbsp;everyday programmer who needs to understand what their program does.&nbsp;Third, the study of languages requires implementation and&nbsp;experimentation. &nbsp;We must try the language out on real-world&nbsp;applications to find out how well it solves the problems of interest.&nbsp;Of course, each of these three activities complements the other: The&nbsp;semantic analysis typically tells us what kinds of designs are&nbsp;possible and guides the initial implementation; the implementation and&nbsp;applications tells us what kinds of designs are useful, and may&nbsp;suggest changes to the semantics of individual primitives.&nbsp;</p>\n<p><br />During the execution of this grant, we engaged in each of the&nbsp;activities described above and developed several new programming&nbsp;languages and tools for data management and communication. &nbsp;More&nbsp;specifically, together with collaborators Kathleen Fisher (Tufts&nbsp;University) and Nate Foster (initially a post doc working at Princeton&nbsp;on this research and now an assistant professor at Cornell&nbsp;University), the PI developed a new language, called Forest, for&nbsp;specifying the structure of multi-directory file systems. &nbsp;From a&nbsp;single, compact specification, the Forest system is able to generate a&nbsp;host of different data-processing tools. &nbsp;For instance, Forest can&nbsp;generate a collection of programmer libraries for parsing, printing,&nbsp;querying, traversing or finding errors in the described data. &nbsp;Forest also has a rigorous semantics, which we have used to prove key properties of&nbsp;system, including various \"round-tripping laws\" that tell us, for&nbsp;example, that parsing is a proper inverse of printing. &nbsp;Such properties help improve our confidence in the reliability of our infrastructure and the basic soundness of our designs.</p>\n<p>The Forest design was implemented as a domain-specific language&nbsp;embedded in Haskell, a modern functional programming language. &nbsp;Using&nbs...",
  "por_txt_cntn": "\nWe are currently in the midst of the \"big data\" revolution.  In other words, we have, all around us, a growing number of computational processes that are each generating enormous amounts information and storing it away for future analysis.  This data can be used to help us investigate the causes of disease, understand the formation of our universe, improve the efficiency of our energy grid, or discover which products are most popular amongst our customers.  Of course, to make use of this data, software engineers must write programs to parse, transform, analyze, query and communicate this data from place to place.  The purpose of this research project was to investigate new kinds of programming languages and programming tools that will help software engineers manage this data more easily, more efficiently, and more reliably. \n\n\nThe study of languages, like the ones developed in this project, involves a number of inter-related activities.  First, it requires some design: the primitives of the language must be defined so they fit together effectively, and allow software engineers to construct an infinite spectrum of useful programs.  Second, each primitive must have a clear semantics &mdash; i.e., a \"meaning\" or \"definition.\"  These meanings are typically expressed in mathematical terms, and doing so allows language designers to prove strong properties of some, or possibly all, of the infinitely many programs that can be written in the language.  Indeed, well-designed languages possess many useful safety properties that help programmers avoid errors in program construction.  A language semantics is also useful to the engineers who develop the compilers or program analysis tools, and to the everyday programmer who needs to understand what their program does. Third, the study of languages requires implementation and experimentation.  We must try the language out on real-world applications to find out how well it solves the problems of interest. Of course, each of these three activities complements the other: The semantic analysis typically tells us what kinds of designs are possible and guides the initial implementation; the implementation and applications tells us what kinds of designs are useful, and may suggest changes to the semantics of individual primitives. \n\n\nDuring the execution of this grant, we engaged in each of the activities described above and developed several new programming languages and tools for data management and communication.  More specifically, together with collaborators Kathleen Fisher (Tufts University) and Nate Foster (initially a post doc working at Princeton on this research and now an assistant professor at Cornell University), the PI developed a new language, called Forest, for specifying the structure of multi-directory file systems.  From a single, compact specification, the Forest system is able to generate a host of different data-processing tools.  For instance, Forest can generate a collection of programmer libraries for parsing, printing, querying, traversing or finding errors in the described data.  Forest also has a rigorous semantics, which we have used to prove key properties of system, including various \"round-tripping laws\" that tell us, for example, that parsing is a proper inverse of printing.  Such properties help improve our confidence in the reliability of our infrastructure and the basic soundness of our designs.\n\nThe Forest design was implemented as a domain-specific language embedded in Haskell, a modern functional programming language.  Using this implementation, we developed a number of specifications and applications, including a specification of the structure of a standard Linux file system.  The Forest system and many of our other products, tools, ideas, code and academic papers can be found on our project website at http://www.padsproj.org/. \n\nIn addition to designing and implementing Forest, we, and our collaborators, designed several other domain-specific languages for ..."
 }
}