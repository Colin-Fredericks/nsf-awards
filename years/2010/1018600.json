{
 "awd_id": "1018600",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Find and Fix Similar Software Bugs",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2010-08-15",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 483261.0,
 "awd_amount": 483261.0,
 "awd_min_amd_letter_date": "2010-08-17",
 "awd_max_amd_letter_date": "2010-08-17",
 "awd_abstract_narration": "Finding and fixing bugs are crucial in the process of developing reliable and high-quality software. Software developers could base on their own experience with their programs, or effectively find bugs by consulting the similar bugs and fixes from others in the past for the same or different systems. However, the body of knowledge in software engineering is still very limited on the nature, the causes and effects, and the characteristics of such recurring bugs. The learning process from prior known bugs is still ad-hoc, manually, and un-systematically. In this project, a comprehensive approach is introduced to capture the knowledge of prior bugs and corresponding fixes, and to leverage such knowledge to build automated tools to detect potential recurring buggy code at other locations in the same or different systems. Such tools will help to detect bugs early in the development process, leading to higher-quality software and the improvement in productivity of software developers in the bug fixing\r\npractice.\r\n\r\nIn this project, an empirical study will be conducted to collect, analyze, and understand the nature and characteristics of recurring and similar bugs within one and across multiple systems. This project is expected to advance software engineering knowledge on the theoretical foundation, concepts, practical techniques, and automated tools to (1) capture the characteristics and measure the similarity of code units involved in prior known fixed bugs, (2) identify the locations of potential buggy units and derive the guidelines to fix them by matching them to the relevant peer code units of the known bugs, and (3) support the similar bug detection and fixing process. The teaching modules and validation efforts in this project will involve students and professionals, promoting teaching and training software quality assurance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Tien",
   "pi_last_name": "Nguyen",
   "pi_mid_init": "N",
   "pi_sufx_name": "",
   "pi_full_name": "Tien N Nguyen",
   "pi_email_addr": "nguyen.n.tien@gmail.com",
   "nsf_id": "000340493",
   "pi_start_date": "2010-08-17",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Iowa State University",
  "inst_street_address": "1350 BEARDSHEAR HALL",
  "inst_street_address_2": "515 MORRILL ROAD",
  "inst_city_name": "AMES",
  "inst_state_code": "IA",
  "inst_state_name": "Iowa",
  "inst_phone_num": "5152945225",
  "inst_zip_code": "500112103",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IA04",
  "org_lgl_bus_name": "IOWA STATE UNIVERSITY OF SCIENCE AND TECHNOLOGY",
  "org_prnt_uei_num": "DQDBM7FGJPC5",
  "org_uei_num": "DQDBM7FGJPC5"
 },
 "perf_inst": {
  "perf_inst_name": "Iowa State University",
  "perf_str_addr": "1350 BEARDSHEAR HALL",
  "perf_city_name": "AMES",
  "perf_st_code": "IA",
  "perf_st_name": "Iowa",
  "perf_zip_code": "500112103",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IA04",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ele_code": "915000",
   "pgm_ele_name": "EPSCoR Co-Funding"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 483261.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software has become a vital part of our modern society. Finding and fixing software defects are crucial in the process of developing reliable and high-quality software. Failing to fix a defect early could result in severe consequences. Once failures are reported, developers need to fix them by locating buggy locations in the code. Like other problem-solving tasks, developers could generally base on their own expertise and experience, or consult with others who have experienced with similar defects before. However, while the similar defects/bugs have been recurring in software systems due to the practice of software reuse, the existing supports for such learning and consultation are still ad-hoc, manually, and un-systematically. Thus, it is desired to have automated tool supports that capture the knowledge on defects and fixes, and leverage it to find and fix the recurring and similar defects.</p>\n<p>In this project, we have conducted research activities with two key objectives: (1) understanding the nature and characteristics of recurring and similar defects in software systems; and (2) leveraging such knowledge to develop scientific foundation and tool supports to detect and recommend fixes for future software defects. Toward these goals, we performed empirical studies on a large number open-source software projects with a very large number of bug fixes. Our key findings fundamentally advance the body of knowledge and understanding of the nature and characteristics of recurring bugs/fixes and its relation to software reuse. First, there are about 17-45% of total fixing changes that are considered as recurring. While many recurring fixes occur on multiple files at the same revisions (i.e. in space), fewer fixes recur on different revisions (i.e. in time). Some of them recur in both time and space. Second, the recurring fixes have high repetitiveness with smaller sizes and with certain syntactic types (e.g., method calls, infix expressions, condition and loop statements). The recurring fixes tend to recur across projects with even a higher level of repetitiveness than the within-project fixes. Third, we are able to collect empirical evidences to confirm that software reuse practice in programming creates similar modules in source code; and similar modules tends to have similar bugs, thus might require fixes in the similar manners. Specifically, in a software project, there exist multiple objects that play similar roles, provide similar functions, or perform similar interactions with the other objects in the system that need to be built. Those functions/interactions are realized in similar code and/or in similar object usage scenarios. Then, when the functions/interactions need to be changed (e.g. due to bug fixing), the corresponding code/usages are changed in the similar manners, resulting in recurring fixes. We call them code peers. When such a program unit is buggy and needs to be fixed, the peer code units need to be considered for fixing as well.</p>\n<p>Leveraging such findings, we developed a novel methodology to characterize and to identify the similar code fragments in a software system (via code clones and code peers) that could be fixed in the similar manners. We then developed a method to propagate the fixing changes in a code fragment to other fragments. More specifically, we developed new concepts, techniques, algorithms, and automated tools to characterize and measure the similarity of code units involved in prior known fixed defects, and to identify the code locations of potential buggy code units. Our tool derives the fixing recommendations by matching them to the peered and cloned code units of the prior known defects. Our empirical evaluation showed that our method is reliable and has high accuracy. We also developed the methods to analyze recurring defects through detecting duplicate defect reports and to better recover the links between the defec...",
  "por_txt_cntn": "\nSoftware has become a vital part of our modern society. Finding and fixing software defects are crucial in the process of developing reliable and high-quality software. Failing to fix a defect early could result in severe consequences. Once failures are reported, developers need to fix them by locating buggy locations in the code. Like other problem-solving tasks, developers could generally base on their own expertise and experience, or consult with others who have experienced with similar defects before. However, while the similar defects/bugs have been recurring in software systems due to the practice of software reuse, the existing supports for such learning and consultation are still ad-hoc, manually, and un-systematically. Thus, it is desired to have automated tool supports that capture the knowledge on defects and fixes, and leverage it to find and fix the recurring and similar defects.\n\nIn this project, we have conducted research activities with two key objectives: (1) understanding the nature and characteristics of recurring and similar defects in software systems; and (2) leveraging such knowledge to develop scientific foundation and tool supports to detect and recommend fixes for future software defects. Toward these goals, we performed empirical studies on a large number open-source software projects with a very large number of bug fixes. Our key findings fundamentally advance the body of knowledge and understanding of the nature and characteristics of recurring bugs/fixes and its relation to software reuse. First, there are about 17-45% of total fixing changes that are considered as recurring. While many recurring fixes occur on multiple files at the same revisions (i.e. in space), fewer fixes recur on different revisions (i.e. in time). Some of them recur in both time and space. Second, the recurring fixes have high repetitiveness with smaller sizes and with certain syntactic types (e.g., method calls, infix expressions, condition and loop statements). The recurring fixes tend to recur across projects with even a higher level of repetitiveness than the within-project fixes. Third, we are able to collect empirical evidences to confirm that software reuse practice in programming creates similar modules in source code; and similar modules tends to have similar bugs, thus might require fixes in the similar manners. Specifically, in a software project, there exist multiple objects that play similar roles, provide similar functions, or perform similar interactions with the other objects in the system that need to be built. Those functions/interactions are realized in similar code and/or in similar object usage scenarios. Then, when the functions/interactions need to be changed (e.g. due to bug fixing), the corresponding code/usages are changed in the similar manners, resulting in recurring fixes. We call them code peers. When such a program unit is buggy and needs to be fixed, the peer code units need to be considered for fixing as well.\n\nLeveraging such findings, we developed a novel methodology to characterize and to identify the similar code fragments in a software system (via code clones and code peers) that could be fixed in the similar manners. We then developed a method to propagate the fixing changes in a code fragment to other fragments. More specifically, we developed new concepts, techniques, algorithms, and automated tools to characterize and measure the similarity of code units involved in prior known fixed defects, and to identify the code locations of potential buggy code units. Our tool derives the fixing recommendations by matching them to the peered and cloned code units of the prior known defects. Our empirical evaluation showed that our method is reliable and has high accuracy. We also developed the methods to analyze recurring defects through detecting duplicate defect reports and to better recover the links between the defect reports and their corresponding fixes. Our work was awarded an ACM SIGSO..."
 }
}