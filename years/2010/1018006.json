{
 "awd_id": "1018006",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:  Small:  An Integrated Parallel Constraint Programming Platform for Combinatorial Search Problems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2010-08-01",
 "awd_exp_date": "2015-07-31",
 "tot_intn_awd_amt": 277065.0,
 "awd_amount": 277065.0,
 "awd_min_amd_letter_date": "2010-07-28",
 "awd_max_amd_letter_date": "2010-07-28",
 "awd_abstract_narration": "Many real-world problems, ranging from scheduling in industrial production lines, planning for intelligent robots, protein structure predication, resource allocation, to various network optimization problems are combinatorial search problems. Constraint Programming (CP) and Answer Set Programming (ASP) are emerging techniques for solving these problems. CP over Finite Domains (FD) has had great successes in many application areas, such as scheduling, where use of global constraints is very effective. ASP has been found amenable to knowledge-intensive search problems such as planning and configuration problems. Recently, there has been great interest in parallelizing CP and ASP solvers to take advantage of the power provided by multi-core processors. \r\n\r\nThis research aims to develop an integrated parallel constraint programming platform for combinatorial search problems. It entails three tasks. Firstly, this research will enhance the power of CLP(FD) (Constraint Logic Programming over FD) by enabling constraints over Composite Finite Domains (CFD). The resulting language, CLP(CFD), allows for natural and efficient modeling of problems with multi-attributed objects. Action Rules (AR), a successful language developed by the PI, will be enhanced and used to implement CLP(CFD). Secondly, this research will develop a compiler to translate ASP programs into AR. For an ASP program, the generated program maintains a partial answer set as a pair of disjoint tuple sets and uses labeling and propagation to compute answer sets. Unlike most ASP solvers, the AR-based solver requires no prior grounding of programs. Thirdly, this research will parallelize AR. Since AR is used as a common intermediate language for both CLP(CFD) and ASP, a parallel implementation of AR will directly result in parallel solvers for CLP(CFD) and ASP. This research will advance the implementation techniques for constraint languages and the resulting system will benefit a wide range of real-world applications.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Neng-Fa",
   "pi_last_name": "Zhou",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Neng-Fa Zhou",
   "pi_email_addr": "zhou@sci.brooklyn.cuny.edu",
   "nsf_id": "000176358",
   "pi_start_date": "2010-07-28",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "CUNY Brooklyn College",
  "inst_street_address": "2900 BEDFORD AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BROOKLYN",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "7189515622",
  "inst_zip_code": "112102850",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "NY09",
  "org_lgl_bus_name": "RESEARCH FOUNDATION OF THE CITY UNIVERSITY OF NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "XNAKYW3FTSE1"
 },
 "perf_inst": {
  "perf_inst_name": "CUNY Brooklyn College",
  "perf_str_addr": "2900 BEDFORD AVE",
  "perf_city_name": "BROOKLYN",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "112102850",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "NY09",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 277065.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>While supported by the grant, the PI, his students, and his collaborators have developed several important algorithms and implementation techniques, including pair-wise arc consistency for constraints over complex domains, an extension of mode-directed tabling for dynamic programming and machine learning applications, an extended hash-consing scheme for sharing ground structured terms in tabled logic programs, tabling for planning, and a SAT compiler. One of PI's students prototyped a parallel system using p-threads for parallelizing propagators for the all_different global constraint.</p>\n<p>During the past three years, the PI and his student, Jonathan Fruhman, designed Picat (picat-lang.org)---a simple, yet powerful, logic-based programming language for a variety of applications. Picat incorporates many features from logic programming, functional programming, scripting, and modeling languages for better productivity of software development. Picat incorporates many of the algorithms and implementation techniques developed by this research project.</p>\n<p>Picat provides a set of tools for solving combinatorial search problems. It has an embedded CP solver that uses action rules to encode propagators. Picat also includes a SAT compiler, which compiles high-level constraints into log-encoded CNF (Conjunctive Normal Form) codes. The competition results of MiniZinc Challenge 2015 show that Picat's SAT compiler scored the highest on 5 of the 20 benchmarks, and was second on the benchmarks that do not use global constraints.</p>\n<p>Picat has become a powerful and flexible modeling and solving language for planning problems. As a solving system, Picat's planner tables states in order to avoid repeating the exploration of the same state; employs the hash-consing technique to share common state data and to speed up the equality testing of states; utilizes tabled states to effectively perform resource-bounded search. Experiments have shown that declarative models that exploit Picat's features by using structural state representations, common-sense domain knowledge, and heuristics can significantly outperform ASP (Answer Set Programming) and PDDL (plan domain description language) encodings run by the best planners, including domain-dependent ones.</p>\n<p>Picat has started impacting the field. After Picat 1.0 was released in February 2015, Lucy Black, who is not related to the project, wrote an article in April 2015 titled \"Is Logic Programming Making A Comeback\", which highly appraises the Picat system's versatility for problem solving. Sergii Dymchenko, who is not related to the project either, has published an article titled \"Declaratively Solving Google Code Jam Problems with Picat\", which summarizes Picat as follows: ``in some cases the use of Picat simplifies the implementation compared to conventional imperative programming languages, while in others it allows to directly convert the problem statement into an efficiently solvable declarative problem specification without inventing an imperative algorithm''. Despite a new language, Picat was used by five contestants, none of whom was a Picat developer, in the 2015 GCJ contest, while only one contestant used Prolog.&nbsp;</p>\n<p>This&nbsp; Picat project has also discovered new research challenges. First, although Picat is a powerful and flexible modeling and solving language for planning problems, it is a challenge for novice programmers to develop efficient planning models. In order to address this issue, future work needs to be done to devise algorithms for translating simple specifications into efficient Picat models that automatically exploit structural representations, symmetries, domain control knowledge, and heuristics. Second, the Picat-SAT compiler is not strong at dealing with global constraints. There are no established algorithms for decomposing many of the global constraints into SAT. Future work needs to be...",
  "por_txt_cntn": "\nWhile supported by the grant, the PI, his students, and his collaborators have developed several important algorithms and implementation techniques, including pair-wise arc consistency for constraints over complex domains, an extension of mode-directed tabling for dynamic programming and machine learning applications, an extended hash-consing scheme for sharing ground structured terms in tabled logic programs, tabling for planning, and a SAT compiler. One of PI's students prototyped a parallel system using p-threads for parallelizing propagators for the all_different global constraint.\n\nDuring the past three years, the PI and his student, Jonathan Fruhman, designed Picat (picat-lang.org)---a simple, yet powerful, logic-based programming language for a variety of applications. Picat incorporates many features from logic programming, functional programming, scripting, and modeling languages for better productivity of software development. Picat incorporates many of the algorithms and implementation techniques developed by this research project.\n\nPicat provides a set of tools for solving combinatorial search problems. It has an embedded CP solver that uses action rules to encode propagators. Picat also includes a SAT compiler, which compiles high-level constraints into log-encoded CNF (Conjunctive Normal Form) codes. The competition results of MiniZinc Challenge 2015 show that Picat's SAT compiler scored the highest on 5 of the 20 benchmarks, and was second on the benchmarks that do not use global constraints.\n\nPicat has become a powerful and flexible modeling and solving language for planning problems. As a solving system, Picat's planner tables states in order to avoid repeating the exploration of the same state; employs the hash-consing technique to share common state data and to speed up the equality testing of states; utilizes tabled states to effectively perform resource-bounded search. Experiments have shown that declarative models that exploit Picat's features by using structural state representations, common-sense domain knowledge, and heuristics can significantly outperform ASP (Answer Set Programming) and PDDL (plan domain description language) encodings run by the best planners, including domain-dependent ones.\n\nPicat has started impacting the field. After Picat 1.0 was released in February 2015, Lucy Black, who is not related to the project, wrote an article in April 2015 titled \"Is Logic Programming Making A Comeback\", which highly appraises the Picat system's versatility for problem solving. Sergii Dymchenko, who is not related to the project either, has published an article titled \"Declaratively Solving Google Code Jam Problems with Picat\", which summarizes Picat as follows: ``in some cases the use of Picat simplifies the implementation compared to conventional imperative programming languages, while in others it allows to directly convert the problem statement into an efficiently solvable declarative problem specification without inventing an imperative algorithm''. Despite a new language, Picat was used by five contestants, none of whom was a Picat developer, in the 2015 GCJ contest, while only one contestant used Prolog. \n\nThis  Picat project has also discovered new research challenges. First, although Picat is a powerful and flexible modeling and solving language for planning problems, it is a challenge for novice programmers to develop efficient planning models. In order to address this issue, future work needs to be done to devise algorithms for translating simple specifications into efficient Picat models that automatically exploit structural representations, symmetries, domain control knowledge, and heuristics. Second, the Picat-SAT compiler is not strong at dealing with global constraints. There are no established algorithms for decomposing many of the global constraints into SAT. Future work needs to be done to investigate encoding algorithms for global constraints into SAT and SMT.\n\n \n\n\t\t\t\t\tLast Modifi..."
 }
}