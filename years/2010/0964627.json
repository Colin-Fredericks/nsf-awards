{
 "awd_id": "0964627",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CSR: Medium: Collaborative Research: Scaling the Implicitly Parallel Programming Model with Lifelong Thread Extraction and Dynamic Adaptation",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2010-05-01",
 "awd_exp_date": "2014-04-30",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 261679.0,
 "awd_min_amd_letter_date": "2010-03-08",
 "awd_max_amd_letter_date": "2012-10-10",
 "awd_abstract_narration": "The microprocessor industry has moved toward multicore designs to leverage increasing transistor counts in the face of physical and micro-architectural limitations.  Unfortunately, providing multiple cores does not translate into performance for most applications. Rather than pushing all the burden onto programmers, this project advocates the use of the implicitly parallel programming model to eliminate the laborious and error-prone process of explicit parallel programming.  Implicit parallel programming leverages sequential languages to facilitate shorter development and debug cycles, and relies on automatic tools, both static compilers and run-time systems, to identify parallelism and customize it to the target platform.  Implicit parallelism can be systematically extracted using: (1) decoupled softwarepipelining, a technique to extract the pipeline parallelism found in many sequential applications; (2) low-frequency and high-confidence speculation to overcome limitations of memory dependence analysis; (3) whole-program scope for parallelization to eliminate analysis boundaries; (4) simple extensions to the sequential programming model that give the programmer the power to refine the meaning of a program; (5) dynamic adaptation to ensure efficiency is maintained across changing environments. This project is developing the set of technologies to realize an implicitly parallel programming system with scalable, lifelong thread extraction and dynamic adaptation.  At the broader level, the implicitly parallel programming approach will free programmers to consider the problems they are trying to solve, rather than forcing them to overcome the processor industry's failure to continue to scale performance.  This approach will keep computers accessible, helping computing to have the same increasingly positive impact on other fields.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Mary Lou",
   "pi_last_name": "Soffa",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Mary Lou Soffa",
   "pi_email_addr": "soffa@cs.virginia.edu",
   "nsf_id": "000203853",
   "pi_start_date": "2012-10-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Kim",
   "pi_last_name": "Hazelwood",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Kim Hazelwood",
   "pi_email_addr": "hazelwood@virginia.edu",
   "nsf_id": "000482856",
   "pi_start_date": "2010-03-08",
   "pi_end_date": "2012-10-10"
  }
 ],
 "inst": {
  "inst_name": "University of Virginia Main Campus",
  "inst_street_address": "1001 EMMET ST N",
  "inst_street_address_2": "",
  "inst_city_name": "CHARLOTTESVILLE",
  "inst_state_code": "VA",
  "inst_state_name": "Virginia",
  "inst_phone_num": "4349244270",
  "inst_zip_code": "229034833",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "VA05",
  "org_lgl_bus_name": "RECTOR & VISITORS OF THE UNIVERSITY OF VIRGINIA",
  "org_prnt_uei_num": "",
  "org_uei_num": "JJG6HU8PA4S5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Virginia Main Campus",
  "perf_str_addr": "1001 EMMET ST N",
  "perf_city_name": "CHARLOTTESVILLE",
  "perf_st_code": "VA",
  "perf_st_name": "Virginia",
  "perf_zip_code": "229034833",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "VA05",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 128452.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 133227.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"MsoNormal\" style=\"margin-top: 0in; margin-right: .1in; margin-bottom: .0001pt; margin-left: .1in; line-height: normal; mso-layout-grid-align: none; text-autospace: none;\"><span>With  chip multiprocessors (CMPs) comes the promise of high-performance  computing on a desktop. CMPs impact the design, implementation and the  way that high performance applications execute. These applications,  which have become increasingly more complex, larger in scale, and handle  huge data sets, can benefit greatly from CMPs. These applications are  expected to use parallel systems with tens to several hundreds of nodes  to handle their ever growing problem sizes. For example, simulating  complex ocean circulation models requires exploiting significant  parallelism. Similarly, emerging applications in biomedical computing,  automated surgery, and data mining have inherent parallelism and CMPs  can increase their performance by several factors. With the shift to  CMPs, managing shared resources has become a critical issue in realizing  their full potential. In this research, we focused on the contention  for memory resources in a CMP.</span></p>\n<p class=\"MsoNormal\" style=\"margin-top: 0in; margin-right: .1in; margin-bottom: .0001pt; margin-left: .1in; line-height: normal; mso-layout-grid-align: none; text-autospace: none;\"><span>&nbsp;</span></p>\n<p class=\"MsoNormal\" style=\"margin-top: 0in; margin-right: .1in; margin-bottom: 10.0pt; margin-left: 6.0pt; line-height: normal;\"><span>To  develop approaches to reduce shared resource contention for emerging  multi-threaded applications, we studied how their performances are  affected by contention for a particular shared resource. We developed a  general methodology for characterizing multi-threaded applications by  determining the effect of shared-resource contention on performance.<span style=\"mso-spacerun: yes;\">&nbsp; </span>We characterized the applications using the PARSEC benchmark suite for shared-memory resource contention.<span style=\"mso-spacerun: yes;\">&nbsp; </span>The  characterization revealed several interesting aspects. Three of twelve  PARSEC benchmarks exhibit no contention for cache resources. Nine  exhibit contention for the L2-cache, with only three exhibiting  contention among their own threads&ndash;most contention is because of  competition with a co-runner. Interestingly, contention for the Front  Side Bus is a major factor and degrades performance by more than 11%</span></p>\n<p class=\"MsoNormal\" style=\"margin-bottom: .0001pt; line-height: normal; mso-layout-grid-align: none; text-autospace: none;\"><span>&nbsp;</span></p>\n<p class=\"MsoListParagraph\" style=\"margin-top: 0in; margin-right: 0in; margin-bottom: .0001pt; margin-left: 6.0pt; mso-add-space: auto; line-height: normal; mso-layout-grid-align: none; text-autospace: none;\"><span>Effective  resource and application management on CMPs requires consideration of  user specific requirements and dynamic adaption of management decisions  based on the actual run-time environment. However, designing an  algorithm to manage resources and applications that can dynamically  adapt based on the run-time environment is difficult because most  resource and application management and monitoring facilities are only  available at the OS level. We developed REEact, an infrastructure that  provides the capability to specify user-level management policies with  dynamic adaptation.<span style=\"mso-spacerun: yes;\">&nbsp; </span>REEact  is a virtual execution environment that provides a framework and core  services to quickly enable the design of custom management policies for  dynamically managing resources and applications.<span style=\"mso-spacerun: yes;\">&nbsp; </span>We  evaluated REEact on three case studies, each illustrating the use of  REEact to apply a specific dynamic management policy on a real CMP.  Through these case studies, we demonstrated that REEact can effective...",
  "por_txt_cntn": "With  chip multiprocessors (CMPs) comes the promise of high-performance  computing on a desktop. CMPs impact the design, implementation and the  way that high performance applications execute. These applications,  which have become increasingly more complex, larger in scale, and handle  huge data sets, can benefit greatly from CMPs. These applications are  expected to use parallel systems with tens to several hundreds of nodes  to handle their ever growing problem sizes. For example, simulating  complex ocean circulation models requires exploiting significant  parallelism. Similarly, emerging applications in biomedical computing,  automated surgery, and data mining have inherent parallelism and CMPs  can increase their performance by several factors. With the shift to  CMPs, managing shared resources has become a critical issue in realizing  their full potential. In this research, we focused on the contention  for memory resources in a CMP.\n \nTo  develop approaches to reduce shared resource contention for emerging  multi-threaded applications, we studied how their performances are  affected by contention for a particular shared resource. We developed a  general methodology for characterizing multi-threaded applications by  determining the effect of shared-resource contention on performance.  We characterized the applications using the PARSEC benchmark suite for shared-memory resource contention.  The  characterization revealed several interesting aspects. Three of twelve  PARSEC benchmarks exhibit no contention for cache resources. Nine  exhibit contention for the L2-cache, with only three exhibiting  contention among their own threads&ndash;most contention is because of  competition with a co-runner. Interestingly, contention for the Front  Side Bus is a major factor and degrades performance by more than 11%\n \nEffective  resource and application management on CMPs requires consideration of  user specific requirements and dynamic adaption of management decisions  based on the actual run-time environment. However, designing an  algorithm to manage resources and applications that can dynamically  adapt based on the run-time environment is difficult because most  resource and application management and monitoring facilities are only  available at the OS level. We developed REEact, an infrastructure that  provides the capability to specify user-level management policies with  dynamic adaptation.  REEact  is a virtual execution environment that provides a framework and core  services to quickly enable the design of custom management policies for  dynamically managing resources and applications.  We  evaluated REEact on three case studies, each illustrating the use of  REEact to apply a specific dynamic management policy on a real CMP.  Through these case studies, we demonstrated that REEact can effectively  and efficiently implement policies to dynamically manage resources and  adapt application execution.\n \nPrevious  research has shown that thread mapping is a powerful tool for resource  management. However, the difficulty of simultaneously managing multiple  hardware resources and the varying nature of the workloads has impeded  the efficiency of thread mapping algorithms. We developed an in-depth  analysis of PARSEC benchmarks running under different thread mappings to  investigate the interaction of various thread mappings with  microarchitectural resources, including L1 I/D-caches, I/D TLBs, L2  caches, hardware prefetchers, off-chip memory interconnects, branch  predictors, memory disambiguation units and the cores. Our experiments  show that when only memory resources are considered, thread mapping  improves an application\u00c6s performance by as much as 14% over the default  Linux scheduler. In contrast, when both memory and processor resources  are considered the mapping algorithm achieves performance improvements  by as much as 28%. \n \nWe  also developed ReSense, the first run-time system that uses application  characteristic..."
 }
}