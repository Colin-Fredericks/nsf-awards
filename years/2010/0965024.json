{
 "awd_id": "0965024",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Vitamin C: A Deductive Framework for Generating Analyzers for C Programs",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2009-07-01",
 "awd_exp_date": "2012-07-31",
 "tot_intn_awd_amt": 259198.0,
 "awd_amount": 266698.0,
 "awd_min_amd_letter_date": "2009-10-27",
 "awd_max_amd_letter_date": "2010-01-27",
 "awd_abstract_narration": "0702600\r\n\r\nVitamin C: A Framework for Generating Analyzers for C Programs\r\n\r\nJerry James\r\n\r\nThis project intends to increase the level of confidence in software systems deployed in mission-critical environments by providing a comprehensive platform for analyzing various aspects of software correctness.  More precisely, it focuses on developing a deductive program transformation framework for automatically generating specialized analyzers for C programs in an aspect-oriented way.  In contrast with code analyzers that take arbitrary programs as input, this research will show how to synthesize a code analyzer that is specialized to the program under analysis and the correctness aspect under consideration.  Such specialization will open up new vistas for making code analyzers more efficient than is currently possible, as well as providing a platform for experimenting with different program analysis algorithms.  The project will lead to the development of a deductive framework for a new class of modal logics.  In addition, it will lead to a study of the application of partial evaluation and program transformation techniques for generating efficient program analyzers suited to particular analysis problems.  The results of this project will be used to aid open source developers in analyzing their software projects, and to introduce students to mathematically rigorous techniques for reasoning about the correctness of software.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Supratik",
   "pi_last_name": "Mukhopadhyay",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Supratik Mukhopadhyay",
   "pi_email_addr": "supratik@csc.lsu.edu",
   "nsf_id": "000209895",
   "pi_start_date": "2009-10-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Louisiana State University",
  "inst_street_address": "202 HIMES HALL",
  "inst_street_address_2": "",
  "inst_city_name": "BATON ROUGE",
  "inst_state_code": "LA",
  "inst_state_name": "Louisiana",
  "inst_phone_num": "2255782760",
  "inst_zip_code": "708030001",
  "inst_country_name": "United States",
  "cong_dist_code": "06",
  "st_cong_dist_code": "LA06",
  "org_lgl_bus_name": "LOUISIANA STATE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "ECQEYCHRNKJ4"
 },
 "perf_inst": {
  "perf_inst_name": "Louisiana State University",
  "perf_str_addr": "202 HIMES HALL",
  "perf_city_name": "BATON ROUGE",
  "perf_st_code": "LA",
  "perf_st_name": "Louisiana",
  "perf_zip_code": "708030001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "06",
  "perf_st_cong_dist": "LA06",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0107",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 45403.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 213795.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 7500.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>We have been able to accomplish the following tasks in this project</p>\n<p>&nbsp;</p>\n<p>1. Development of a deductive abstraction framework that provides safe approximations of program semantics</p>\n<p>2. Implementation of a program transformation framework for weaving in analysis aspects written in FCTL</p>\n<p>3. Development of the syntax and semantics of a modal logic VCL (Verification of C Logic) for specifying properties of C programs</p>\n<p>4. Implementation of a resolution procedure with constraints</p>\n<p>5. Extension and implementation of the program transformation framework for dealing with pointers and arrays and incorporating VCL formulas as analysis aspects</p>\n<p>6. An abstraction framework for deriving an abstract resolution procedure and predicting its accuracy and termination</p>\n<p>7. Introduction of a logic with a sound and complete proof system for reasoning about C and Java &nbsp;programs with library function calls (model-based static analysis)</p>\n<p>8. Preliminary definition of a soft analysis approach for generating unit tests from results of static analysis</p>\n<p>9. Development of a language-based abstraction framework</p>\n<p>10. Integration of deductive verification in higher order logic with static analysis and a case study of verifying an open source Netgear router using deductive static analysis</p>\n<p>&nbsp;</p>\n<p>Our project introduces a new paradigm in analysis of software: on-demand intelligent program analysis. It draws ideas from hitherto unexplored areas of constructive logic and type theory to develop techniques for automatically synthesizing \"static program monitors\" on-demand from specifications of analysis aspects. These \"monitors\" accept the \"collecting semantics\" of the source code as input and decide whether it conforms to the given analysis aspect. In addition, our project helps shift the focus of program analysis from \"hunting for shallow application-independent errors\" to deeper application-dependent errors\".</p>\n<p>&nbsp;</p>\n<p>The major discoveries&nbsp; can be summarized in the following bullets</p>\n<p>1. Development of a language-based abstraction framework</p>\n<p>2. A case study of verifying an open source Netgear router using deductive static analysis. Christopher Steinmuller, an undergraduate student, together with graduate student Zheng Lu, formally verified the conformance of the firmware of Netgear's WNR 3500 L wireless router with RFC 2131 based on which it is designed. This resulted in the world's first router with formally verified router. Formally verified OCAML code for the router firmware was generated automatically. Based on this work, Christopher Steinmuller won an honorable mention in CRA Undergraduate Research award competition, 2011.</p>\n<p>3.&nbsp; Analysis of termination and other liveness properties of an imperative program can be reduced to termination proof synthesis for simple loops, <em>i.e.</em>, loops with only variable updates in the loop body. Among simple loops, the subset of <em>Linear Simple Loops </em>(LSLs) is particular interesting because it is common in practice and expressive in theory. Existing techniques can successfully synthesize a linear ranking function for an LSL if there exists one. However, when a terminating LSL does not have a linear ranking function, these techniques fail. &nbsp;We describe an automatic method that generates proofs of universal termination for LSLs based on the synthesis of disjunctive ranking relations. The method repeatedly finds linear ranking functions on parts of the state space and checks whether the transitive closure of the transition relation is included in the union of the ranking relations. Our method extends the work of Podelski and Rybalchenko. We have implemented a prototype of the method and have shown experimental evidence of the effectiveness of our method.</p>\n<p>4. We combined static analysis techniques with model-based deductiv...",
  "por_txt_cntn": "\nWe have been able to accomplish the following tasks in this project\n\n \n\n1. Development of a deductive abstraction framework that provides safe approximations of program semantics\n\n2. Implementation of a program transformation framework for weaving in analysis aspects written in FCTL\n\n3. Development of the syntax and semantics of a modal logic VCL (Verification of C Logic) for specifying properties of C programs\n\n4. Implementation of a resolution procedure with constraints\n\n5. Extension and implementation of the program transformation framework for dealing with pointers and arrays and incorporating VCL formulas as analysis aspects\n\n6. An abstraction framework for deriving an abstract resolution procedure and predicting its accuracy and termination\n\n7. Introduction of a logic with a sound and complete proof system for reasoning about C and Java  programs with library function calls (model-based static analysis)\n\n8. Preliminary definition of a soft analysis approach for generating unit tests from results of static analysis\n\n9. Development of a language-based abstraction framework\n\n10. Integration of deductive verification in higher order logic with static analysis and a case study of verifying an open source Netgear router using deductive static analysis\n\n \n\nOur project introduces a new paradigm in analysis of software: on-demand intelligent program analysis. It draws ideas from hitherto unexplored areas of constructive logic and type theory to develop techniques for automatically synthesizing \"static program monitors\" on-demand from specifications of analysis aspects. These \"monitors\" accept the \"collecting semantics\" of the source code as input and decide whether it conforms to the given analysis aspect. In addition, our project helps shift the focus of program analysis from \"hunting for shallow application-independent errors\" to deeper application-dependent errors\".\n\n \n\nThe major discoveries  can be summarized in the following bullets\n\n1. Development of a language-based abstraction framework\n\n2. A case study of verifying an open source Netgear router using deductive static analysis. Christopher Steinmuller, an undergraduate student, together with graduate student Zheng Lu, formally verified the conformance of the firmware of Netgear's WNR 3500 L wireless router with RFC 2131 based on which it is designed. This resulted in the world's first router with formally verified router. Formally verified OCAML code for the router firmware was generated automatically. Based on this work, Christopher Steinmuller won an honorable mention in CRA Undergraduate Research award competition, 2011.\n\n3.  Analysis of termination and other liveness properties of an imperative program can be reduced to termination proof synthesis for simple loops, i.e., loops with only variable updates in the loop body. Among simple loops, the subset of Linear Simple Loops (LSLs) is particular interesting because it is common in practice and expressive in theory. Existing techniques can successfully synthesize a linear ranking function for an LSL if there exists one. However, when a terminating LSL does not have a linear ranking function, these techniques fail.  We describe an automatic method that generates proofs of universal termination for LSLs based on the synthesis of disjunctive ranking relations. The method repeatedly finds linear ranking functions on parts of the state space and checks whether the transitive closure of the transition relation is included in the union of the ranking relations. Our method extends the work of Podelski and Rybalchenko. We have implemented a prototype of the method and have shown experimental evidence of the effectiveness of our method.\n\n4. We combined static analysis techniques with model-based deductive verification using SMT solvers to provide a framework that, given an analysis aspect of the source code, automatically generates an analyzer capable of inferring information about that aspect. The analyzer is generated by trans..."
 }
}