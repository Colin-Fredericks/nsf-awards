{
 "awd_id": "1016565",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "AF:  Small:  Information Theory-Based Methods for Hardness Amplification and Compression",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Dmitri Maslov",
 "awd_eff_date": "2010-09-01",
 "awd_exp_date": "2014-08-31",
 "tot_intn_awd_amt": 406410.0,
 "awd_amount": 406410.0,
 "awd_min_amd_letter_date": "2010-07-21",
 "awd_max_amd_letter_date": "2012-07-02",
 "awd_abstract_narration": "This project aims to investigate two kinds of problems in theoretical computer science and information theory. The first is about Hardness Amplification. Here the goal is to find ways to manipulate functions that are hard to compute in some computational model to obtain new functions that are significantly harder to compute. For example, in communication complexity, one might expect that computing k copies of a functionality should take k times the communication, but to date we do not know how to prove this. Prior work has shown that the communication must grow by a factor of roughly the square root of k, but it remains to be seen whether this can be increased to a factor of k. Another domain where this kind of problem makes sense is for streaming algorithms. In a streaming algorithm, the input arrives as a massive data stream that cannot be stored. The goal is to compute a function of the data using as little memory as possible. One might expect that handling k independent streams of data in parallel should require k times the memory, yet we do not know how to prove this.  Similar questions can be asked about amplifying the hardness of approximation algorithms, and showing that composing a function with itself increases its circuit depth. This kind of question is related to proving lowerbounds, a central goal of theoretical computer science.\r\n\r\nThe second kind of problem is about compression. Today we have a good understanding of how single messages can be compressed so that the number of bits it takes to represent them is more or less equal to the information that they carry. Here the information can be measured using Shannon's Entropy function, or in the case of randomized transmissions, the mutual information between the inputs and the messages. However, if we have an interactive communication process between several parties, it is not clear how to reduce the communication in the interaction so that the communication is close to the amount of information conveyed between the parties. This problem is closely related to the problem of amplifying the communication complexity of a function, discussed above. Prior work has shown how to reduce the communication of a protocol that conveys small information, and such a compression scheme turns out to be useful to prove that computing many copies of a function must require larger communication.  Indeed, an optimal compression scheme would give an optimal result in the setting of hardness amplification. Finding such a scheme is a major goal of this project. This project also aims to study the compression of memory used by streaming algorithms. Given a streaming algorithm, can we always reduce the memory usage of the algorithm until the number of bits used is close to the amount of information stored by the algorithm. In this setting, it is not clear what the right measure of information should be, and defining a meaningful measure of the information is another goal.\r\n\r\nThe common theme tying the problems of this proposal together is an information theory based method that is applicable to these problems.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Anup",
   "pi_last_name": "Rao",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Anup Rao",
   "pi_email_addr": "anuprao@u.washington.edu",
   "nsf_id": "000537421",
   "pi_start_date": "2010-07-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Washington",
  "inst_street_address": "4333 BROOKLYN AVE NE",
  "inst_street_address_2": "",
  "inst_city_name": "SEATTLE",
  "inst_state_code": "WA",
  "inst_state_name": "Washington",
  "inst_phone_num": "2065434043",
  "inst_zip_code": "981951016",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "WA07",
  "org_lgl_bus_name": "UNIVERSITY OF WASHINGTON",
  "org_prnt_uei_num": "",
  "org_uei_num": "HD1WMN6945W6"
 },
 "perf_inst": {
  "perf_inst_name": "University of Washington",
  "perf_str_addr": "4333 BROOKLYN AVE NE",
  "perf_city_name": "SEATTLE",
  "perf_st_code": "WA",
  "perf_st_name": "Washington",
  "perf_zip_code": "981951016",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "WA07",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  },
  {
   "pgm_ele_code": "792700",
   "pgm_ele_name": "COMPLEXITY & CRYPTOGRAPHY"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 119642.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 139908.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 146860.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>&nbsp;</p>\n<p>In the past year, we worked on several projects related to using  methods from information theory to prove lower bounds on communication  complexity and other computational models.&nbsp; In addition, the PI  co-organized a workshop at the Banff International Research Station,  gathering experts to have a workshop on \"Communication Complexity and  its Applications\" for the first time in a couple of decades.&nbsp;</p>\n<p><br />One of the major goals of theoretical computer science is to come  up with ways to prove that known algorithms are optimal.&nbsp;  Unfortunately, despite much effort we know of no way to do this today,  besides arguing that linear time algorithms are optimal because they  must necessarily read all of their input.&nbsp; We invested a lot of effort in  the last year and a half on making progress on this issue.&nbsp;</p>\n<p><br />We defined a new natural model of  computation using circuits.&nbsp; These circuits are allowed to have gates  with fan-in up to 2n/3, where n is the number of bits in the input.&nbsp;  Each gate may compute an arbitrary function of its input.&nbsp; We showed  that proving lower bounds on this model of computation would give new  size depth tradeoffs for boolean circuits, a major open problem that has  remained unresolved for about 40 years.&nbsp; Specifically, it would give a  proof that there is no linear sized logarithmic &nbsp;(in n) depth circuit  for computing some explicit function of n bits.&nbsp; The ultimate goal is to  prove that there is no linear sized circuit for computing some explicit  function, but we don't even know how to prove a lower bound when the  depth is restricted to being logarithmic.&nbsp; Our work defined a model of  communication that can simulate such circuits, and so enables one to  attack the lower bound problem using methods from communication  complexity.&nbsp; The model is as follows:&nbsp; there are k &nbsp;= n/100 players.&nbsp;  Each player can choose to see some n/3 of the input bits.&nbsp; One needs to  argue that if each player can send only one bit, then they cannot  compute the function.</p>\n<p><br />We studied the problem of compressing  communication between two parties.&nbsp; Despite much effort, the best result  in this direction is still obtained in our work with Barak, et. al.,  where we showed that any protocol that reveals I bits of information and  has C bits of communication can be simulated with a protocol with  communication roughly sqrt(IC).&nbsp; We studied the case where the  information is asymmetric.&nbsp; Namely, one party learns much more  information than the other during this protocol.&nbsp; We showed that if one  party learns I_A bits and the learns I_B bits (so the total information  is I = I_A+I_B, then the protocol can be compressed to get communication  proportional to roughly (I_A)^{1/4} C^{3/4} + I_A+I_B, beating the  earlier result for certain values of I_A, I_B.&nbsp;</p>\n<p><br />In work with faculty from Technion, we studied the Number-on-forehead  model of communication complexity.&nbsp; Here k parties each have an input on  their forehead, and wish to compute some function of all inputs.&nbsp; Each  party can only see the others' inputs.&nbsp; A classical problem (with many  applications) that has been studied is the problem of computing set  disjointness.&nbsp; The parties each have subsets of {1,2,...,n} on their  forehead and want to know whether the intersection of all the sets is  empty or not.&nbsp; A long sequence of works has attempted to prove lower  bounds on this model, culminating (prior to our work) on a lower bound  of sqrt(n)/2^k for this problem.&nbsp; In our work we improved the lower  bound to n/4^k, which is almost optimal.&nbsp;</p>\n<p><br />We studied extending the information  theory methods we have developed to the setting of streaming algorithms.&nbsp;  We defined a measure of information for streaming algor...",
  "por_txt_cntn": "\n \n\nIn the past year, we worked on several projects related to using  methods from information theory to prove lower bounds on communication  complexity and other computational models.  In addition, the PI  co-organized a workshop at the Banff International Research Station,  gathering experts to have a workshop on \"Communication Complexity and  its Applications\" for the first time in a couple of decades. \n\n\nOne of the major goals of theoretical computer science is to come  up with ways to prove that known algorithms are optimal.   Unfortunately, despite much effort we know of no way to do this today,  besides arguing that linear time algorithms are optimal because they  must necessarily read all of their input.  We invested a lot of effort in  the last year and a half on making progress on this issue. \n\n\nWe defined a new natural model of  computation using circuits.  These circuits are allowed to have gates  with fan-in up to 2n/3, where n is the number of bits in the input.   Each gate may compute an arbitrary function of its input.  We showed  that proving lower bounds on this model of computation would give new  size depth tradeoffs for boolean circuits, a major open problem that has  remained unresolved for about 40 years.  Specifically, it would give a  proof that there is no linear sized logarithmic  (in n) depth circuit  for computing some explicit function of n bits.  The ultimate goal is to  prove that there is no linear sized circuit for computing some explicit  function, but we don't even know how to prove a lower bound when the  depth is restricted to being logarithmic.  Our work defined a model of  communication that can simulate such circuits, and so enables one to  attack the lower bound problem using methods from communication  complexity.  The model is as follows:  there are k  = n/100 players.   Each player can choose to see some n/3 of the input bits.  One needs to  argue that if each player can send only one bit, then they cannot  compute the function.\n\n\nWe studied the problem of compressing  communication between two parties.  Despite much effort, the best result  in this direction is still obtained in our work with Barak, et. al.,  where we showed that any protocol that reveals I bits of information and  has C bits of communication can be simulated with a protocol with  communication roughly sqrt(IC).  We studied the case where the  information is asymmetric.  Namely, one party learns much more  information than the other during this protocol.  We showed that if one  party learns I_A bits and the learns I_B bits (so the total information  is I = I_A+I_B, then the protocol can be compressed to get communication  proportional to roughly (I_A)^{1/4} C^{3/4} + I_A+I_B, beating the  earlier result for certain values of I_A, I_B. \n\n\nIn work with faculty from Technion, we studied the Number-on-forehead  model of communication complexity.  Here k parties each have an input on  their forehead, and wish to compute some function of all inputs.  Each  party can only see the others' inputs.  A classical problem (with many  applications) that has been studied is the problem of computing set  disjointness.  The parties each have subsets of {1,2,...,n} on their  forehead and want to know whether the intersection of all the sets is  empty or not.  A long sequence of works has attempted to prove lower  bounds on this model, culminating (prior to our work) on a lower bound  of sqrt(n)/2^k for this problem.  In our work we improved the lower  bound to n/4^k, which is almost optimal. \n\n\nWe studied extending the information  theory methods we have developed to the setting of streaming algorithms.   We defined a measure of information for streaming algorithms and proved  several results about compressing algorithms.\n\n\t\t\t\t\tLast Modified: 10/02/2014\n\n\t\t\t\t\tSubmitted by: Anup Rao"
 }
}