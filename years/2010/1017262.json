{
 "awd_id": "1017262",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: Balancing Expressiveness and Modular Reasoning for Aspect-Oriented Programming",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2010-08-15",
 "awd_exp_date": "2015-07-31",
 "tot_intn_awd_amt": 241029.0,
 "awd_amount": 241029.0,
 "awd_min_amd_letter_date": "2010-08-04",
 "awd_max_amd_letter_date": "2011-09-19",
 "awd_abstract_narration": "Software systems are poised to keep growing in complexity and permeate deeper into the critical infrastructures of society. The complexity of these systems is exceeding the limits of existing modularization mechanisms and reliability requirements are becoming stringent. Development of new separation of concerns (SoC) techniques is thus vital to make software more reliable and maintainable. Implicit invocation (II) and aspect-oriented (AO) programming languages provide related but distinct mechanisms for separation of concerns. The proposed work encompasses fundamental and practical efforts to improve modularization and reasoning mechanisms for II and AO languages, which is a long standing challenge for both kinds of languages. Addressing these challenges has the potential to significantly improve the quality of software by easing the adoption of new separation of concerns techniques.\r\n\r\nThe project will proceed using the experimental language, Ptolemy, which blends both II and AO ideas. Ptolemy has explicitly announced events, which are defined in interfaces called \"event types\". Event types help separate concerns and decouple advice from the code it advises. Event type declarations also offer a place to specify advice. The explicit announcement of events allows the possibility of careful reasoning about correctness of Ptolemy programs, since it is possible to reason about parts of the program where there are no events in a conventional manner. The project aims to investigate reasoning by developing a formal specification language and verification technique. The approach is based on the idea of greybox (\"model program'') specifications, as found in JML and the refinement calculus. There are known techniques for reasoning about uses of abstractions that have model program specifications, and the project will apply these to Ptolemy. The intellectual merit is in the treatment of expressions in Ptolemy that announce events and those that cause an advice to proceed. A straightforward adaptation of existing reasoning techniques to these cases appears to require a whole program analysis, which is generally not desirable for modular and scalable verification. The project also aims to investigate the utility and effectiveness of Ptolemy and its specification system. A software evolution analysis will be conducted to study the ability of competing aspect-oriented, implicit invocation, and Ptolemy implementations of open source projects to withstand change. Showing Ptolemy's benefits over II and AO languages will help software designers in deciding on advanced mechanisms for separation of concerns.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Gary",
   "pi_last_name": "Leavens",
   "pi_mid_init": "T",
   "pi_sufx_name": "",
   "pi_full_name": "Gary T Leavens",
   "pi_email_addr": "Leavens@ucf.edu",
   "nsf_id": "000331890",
   "pi_start_date": "2010-08-04",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "The University of Central Florida Board of Trustees",
  "inst_street_address": "4000 CENTRAL FLORIDA BLVD",
  "inst_street_address_2": "",
  "inst_city_name": "ORLANDO",
  "inst_state_code": "FL",
  "inst_state_name": "Florida",
  "inst_phone_num": "4078230387",
  "inst_zip_code": "328168005",
  "inst_country_name": "United States",
  "cong_dist_code": "10",
  "st_cong_dist_code": "FL10",
  "org_lgl_bus_name": "THE UNIVERSITY OF CENTRAL FLORIDA BOARD OF TRUSTEES",
  "org_prnt_uei_num": "",
  "org_uei_num": "RD7MXJV7DKT9"
 },
 "perf_inst": {
  "perf_inst_name": "The University of Central Florida Board of Trustees",
  "perf_str_addr": "4000 CENTRAL FLORIDA BLVD",
  "perf_city_name": "ORLANDO",
  "perf_st_code": "FL",
  "perf_st_name": "Florida",
  "perf_zip_code": "328168005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "10",
  "perf_st_cong_dist": "FL10",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 78831.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 162198.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><strong>Intellectual Merit</strong></p>\n<p><br />In formal methods, which is a subfield of the Computer Science fields of software engineering and programming languages there is presently an ongoing question as to how to best design and reason about complex software. It is accepted wisdom that software should be designed from modular parts, so that these parts can be independently maintained and improved. This is often difficult when the software must satisfy several different concerns, such as security and usability. It is also important to be able to specify what the software should do and to verify that it works as specified in a modular fashion. Modularity in general is important for scalability: when a system has a modular design, it can be constructed and maintained by a large team working largely independently, given specifications for module interfaces. When one can reason about a system modularly, then verification efforts also scale to larger and larger systems.&nbsp;</p>\n<p><br />Implicit invocation and aspect-oriented techniques (such as pointcuts and advice as found in AspectJ) help with modular design, by decoupling parts of a large software system. In essence, both allow events to be announced, which allows bits of code to be run in response. These bits of code, called handlers or advice, are not directly referred to by the code that announces events, leading to very modular (loosely-coupled) connections between different parts of a program; this is good for design modularity and thus for evolution and maintenance of programs. However, precisely because they are not immediately and strongly connected to the code announcing an event, it is difficult to modularly reason about handlers and advice, because modular reasoning must be local to a piece of code, although it can use specifications of used code.</p>\n<p><br />The main achievement of this grant is that we showed that it is possible to do modular verification for Implicit Invocation (II) style languages, like Ptolemy. We demonstrated two such techniques. The first is \"translucid contracts\", which use abstract programs to specify the control flow behavior of handlers and advised code. The second adds a separate \"rely clause\" to specify the behavior of the advised code. The implication of this is that II languages have most of the modularity advantages for design and code of AO languages, but now have a sound way to do modular specification and verification. &nbsp;Since II languages are nearly as expressive as AO languages, this goes a long way towards resolving the trade-off between modular design and modular verification: one can have both in an II language.</p>\n<p><br /><strong>Broader Impacts</strong></p>\n<p><strong>&nbsp;</strong><br />The world needs more complex and sophisticated software systems, and the more these participate in the world, the more they have cross-cutting demands placed on them. For example, we want our systems to be easy to use, but we also want them to be secure. For modular design, it is very helpful to be able to collect policies that affect each of these concerns in a single module. However, we also want our systems to be reliable. For this purpose we need to know what they are supposed to do and we need a high level of assurance that they do what they are supposed to. &nbsp;Being able to achieve both of these goals at once, as enabled by this project, will allow software engineers to build more complex and more reliable and trustworthy systems. That is the promise of the research results in this project.</p>\n<p><br />The project also supported two Ph.D. students who graduated from the University of Central Florida (UCF). Rochelle Elva, who graduated in Summer 2013 is now teaching Computer Science at UCF as a visiting lecturer. Jose Sanchez, who graduated in Spring 2015, has returned to Costa Rica where he teaches as a university professor.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t...",
  "por_txt_cntn": "\nIntellectual Merit\n\n\nIn formal methods, which is a subfield of the Computer Science fields of software engineering and programming languages there is presently an ongoing question as to how to best design and reason about complex software. It is accepted wisdom that software should be designed from modular parts, so that these parts can be independently maintained and improved. This is often difficult when the software must satisfy several different concerns, such as security and usability. It is also important to be able to specify what the software should do and to verify that it works as specified in a modular fashion. Modularity in general is important for scalability: when a system has a modular design, it can be constructed and maintained by a large team working largely independently, given specifications for module interfaces. When one can reason about a system modularly, then verification efforts also scale to larger and larger systems. \n\n\nImplicit invocation and aspect-oriented techniques (such as pointcuts and advice as found in AspectJ) help with modular design, by decoupling parts of a large software system. In essence, both allow events to be announced, which allows bits of code to be run in response. These bits of code, called handlers or advice, are not directly referred to by the code that announces events, leading to very modular (loosely-coupled) connections between different parts of a program; this is good for design modularity and thus for evolution and maintenance of programs. However, precisely because they are not immediately and strongly connected to the code announcing an event, it is difficult to modularly reason about handlers and advice, because modular reasoning must be local to a piece of code, although it can use specifications of used code.\n\n\nThe main achievement of this grant is that we showed that it is possible to do modular verification for Implicit Invocation (II) style languages, like Ptolemy. We demonstrated two such techniques. The first is \"translucid contracts\", which use abstract programs to specify the control flow behavior of handlers and advised code. The second adds a separate \"rely clause\" to specify the behavior of the advised code. The implication of this is that II languages have most of the modularity advantages for design and code of AO languages, but now have a sound way to do modular specification and verification.  Since II languages are nearly as expressive as AO languages, this goes a long way towards resolving the trade-off between modular design and modular verification: one can have both in an II language.\n\n\nBroader Impacts\n\n \nThe world needs more complex and sophisticated software systems, and the more these participate in the world, the more they have cross-cutting demands placed on them. For example, we want our systems to be easy to use, but we also want them to be secure. For modular design, it is very helpful to be able to collect policies that affect each of these concerns in a single module. However, we also want our systems to be reliable. For this purpose we need to know what they are supposed to do and we need a high level of assurance that they do what they are supposed to.  Being able to achieve both of these goals at once, as enabled by this project, will allow software engineers to build more complex and more reliable and trustworthy systems. That is the promise of the research results in this project.\n\n\nThe project also supported two Ph.D. students who graduated from the University of Central Florida (UCF). Rochelle Elva, who graduated in Summer 2013 is now teaching Computer Science at UCF as a visiting lecturer. Jose Sanchez, who graduated in Spring 2015, has returned to Costa Rica where he teaches as a university professor.\n\n \n\n\t\t\t\t\tLast Modified: 10/05/2015\n\n\t\t\t\t\tSubmitted by: Gary T Leavens"
 }
}