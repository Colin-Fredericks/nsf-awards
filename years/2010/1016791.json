{
 "awd_id": "1016791",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CSR: Small: Verifying Simulink-Stateflow models",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2010-08-01",
 "awd_exp_date": "2015-07-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 500000.0,
 "awd_min_amd_letter_date": "2010-08-06",
 "awd_max_amd_letter_date": "2011-07-05",
 "awd_abstract_narration": "The vast majority of commercial embedded systems are designed with simulation-based tools such as MathWork's Simulink and Stateflow.  While simulations are computationally efficient, they are not complete---they cannot be naively used to design systems with provable guarantees. This project aims to build tools and techniques to verify such models. To this end, the project overcomes two key technical hurdles.  First, it has been well known that Simulink-Stateflow (SLSF) models do not have any well-defined meaning. The mathematical description of a building block can be different from the simulated behavior that is generated numerically. This problem is addressed by defining semantics of SLSF models in terms of (possibly probabilistic) hybrid automata. Secondly, the class of Simulink models (translated to hybrid automata) that can be verified automatically by currently available techniques is rather restrictive. This second problem is addressed in this project by abstracting SLSF models into hybrid automata with simple dynamics, model checking the abstract models, and then refining the abstractions based on counterexamples generated by the model checker. Such a counterexample guided abstraction refinement framework provides semi-decision procedures to automatically analyze Simulink-Stateflow models. The developed software tools developed in this project translate SLSF models into probabilistic hybrid automata, analyze the formal automata model by abstracting, model checking, and refining, and then translate valid counterexamples back into Simulink to provide the user diagnostic information. Furthermore, the project builds a repository of benchmark SLSF models and their corresponding hybrid automaton models, based on examples from existing hybrid systems literature and drawing on industrial applications. The repository will be publicly disseminated and will be used to evaluate our tool. \r\n \r\nA new course will be developed on the verification of hybrid systems that introduces undergraduate and graduate students in engineering at Illinois to the use of formal methods in embedded system design. Successful completion of the research tasks outlined here is likely to more broadly influence the design and verification of probabilistic hybrid systems that arise in application domains such as autonomous vehicles and  mixed analog-digital circuits.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Sayan",
   "pi_last_name": "Mitra",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sayan Mitra",
   "pi_email_addr": "mitras@illinois.edu",
   "nsf_id": "000526790",
   "pi_start_date": "2010-08-06",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Mahesh",
   "pi_last_name": "Viswanathan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Mahesh Viswanathan",
   "pi_email_addr": "vmahesh@uiuc.edu",
   "nsf_id": "000210258",
   "pi_start_date": "2010-08-06",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "506 S WRIGHT ST",
  "perf_city_name": "URBANA",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618013620",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 163149.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 336851.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of this project was to develop foundations, algorithms, and supporting software tools for analysis or <em>verification</em> of computing systems that control physical processes. From autonomous cars, power systems, medical devices, to air-traffic control systems, many modern systems have software-based control systems at their core. Algorithmic analysis or verification of such systems means to either (a) mathematically prove (certify) that all possible behaviors under different conditions of the system meet the requirements or (b) find bugs in the system that violate the requirement. As systems become more complex, with higher levels of autonomy and intelligence, verification is obviously a critically important part of system design.</p>\n<p>&nbsp;</p>\n<p>The verification problem for cyber-physical systems has been recognized to be notoriously difficult. Physical laws are described by nonlinear, time-varying differential equations. These may not even have analytical solutions. In addition, verification has to contend with the uncertainties in the system---message delays, disturbances, failures, etc. The traditional approach is to use some simulations and tests of the system. While this can help in bugs finding; not finding bugs can never guarantee or certify absence of bugs.</p>\n<p>&nbsp;</p>\n<p>In this project, we approached this problem using what we call <em>simulation-based verification </em>or <em>static-dynamic analysis </em>algorithms. The key idea has two steps: First, using an existing simulation engine we compute an individual behaviors of the system. Second, using these simulations and a new type of <em>static analysis </em>of the model, we compute an over-approximation of all the possible behaviors of the system. The key technical advancement that enabled us to do this static analysis is to characterize how much the behavior of the system chances with changes in the unknown parameters. We call this type of continuity notion a <em>discrepancy function </em>of the system and it essentially bounds, how much two behaviors of the system with different parameters diverge as a function of time. The concept of discrepancy function has attracted independent interest; there has been several major follow-up publications and a patent has been filed.</p>\n<p>&nbsp;</p>\n<p>We have shown that given a discrepancy function of a system, it is possible to solve the bounded time verification problem for cyber-physical systems. Our proposed algorithms always give the right answer, that is they are sound. They always terminate as long as the system meets the requirements robustly---meaning small perturbations to the system should not change the outcome of the analysis. &nbsp;</p>\n<p>&nbsp;</p>\n<p>We have implemented these algorithms in a prototype software tool called Compute Execute Check Engine (C2E2). This implementation targets a specific class of CPS models created suing the popular Simulink/Stateflow modeling environment. The tool has been made publicly available and several research groups have started using it. We have applied it to successfully solve several challenging verification problems.</p>\n<p>&nbsp;</p>\n<p>For example, our colleagues at NASA have developed parallel landing protocol for increasing throughput in future runways. The protocol reduces the spacing between aircraft approaching the landing strop and uses several heuristics to project the motion of approaching aircraft to raise an alarm (called ALAS) so that if there is a violation of separation then the pilot is supposed to get a warning at least 4 seconds in advance. Existing verification approaches failed to verify this protocol because of the the complexities of the and the uncertainty in the dynamics of the aircraft. With C2E2 we were able to verify the protocol under a variety of conditions; we identified conditions where false alarms are possible and we also confirmed that existence of r...",
  "por_txt_cntn": "\nThe goal of this project was to develop foundations, algorithms, and supporting software tools for analysis or verification of computing systems that control physical processes. From autonomous cars, power systems, medical devices, to air-traffic control systems, many modern systems have software-based control systems at their core. Algorithmic analysis or verification of such systems means to either (a) mathematically prove (certify) that all possible behaviors under different conditions of the system meet the requirements or (b) find bugs in the system that violate the requirement. As systems become more complex, with higher levels of autonomy and intelligence, verification is obviously a critically important part of system design.\n\n \n\nThe verification problem for cyber-physical systems has been recognized to be notoriously difficult. Physical laws are described by nonlinear, time-varying differential equations. These may not even have analytical solutions. In addition, verification has to contend with the uncertainties in the system---message delays, disturbances, failures, etc. The traditional approach is to use some simulations and tests of the system. While this can help in bugs finding; not finding bugs can never guarantee or certify absence of bugs.\n\n \n\nIn this project, we approached this problem using what we call simulation-based verification or static-dynamic analysis algorithms. The key idea has two steps: First, using an existing simulation engine we compute an individual behaviors of the system. Second, using these simulations and a new type of static analysis of the model, we compute an over-approximation of all the possible behaviors of the system. The key technical advancement that enabled us to do this static analysis is to characterize how much the behavior of the system chances with changes in the unknown parameters. We call this type of continuity notion a discrepancy function of the system and it essentially bounds, how much two behaviors of the system with different parameters diverge as a function of time. The concept of discrepancy function has attracted independent interest; there has been several major follow-up publications and a patent has been filed.\n\n \n\nWe have shown that given a discrepancy function of a system, it is possible to solve the bounded time verification problem for cyber-physical systems. Our proposed algorithms always give the right answer, that is they are sound. They always terminate as long as the system meets the requirements robustly---meaning small perturbations to the system should not change the outcome of the analysis.  \n\n \n\nWe have implemented these algorithms in a prototype software tool called Compute Execute Check Engine (C2E2). This implementation targets a specific class of CPS models created suing the popular Simulink/Stateflow modeling environment. The tool has been made publicly available and several research groups have started using it. We have applied it to successfully solve several challenging verification problems.\n\n \n\nFor example, our colleagues at NASA have developed parallel landing protocol for increasing throughput in future runways. The protocol reduces the spacing between aircraft approaching the landing strop and uses several heuristics to project the motion of approaching aircraft to raise an alarm (called ALAS) so that if there is a violation of separation then the pilot is supposed to get a warning at least 4 seconds in advance. Existing verification approaches failed to verify this protocol because of the the complexities of the and the uncertainty in the dynamics of the aircraft. With C2E2 we were able to verify the protocol under a variety of conditions; we identified conditions where false alarms are possible and we also confirmed that existence of runway configurations where the 4 second advance notice is not possible. These verification results appeared in the proceedings of the 2014 international conference on Formal Methods. While a lot of..."
 }
}