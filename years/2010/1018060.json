{
 "awd_id": "1018060",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF:  Small:  Locally Decodable Codes and Space Bounded Computation",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Dmitri Maslov",
 "awd_eff_date": "2010-08-01",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 346480.0,
 "awd_amount": 346480.0,
 "awd_min_amd_letter_date": "2010-07-21",
 "awd_max_amd_letter_date": "2010-07-21",
 "awd_abstract_narration": "This project focuses on questions related to bounding the space requirements of computation in various settings, and the relationship between computation time and space.\r\n\r\nCurrent computation tasks often involve very large data sets, for example data originating from the internet, biological or other scientific databases.  The size of input data in certain computational tasks requires special considerations and solutions that work with only small portions of the input at a time: manipulating all of the input at once would be prohibitive even with the latest computer technology.  Locally decodable codes and streaming algorithms are motivated by such applications.\r\n\r\nLocally decodable codes are error correcting codes with the extra property that in order to retrieve the correct value of one position of the input with high probability, it is sufficient to read just a small number of positions of the possibly corrupted codeword.  So far the known constructions of such codes with constant number of queries have very large length with respect to the input size, and there is a large gap between the known upper and lower bounds on the length of codewords, even in the case of 3-query codes.  The project further examines the relationship between the length necessary for the codewords, the number of queries allowed for decoding, and the error correcting properties of locally decodable codes.\r\n\r\nIn addition, the project includes proving bounds on storage space in the cell probe model while limiting the number of positions accessed to answer questions about the data, and  bounding the space requirements of streaming algorithms.  Finally, the project addresses the relationship between the size and depth of Boolean circuits necessary to compute a given function.  This is directly related to the relationship between the time and space of computation.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Anna",
   "pi_last_name": "Gal",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Anna Gal",
   "pi_email_addr": "panni@cs.utexas.edu",
   "nsf_id": "000316297",
   "pi_start_date": "2010-07-21",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "110 INNER CAMPUS DR",
  "perf_city_name": "AUSTIN",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787121139",
  "perf_ctry_code": "US",
  "perf_cong_dist": "25",
  "perf_st_cong_dist": "TX25",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "792700",
   "pgm_ele_name": "COMPLEXITY & CRYPTOGRAPHY"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 346480.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The main focus of the project was the study of space bounded computation in various contexts, motivated by current computational tasks involving large amounts of data. In addition to classical questions of computational complexity, aspects of space bounded computation were examined in the context of&nbsp; coding theory, in particular locally decodable codes.</p>\n<p>Locally decodable codes are error correcting codes with the extra property that it is sufficient to read just a small number of positions of a possibly corrupted codeword in order to recover any one position of the input. This property is useful when encoding very large data sets, for example patient records of a hospital. Traditional error correcting methods that provide good error tolerance against arbitrary errors would require processing the entire database (e.g. data of the entire hospital) even for recovering small amounts of information (e.g. individual patient records). Locally decodable codes allow reliable recovery of any individual record, by accessing not much larger amount of data then the desired information. The challenge is to achieve this even when any part of the database can be corrupted by adversarial errors.</p>\n<p>To achieve local decodability, it is necessary to use randomness in the&nbsp; decoding procedures. We refer to the probability of returning the correct answer as the correctness of the decoding algorithm. In joint work with Andrew Mills, we showed that&nbsp; achieving slightly larger correctness than the known subexponential length constructions requires exponential codeword length for 3-query codes. Previously, there were no larger than quadratic lower bounds known for&nbsp; locally decodable codes with more than 2 queries, even in the case of&nbsp; 3-query linear codes. Our lower bounds hold for linear codes over arbitrary finite fields and for binary nonlinear codes. We also obtained similar results for arbitrary number of queries, under certain assumptions on the decoding algorithm, that have been commonly used in previous constructions. Our results explain the limitations on correctness of these algorithms.</p>\n<p>Batch codes are closely related to the concept of local decodability, as well as to efficient use of storage space. Batch codes were introduced by Ishai, Kushilevitz, Ostrovsky and Sahai in 2004. A batch code specifies a method to encode a string x&nbsp; into an m-tuple of strings stored on m distinct servers, such that any subset of k symbols from x can be retrieved by reading at most t symbols from each server. The goal is to keep the \"load\" t small, while also minimizing the total storage space. The problem is motivated by applications to load balancing&nbsp; in distributed storage, private information retrieval and cryptographic protocols.<br />Combinatorial batch codes are purely replication based batch codes, where each server stores a subset of symbols of the string x. In joint work with Natalia Silberstein, we&nbsp; gave optimal constructions of combinatorial batch codes for a new range of parameters. Our constructions are based on block designs.<br /><br /><br />The depth of Boolean circuits is closely related to the space complexity of the corresponding functions. As part of this project, we studied questions of space bounded computation related to the size versus depth problem, in particular we considered tradeoffs between simultaneous time and&nbsp; space bounds in the context of Boolean circuit complexity, <br />In joint work with Jing-Tang Jang, we obtained significant improvements over the general bounds for the size versus&nbsp; depth problem for special classes of Boolean circuits.&nbsp; We showed that every layered Boolean circuit of size s can be simulated by a layered Boolean circuit of&nbsp; depth $O(\\sqrt{s \\log s})$.&nbsp; For planar circuits and synchronous circuits of size $s$, we obtained simulations of depth $O(\\sqrt{s})$.&nbsp; Im...",
  "por_txt_cntn": "\nThe main focus of the project was the study of space bounded computation in various contexts, motivated by current computational tasks involving large amounts of data. In addition to classical questions of computational complexity, aspects of space bounded computation were examined in the context of  coding theory, in particular locally decodable codes.\n\nLocally decodable codes are error correcting codes with the extra property that it is sufficient to read just a small number of positions of a possibly corrupted codeword in order to recover any one position of the input. This property is useful when encoding very large data sets, for example patient records of a hospital. Traditional error correcting methods that provide good error tolerance against arbitrary errors would require processing the entire database (e.g. data of the entire hospital) even for recovering small amounts of information (e.g. individual patient records). Locally decodable codes allow reliable recovery of any individual record, by accessing not much larger amount of data then the desired information. The challenge is to achieve this even when any part of the database can be corrupted by adversarial errors.\n\nTo achieve local decodability, it is necessary to use randomness in the  decoding procedures. We refer to the probability of returning the correct answer as the correctness of the decoding algorithm. In joint work with Andrew Mills, we showed that  achieving slightly larger correctness than the known subexponential length constructions requires exponential codeword length for 3-query codes. Previously, there were no larger than quadratic lower bounds known for  locally decodable codes with more than 2 queries, even in the case of  3-query linear codes. Our lower bounds hold for linear codes over arbitrary finite fields and for binary nonlinear codes. We also obtained similar results for arbitrary number of queries, under certain assumptions on the decoding algorithm, that have been commonly used in previous constructions. Our results explain the limitations on correctness of these algorithms.\n\nBatch codes are closely related to the concept of local decodability, as well as to efficient use of storage space. Batch codes were introduced by Ishai, Kushilevitz, Ostrovsky and Sahai in 2004. A batch code specifies a method to encode a string x  into an m-tuple of strings stored on m distinct servers, such that any subset of k symbols from x can be retrieved by reading at most t symbols from each server. The goal is to keep the \"load\" t small, while also minimizing the total storage space. The problem is motivated by applications to load balancing  in distributed storage, private information retrieval and cryptographic protocols.\nCombinatorial batch codes are purely replication based batch codes, where each server stores a subset of symbols of the string x. In joint work with Natalia Silberstein, we  gave optimal constructions of combinatorial batch codes for a new range of parameters. Our constructions are based on block designs.\n\n\nThe depth of Boolean circuits is closely related to the space complexity of the corresponding functions. As part of this project, we studied questions of space bounded computation related to the size versus depth problem, in particular we considered tradeoffs between simultaneous time and  space bounds in the context of Boolean circuit complexity, \nIn joint work with Jing-Tang Jang, we obtained significant improvements over the general bounds for the size versus  depth problem for special classes of Boolean circuits.  We showed that every layered Boolean circuit of size s can be simulated by a layered Boolean circuit of  depth $O(\\sqrt{s \\log s})$.  For planar circuits and synchronous circuits of size $s$, we obtained simulations of depth $O(\\sqrt{s})$.  Improving any of the above results by polylog factors would immediately improve the bounds for general circuits. We also obtained\nresults that imply that the class of languages ..."
 }
}