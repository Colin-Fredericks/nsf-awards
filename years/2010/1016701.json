{
 "awd_id": "1016701",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:  Small:  Always-On Static and Dynamic Feedback",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2010-08-15",
 "awd_exp_date": "2014-07-31",
 "tot_intn_awd_amt": 480586.0,
 "awd_amount": 512586.0,
 "awd_min_amd_letter_date": "2010-08-18",
 "awd_max_amd_letter_date": "2012-04-04",
 "awd_abstract_narration": "Software developers aim to create reliable software at low cost.  Two types of tools that help in this task are static and dynamic analysis tools.\r\nStatic analysis tools reason about the program source code, without ever running the program; a widely-used example is type systems.  Dynamic analysis tools observe the program as it executes; a widely-used example is testing.  Dynamic and static feedback provide complementary benefits, neither one dominates the other, and at any moment only the programmer knows which one would be most useful.  Unfortunately, current programming languages impose too rigid a model of the development process:  they favor either static or dynamic tools, which prevents the programmer from freely using the other variety.  We propose a new approach, in which the developer always has access to immediate execution feedback, and always has access to sound static feedback.  The key broader impact is to permit developers to work the way they find most natural and effective, which will improve reliability and reduce cost.  Developers will create software that is more reliable than that created in an environment that favors dynamic analysis.\r\nDevelopers will work faster than they can in an environment that favors static analysis.\r\n\r\nIt is well-known that dynamically-typed scripting languages and statically-typed programming languages have complementary strengths.  For example, scripting can permit faster and more flexible program development and modification, whereas programming languages can yield more reliable and maintainable applications.  Our goal is to give programmers the benefits of both scripting languages and programming languages, so that a programmer can shift back and forth between the two paradigms depending on the task at hand.  In our approach, a programmer can view and execute a program through the lens of sound static typing, or can view and execute a program through the lens of dynamic typing with no statically-imposed restrictions. Furthermore, the programmer can switch between these two views as often as desired, or can use them both simultaneously, depending on the programmer's current information needs.  In our approach, a programmer may temporarily disable the type system and test the code, even if the code does not type-check.  The code is executed as if no types had been written.  Type errors (inconsistencies between the execution and the declared types) are logged but do not terminate execution.  The logged errors can be examined if the test fails or deferred if the test succeeds.  This mode is appropriate for tasks such as initial prototyping, evolving an interface, representation changes, library replacement, and exploratory refactoring.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Michael",
   "pi_last_name": "Ernst",
   "pi_mid_init": "D",
   "pi_sufx_name": "",
   "pi_full_name": "Michael D Ernst",
   "pi_email_addr": "mernst@cs.washington.edu",
   "nsf_id": "000310100",
   "pi_start_date": "2010-08-18",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Washington",
  "inst_street_address": "4333 BROOKLYN AVE NE",
  "inst_street_address_2": "",
  "inst_city_name": "SEATTLE",
  "inst_state_code": "WA",
  "inst_state_name": "Washington",
  "inst_phone_num": "2065434043",
  "inst_zip_code": "981951016",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "WA07",
  "org_lgl_bus_name": "UNIVERSITY OF WASHINGTON",
  "org_prnt_uei_num": "",
  "org_uei_num": "HD1WMN6945W6"
 },
 "perf_inst": {
  "perf_inst_name": "University of Washington",
  "perf_str_addr": "4333 BROOKLYN AVE NE",
  "perf_city_name": "SEATTLE",
  "perf_st_code": "WA",
  "perf_st_name": "Washington",
  "perf_zip_code": "981951016",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "WA07",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 480586.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project has developed new tools and techniques to help software developers find, fix, and prevent errors. &nbsp;Our focus was on combining two different approaches (static and dynamic analysis) that had previously been considered incompatible.<br />The software developers who write computer programs are fallible: &nbsp;they sometimes make mistakes, called bugs. &nbsp;These bugs can cause loss of time, money, or even life. &nbsp;Software developers use tools to help them find and fix bugs in their programs. &nbsp;These tools fall into two general categories: &nbsp;static analysis and dynamic analysis. &nbsp;A typical static analysis is a compiler. &nbsp;A typical dynamic analysis is testing.<br />A static analysis reasons about all the ways the program can behave, by examining the program source code. &nbsp;However, a static analysis does not run the program. &nbsp;By contrast, a dynamic analysis runs the program and observes what the program does.<br />Each style of analysis has its own advantages and disadvantages. &nbsp;A static analysis virtually explores every possible execution of a program, so no bug escapes undetected. &nbsp;However, a static analysis issues many false alarms about potential problems that can never occur in practice. &nbsp;By contrast, a dynamic analysis observes actual executions of a program: &nbsp;it has all details about those executions and thus is more precise and issues no false alarms. &nbsp;Furthermore, a dynamic analysis can be run even if the program is not already perfect. &nbsp;However, a dynamic analysis gives no guarantee about executions that it does not observe.<br />A software developer prefers to use static analysis for some tasks and dynamic analysis for other tasks. &nbsp;Unfortunately, the software developer usually doesn't have a choice. &nbsp;Most tools perform either static or dynamic analysis, but not both. &nbsp;The choice is dictated by the tool designer, or sometimes by the programming language designer: &nbsp;each programming language's type system is either static or dynamic. &nbsp;As a result, the software developer is forced to use a tool that is ill-suited to the current task.<br />Our ambitious goal was to create hybrid tools that offer the best of both worlds: &nbsp;they offer guarantees like static tools, but they can be easily run and are precise like dynamic tools. &nbsp;We started with type systems, where we produced tools that either guarantee that the program is correct, or else transform it so that it can run anyway, despite the compiler's typical requirement that the program type-checks. &nbsp;We have extended our work to other domains including testing, mutation, and mining.<br />This project is of significant intellectual merit. &nbsp;It has devised a new approach that combines the best of static and dynamic typing, rather than the worst (such as getting no static guarantee of correctness). &nbsp;As opposed to previous techniques, it starts from a sound static type system rather than an unsound dynamic one. &nbsp;We have devised new implementation strategies and optimizations, formalized our results, and done extensive experiments that yielded insight into the practices and needs of programmers. &nbsp;Furthermore, our ideas unexpectedly led to other areas beyond type-checking and yielded similar scientific breakthroughs there.<br />The immediate impact of our project is to improve software development. &nbsp;Developers who use our tools can spend less time and money, and will be less frustrated, while producing higher-quality software that suffers fewer bugs. &nbsp;The broader impacts touch on all of society that uses software -- that is, on all of society! &nbsp;Users can spend less on software and suffer fewer crashes, unavailability, data loss, and error; they can do their jobs more effectively and use scarce time and money more productively. &nbsp;In addition, we have trained numerous un...",
  "por_txt_cntn": "\nThis project has developed new tools and techniques to help software developers find, fix, and prevent errors.  Our focus was on combining two different approaches (static and dynamic analysis) that had previously been considered incompatible.\nThe software developers who write computer programs are fallible:  they sometimes make mistakes, called bugs.  These bugs can cause loss of time, money, or even life.  Software developers use tools to help them find and fix bugs in their programs.  These tools fall into two general categories:  static analysis and dynamic analysis.  A typical static analysis is a compiler.  A typical dynamic analysis is testing.\nA static analysis reasons about all the ways the program can behave, by examining the program source code.  However, a static analysis does not run the program.  By contrast, a dynamic analysis runs the program and observes what the program does.\nEach style of analysis has its own advantages and disadvantages.  A static analysis virtually explores every possible execution of a program, so no bug escapes undetected.  However, a static analysis issues many false alarms about potential problems that can never occur in practice.  By contrast, a dynamic analysis observes actual executions of a program:  it has all details about those executions and thus is more precise and issues no false alarms.  Furthermore, a dynamic analysis can be run even if the program is not already perfect.  However, a dynamic analysis gives no guarantee about executions that it does not observe.\nA software developer prefers to use static analysis for some tasks and dynamic analysis for other tasks.  Unfortunately, the software developer usually doesn't have a choice.  Most tools perform either static or dynamic analysis, but not both.  The choice is dictated by the tool designer, or sometimes by the programming language designer:  each programming language's type system is either static or dynamic.  As a result, the software developer is forced to use a tool that is ill-suited to the current task.\nOur ambitious goal was to create hybrid tools that offer the best of both worlds:  they offer guarantees like static tools, but they can be easily run and are precise like dynamic tools.  We started with type systems, where we produced tools that either guarantee that the program is correct, or else transform it so that it can run anyway, despite the compiler's typical requirement that the program type-checks.  We have extended our work to other domains including testing, mutation, and mining.\nThis project is of significant intellectual merit.  It has devised a new approach that combines the best of static and dynamic typing, rather than the worst (such as getting no static guarantee of correctness).  As opposed to previous techniques, it starts from a sound static type system rather than an unsound dynamic one.  We have devised new implementation strategies and optimizations, formalized our results, and done extensive experiments that yielded insight into the practices and needs of programmers.  Furthermore, our ideas unexpectedly led to other areas beyond type-checking and yielded similar scientific breakthroughs there.\nThe immediate impact of our project is to improve software development.  Developers who use our tools can spend less time and money, and will be less frustrated, while producing higher-quality software that suffers fewer bugs.  The broader impacts touch on all of society that uses software -- that is, on all of society!  Users can spend less on software and suffer fewer crashes, unavailability, data loss, and error; they can do their jobs more effectively and use scarce time and money more productively.  In addition, we have trained numerous undergraduate and graduate students and published over a dozen technical papers.\n\n \n\n \n\n\t\t\t\t\tLast Modified: 09/01/2015\n\n\t\t\t\t\tSubmitted by: Michael D Ernst"
 }
}