{
 "awd_id": "1018961",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "III:  Small: Database-driven Ajax applications",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Nan Zhang",
 "awd_eff_date": "2010-09-01",
 "awd_exp_date": "2014-08-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 532000.0,
 "awd_min_amd_letter_date": "2010-08-07",
 "awd_max_amd_letter_date": "2012-03-14",
 "awd_abstract_narration": "AJAX programming enables superior performance and interface quality that is comparable to desktop applications, despite the fact that the users? browsers interact with a remote server on the cloud. The challenge is that AJAX programs are hard to write since they are essentially distributed programs combining three different languages: browser-side Javascript, a server side programming language (e.g., Java, PHP, etc) and database access with SQL. \r\n\r\nThe proposal develops a framework for the rapid creation of fully-fledged AJAX-based web application pages from declarative, data-driven, SQL-based specifications. The proposal delivers an architecture and SQL-based page specification language that is sufficiently abstract and declarative to enable rapid development, while it is also (a) performant and (b) enables the same class of data-driven web applications with what can be manually coded. Novel incremental view maintenance, distributed query processing and concurrency control techniques enable performance, while the component-based structuring of pages blends the data aspects of the language with front-end mechanisms for creating rich interfaces.\r\n\r\nDeclarative specifications lead to rapid programming, fewer bugs and easy application maintenance and evolution, while the framework solves performance optimization and correctness problems and provides functionalities that otherwise the developer would need to take care of with tedious custom AJAX code. The results are carried over besides Ajax to Adobe's Flash, the recent Microsoft's Silverlight and the emerging mobile application platforms. Furthermore, they contribute to UCSD?s web application development curriculum by providing a principled method of architecting and implementing interactive data-driven applications. The information about the project can be found at http://db.ucsd.edu/NSF10FWD/",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Yannis",
   "pi_last_name": "Papakonstantinou",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Yannis Papakonstantinou",
   "pi_email_addr": "yannis@cs.ucsd.edu",
   "nsf_id": "000229823",
   "pi_start_date": "2010-08-07",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "9500 GILMAN DR",
  "perf_city_name": "LA JOLLA",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930021",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736400",
   "pgm_ele_name": "Info Integration & Informatics"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 500000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span>Implementing a data-driven web application or analytics visualization (even a conceptually simple one) requires an inordinate amount of time. Projects that are relatively easy to specify are fairly time consuming. There is an obvious benefit to IT people in reducing this time. </span></p>\n<p><span>This project argued that one common reason is the many integration frictions across the multiple sources of data in the application. For example, some data may reside in application server memory, some other data reside on client (browser) memory, some data reside in a conventional SQL database, while other data nowadays reside on scalable NoSQL systems. All these data must be integrated and must interact in order to create a functional application.</span></p>\n<p>The high level goal of the project was to</p>\n<p>(a) research novel solutions to the identified frictions and</p>\n<p>(b) deliver an application development platform that encompasses the individual solutions into a usable, coordinated programming tool for building data-driven applications. Emphasis was given on analytics applications.</p>\n<p>The first identified frictions were the data heterogeneity and distribution problems: Applications access distributed and heterogeneous data across multiple data sources (user input of the browser page, session data in the application server, SQL database, NoSQL database etc). A novel distributed query processing problem is caused by the emergence of NoSQL stores. It has became commonplace that a company keeps its conventional enterprise data in a relational, ACID database, while Big and Fast data from web activity, sensors and devices are kept in NoSQL stores. Applications that require access to both (even for rudimentary purposes) do not get the benefit of having a single data platform.</p>\n<p>In response, the project built middleware that can integrate memory data with SQL and noSQL stores. The middleware results into an integrated database (see image) that may either be virtual or materialized. If virtual,&nbsp;the technical problem is to execute distributed queries over memory, SQL and noSQL stores.&nbsp;If materialized the technical problem is incremental view maintenance: How does the system keep the integrated database (also called integrated view) up-to-date as the underlying data change.</p>\n<p>The second identified friction pertains to coordinating the data of the multiple layers. The reporting components connect to reported data part that are automatically and incrementally updated views of the application state.&nbsp;</p>\n<p>In response to the SQL/NoSQL heterogeneity/mismatch problems, the project introduced theSQL++ data model, which is a minimally expanded JSON. It provides an excellent semi-structured model that captures SQL databases, noSQL databases (naturally since most of them indeed model their data as JSON extensions), browser Javascript-originating data, and application-level objects.&nbsp;The project extended SQL to SQL++ so that it can be viewed either as an expanded SQL or as a JSON query language.</p>\n<p>A language novelty of SQL++ is the inclusion of configuration options that formally itemize the semantics variations that language designers may choose from ([NOS14], [NOS15]). The options often pertain to the treatment of semi-structuredness (missing attributes, heterogeneous types, etc), where more than one sensible approaches are possible. The net effect of configuration options is that SQL++ became unifying: By appropriate choices of configuration options, the SQL++ semantics can morph into the semantics of existing semi-structured (NoSQL) database query languages. Extensive experimental validation showed how SQL and four semi-structured database query languages (MongoDB, Cassandra CQL, Couchbase N1QL and AsterixDB AQL) are formally described by appropriate settings of the configuration options.&nbsp;</p>\n<p>This project developed a novel i...",
  "por_txt_cntn": "\nImplementing a data-driven web application or analytics visualization (even a conceptually simple one) requires an inordinate amount of time. Projects that are relatively easy to specify are fairly time consuming. There is an obvious benefit to IT people in reducing this time. \n\nThis project argued that one common reason is the many integration frictions across the multiple sources of data in the application. For example, some data may reside in application server memory, some other data reside on client (browser) memory, some data reside in a conventional SQL database, while other data nowadays reside on scalable NoSQL systems. All these data must be integrated and must interact in order to create a functional application.\n\nThe high level goal of the project was to\n\n(a) research novel solutions to the identified frictions and\n\n(b) deliver an application development platform that encompasses the individual solutions into a usable, coordinated programming tool for building data-driven applications. Emphasis was given on analytics applications.\n\nThe first identified frictions were the data heterogeneity and distribution problems: Applications access distributed and heterogeneous data across multiple data sources (user input of the browser page, session data in the application server, SQL database, NoSQL database etc). A novel distributed query processing problem is caused by the emergence of NoSQL stores. It has became commonplace that a company keeps its conventional enterprise data in a relational, ACID database, while Big and Fast data from web activity, sensors and devices are kept in NoSQL stores. Applications that require access to both (even for rudimentary purposes) do not get the benefit of having a single data platform.\n\nIn response, the project built middleware that can integrate memory data with SQL and noSQL stores. The middleware results into an integrated database (see image) that may either be virtual or materialized. If virtual, the technical problem is to execute distributed queries over memory, SQL and noSQL stores. If materialized the technical problem is incremental view maintenance: How does the system keep the integrated database (also called integrated view) up-to-date as the underlying data change.\n\nThe second identified friction pertains to coordinating the data of the multiple layers. The reporting components connect to reported data part that are automatically and incrementally updated views of the application state. \n\nIn response to the SQL/NoSQL heterogeneity/mismatch problems, the project introduced theSQL++ data model, which is a minimally expanded JSON. It provides an excellent semi-structured model that captures SQL databases, noSQL databases (naturally since most of them indeed model their data as JSON extensions), browser Javascript-originating data, and application-level objects. The project extended SQL to SQL++ so that it can be viewed either as an expanded SQL or as a JSON query language.\n\nA language novelty of SQL++ is the inclusion of configuration options that formally itemize the semantics variations that language designers may choose from ([NOS14], [NOS15]). The options often pertain to the treatment of semi-structuredness (missing attributes, heterogeneous types, etc), where more than one sensible approaches are possible. The net effect of configuration options is that SQL++ became unifying: By appropriate choices of configuration options, the SQL++ semantics can morph into the semantics of existing semi-structured (NoSQL) database query languages. Extensive experimental validation showed how SQL and four semi-structured database query languages (MongoDB, Cassandra CQL, Couchbase N1QL and AsterixDB AQL) are formally described by appropriate settings of the configuration options. \n\nThis project developed a novel incremental view maintenance solution by observing that the most typical state modifications involve an application inserting a new record (possibly a semistructured one in n..."
 }
}