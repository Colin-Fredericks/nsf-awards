{
 "awd_id": "0208289",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "Time Complexity Limits for Shared-Memory Synchronization",
 "cfda_num": "47.070",
 "org_code": "05010100",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Kathleen M. O'Hara",
 "awd_eff_date": "2002-09-01",
 "awd_exp_date": "2005-08-31",
 "tot_intn_awd_amt": 107497.0,
 "awd_amount": 107497.0,
 "awd_min_amd_letter_date": "2002-08-16",
 "awd_max_amd_letter_date": "2002-08-16",
 "awd_abstract_narration": "Through the years, much work has been done on synchronization algorithms for\r\nshared-memory multiprocessors.  In contrast, very little work has been done on\r\ntime-complexity lower bounds that express fundamental limits to which such\r\nalgorithms are subject.  Given the vastness of the literature on\r\nsynchronization, this may seem somewhat surprising.  However, there is a\r\nsimple explanation: while devising a useful time complexity measure for\r\nsequential algorithms is straightforward, it is not altogether obvious how to\r\ndo this in a meaningful way for synchronization algorithms.  Indeed, in most\r\nsynchronization algorithms, processes may wait unboundedly; thus, if one merely\r\napplies the standard sequential measure of counting all operations to such an\r\nalgorithm, then its time complexity is unbounded.  This is not a very useful\r\nstatistic.\r\n\r\nRecently, some progress has been made towards defining useful time complexity\r\nmeasures.  One such measure is the the remote memory references (RMR) measure.\r\nUnder the RMR measure, a distinction is made between local and remote accesses\r\nof shared memory.  An access is local if it does not require a traversal of\r\nthe global interconnect between processors and shared memory, and is\r\nremote otherwise.  The RMR measure was motived by research on \"local-spin\"\r\nsynchronization algorithms.  In such algorithms, processes are structured so\r\nthat all busy waiting is on variables cached locally or stored in a local\r\nmemory module.\r\n\r\nWhen studying synchronization problems, the following key question arises:\r\nUsing some class C of synchronization primitives, what is the most\r\nefficient possible algorithm for solving a given synchronization problem?\r\nIt is this basic question to which this research project is directed, where\r\n\"efficiency\" is defined as time complexity under the RMR measure.  The\r\nresearch agenda includes work on both algorithms and lower bounds.  Based\r\non such work, rankings of synchronization primitives are being developed\r\nthat order synchronization primitives according to the time complexity\r\n(worst-case, average-case, amortized) with which various synchronization\r\nproblems can be solved.  Such rankings should be of value to computer\r\narchitects.  Indeed, preliminary research has shown that a variety of\r\nfetch-and-phi primitives are more powerful than comparison primitives for\r\nimplementing blocking synchronization mechanisms.  This stands in contrast\r\nto the fact that compare-and-swap and related comparison primitives are\r\ncommonly regarded to be among the most powerful and useful of primitives,\r\nand are widely supported in modern machines.\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "James",
   "pi_last_name": "Anderson",
   "pi_mid_init": "H",
   "pi_sufx_name": "",
   "pi_full_name": "James H Anderson",
   "pi_email_addr": "anderson@cs.unc.edu",
   "nsf_id": "000481767",
   "pi_start_date": "2002-08-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of North Carolina at Chapel Hill",
  "inst_street_address": "104 AIRPORT DR STE 2200",
  "inst_street_address_2": "",
  "inst_city_name": "CHAPEL HILL",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9199663411",
  "inst_zip_code": "275995023",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL",
  "org_prnt_uei_num": "D3LHU66KBLD5",
  "org_uei_num": "D3LHU66KBLD5"
 },
 "perf_inst": {
  "perf_inst_name": "University of North Carolina at Chapel Hill",
  "perf_str_addr": "104 AIRPORT DR STE 2200",
  "perf_city_name": "CHAPEL HILL",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "275995023",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "286000",
   "pgm_ele_name": "THEORY OF COMPUTING"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9216",
   "pgm_ref_txt": "ADVANCED SOFTWARE TECH & ALGOR"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0102",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0102",
   "fund_name": "",
   "fund_symb_id": ""
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2002,
   "fund_oblg_amt": 107497.0
  }
 ],
 "por": null
}