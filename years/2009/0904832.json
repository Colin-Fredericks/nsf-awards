{
 "awd_id": "0904832",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF: Medium: Collaborative Research: Approximate Computational Geometry via Controlled Linear Perturbation",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Dmitri Maslov",
 "awd_eff_date": "2009-09-01",
 "awd_exp_date": "2013-08-31",
 "tot_intn_awd_amt": 300000.0,
 "awd_amount": 308000.0,
 "awd_min_amd_letter_date": "2009-09-03",
 "awd_max_amd_letter_date": "2010-05-14",
 "awd_abstract_narration": "The investigators will develop an approximate computational geometry that is algorithm independent, accurate, and fast.  Geometric predicate evaluation and element construction will be performed approximately using floating point arithmetic.  Degeneracy will be handled transparently.  The evaluation and construction techniques will be encapsulated in a software library that will be free for nonprofit use.\r\n\r\nThe research challenge is robustness: the output of an approximate algorithm must be correct for a small perturbation of the given input.  This definition extends the numerical analysis definition of a stable algorithm to cover combinatorial error.  Robustness is a fundamental computer science problem that is a major challenge in computational geometry.  The predominant strategy in computational geometry, exact computation using algebraic geometry, has high computational complexity and contradicts the standard scientific and engineering strategy of approximate computation with error bounds.  The investigators will adapt approximate computation to the special needs of computational geometry, which is primarily combinatorial.  This task involves core research at the interface between computational geometry and numerical computing.\r\n\r\nRobust approximate computation will transform how computational geometry is taught, how algorithms are developed and implemented, and how the field interacts with the wider scientific and engineering community.  Introductory courses will present a rigorous, practical robustness theory, instead of treating robustness in an ad hoc, incomplete way.  Programmers will implement real RAM algorithms as stated, using our library to ensure robustness and to handle degeneracy, instead of addressing these problems anew for every algorithm, which is often a major research challenge.  Computational geometry will be available to other disciplines in the form of high-quality software libraries, akin to modern applied mathematics libraries.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Elisha",
   "pi_last_name": "Sacks",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Elisha Sacks",
   "pi_email_addr": "sacks@cs.purdue.edu",
   "nsf_id": "000220105",
   "pi_start_date": "2009-09-03",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Purdue University",
  "inst_street_address": "2550 NORTHWESTERN AVE # 1100",
  "inst_street_address_2": "",
  "inst_city_name": "WEST LAFAYETTE",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "7654941055",
  "inst_zip_code": "479061332",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IN04",
  "org_lgl_bus_name": "PURDUE UNIVERSITY",
  "org_prnt_uei_num": "YRXVL4JYCEF5",
  "org_uei_num": "YRXVL4JYCEF5"
 },
 "perf_inst": {
  "perf_inst_name": "Purdue University",
  "perf_str_addr": "2550 NORTHWESTERN AVE # 1100",
  "perf_city_name": "WEST LAFAYETTE",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "479061332",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IN04",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "792600",
   "pgm_ele_name": "ALGORITHMS"
  },
  {
   "pgm_ele_code": "792900",
   "pgm_ele_name": "COMPUTATIONAL GEOMETRY"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 300000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Computational geometry is the branch of computer science that develops<br />algorithms for solving geometry problems.&nbsp; The field addresses abstract<br />problems, such as how a set of lines partitions the plane into regions and how a<br />polyhedron can be decomposed into tetrahedrons.&nbsp; Algorithms that solve these<br />problems advance our understanding of the interplay between computing and<br />geometry.&nbsp; Many scientific and engineering problems can be formulated in the<br />language of computational geometry.&nbsp; Examples include planning a safe path for a<br />robot in a cluttered environment, computer-aided design of complex parts using a<br />library of standard shape, and construction of three-dimensional models of<br />tumors from MRI data.<br /><br />We researched the robustness problem: how to convert computational geometry<br />algorithms into reliable, efficient software.&nbsp; Numerical algorithms, including<br />algorithms of computational geometry, are formulated under the simplifying<br />assumptions that real numbers have unit size and real arithmetic takes unit<br />time.&nbsp; The is called the real-RAM model.&nbsp; However, algorithms are implemented<br />using floating point computer arithmetic, which has rounding.&nbsp; The resulting<br />program is accurate and its running time matches the prediction of the real-RAM<br />model.&nbsp; Computational geometry algorithms are atypical because their control<br />logic is expressed using predicates: polynomials whose signs are interpreted as<br />truth values.&nbsp; Although floating point predicate evaluation is accurate, even a<br />small error can make the sign incorrect and thus can cause a large error in the<br />program output.&nbsp; Predicates can be evaluated exactly using integer arithmetic,<br />but this strategy imposes a high overhead in running time and in computer<br />memory.&nbsp; Moreover, a predicate can be degenerate, meaning zero rather than<br />positive or negative.&nbsp; Degeneracy adds special cases to the control logic that<br />are usually ignored by algorithm creators.&nbsp; The software must handle these cases<br />or face erratic failures.<br /><br />We solved the robustness problem by developing a technique for evaluating<br />predicates exactly and efficiently using floating point interval arithmetic.<br />Interval arithmetic is a version of floating point arithmetic that computes an<br />interval of floating point numbers, represented by its two endpoints, that is<br />guaranteed to contain the exact result.&nbsp; We perturb the input parameters to the<br />computational geomtry algorithm.&nbsp; The perturbation eliminates degeneracy by<br />eliminating the coincidental relations among the inputs.&nbsp; We evaluate predicates<br />in floating point interval arithmetic.&nbsp; The result is ambiguous if the interval<br />contains zero, so either sign is consistent with this interval.&nbsp; We remove the<br />ambiguity by increasing the precision of the interval arithmetic, which shrinks<br />the interval.&nbsp; We adaptively increase the precision until the sign is verified.<br />We use an extended precision software library called MPFR because the computer<br />hardware does not directly support arbitrary precision arithmetic.&nbsp; We have<br />proved that the expected overhead of this technique is constant for predicates<br />in the input parameters.<br /><br />As a result of this work, we have been able to implement algorithms that were<br />devised 25 years aga, but until now could not be turned into programs.&nbsp; Visit<br />http://youtu.be/BsCcy0vYerw for a video illustrating an implementation of path<br />planning.<br /><br /></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/25/2013<br>\n\t\t\t\t\tModified by: Elisha&nbsp;Sacks</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nComputational geometry is the branch of computer science that develops\nalgorithms for solving geometry problems.  The field addresses abstract\nproblems, such as how a set of lines partitions the plane into regions and how a\npolyhedron can be decomposed into tetrahedrons.  Algorithms that solve these\nproblems advance our understanding of the interplay between computing and\ngeometry.  Many scientific and engineering problems can be formulated in the\nlanguage of computational geometry.  Examples include planning a safe path for a\nrobot in a cluttered environment, computer-aided design of complex parts using a\nlibrary of standard shape, and construction of three-dimensional models of\ntumors from MRI data.\n\nWe researched the robustness problem: how to convert computational geometry\nalgorithms into reliable, efficient software.  Numerical algorithms, including\nalgorithms of computational geometry, are formulated under the simplifying\nassumptions that real numbers have unit size and real arithmetic takes unit\ntime.  The is called the real-RAM model.  However, algorithms are implemented\nusing floating point computer arithmetic, which has rounding.  The resulting\nprogram is accurate and its running time matches the prediction of the real-RAM\nmodel.  Computational geometry algorithms are atypical because their control\nlogic is expressed using predicates: polynomials whose signs are interpreted as\ntruth values.  Although floating point predicate evaluation is accurate, even a\nsmall error can make the sign incorrect and thus can cause a large error in the\nprogram output.  Predicates can be evaluated exactly using integer arithmetic,\nbut this strategy imposes a high overhead in running time and in computer\nmemory.  Moreover, a predicate can be degenerate, meaning zero rather than\npositive or negative.  Degeneracy adds special cases to the control logic that\nare usually ignored by algorithm creators.  The software must handle these cases\nor face erratic failures.\n\nWe solved the robustness problem by developing a technique for evaluating\npredicates exactly and efficiently using floating point interval arithmetic.\nInterval arithmetic is a version of floating point arithmetic that computes an\ninterval of floating point numbers, represented by its two endpoints, that is\nguaranteed to contain the exact result.  We perturb the input parameters to the\ncomputational geomtry algorithm.  The perturbation eliminates degeneracy by\neliminating the coincidental relations among the inputs.  We evaluate predicates\nin floating point interval arithmetic.  The result is ambiguous if the interval\ncontains zero, so either sign is consistent with this interval.  We remove the\nambiguity by increasing the precision of the interval arithmetic, which shrinks\nthe interval.  We adaptively increase the precision until the sign is verified.\nWe use an extended precision software library called MPFR because the computer\nhardware does not directly support arbitrary precision arithmetic.  We have\nproved that the expected overhead of this technique is constant for predicates\nin the input parameters.\n\nAs a result of this work, we have been able to implement algorithms that were\ndevised 25 years aga, but until now could not be turned into programs.  Visit\nhttp://youtu.be/BsCcy0vYerw for a video illustrating an implementation of path\nplanning.\n\n\n\n\t\t\t\t\tLast Modified: 10/25/2013\n\n\t\t\t\t\tSubmitted by: Elisha Sacks"
 }
}