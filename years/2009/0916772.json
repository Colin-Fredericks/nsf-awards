{
 "awd_id": "0916772",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "TC: Small: Collaborative Research: Trustworthy Hardware from Certified Behavioral Synthesis",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Jeremy Epstein",
 "awd_eff_date": "2009-09-15",
 "awd_exp_date": "2013-08-31",
 "tot_intn_awd_amt": 249989.0,
 "awd_amount": 249989.0,
 "awd_min_amd_letter_date": "2009-09-18",
 "awd_max_amd_letter_date": "2012-08-25",
 "awd_abstract_narration": "Electronic System Level (ESL) designs, specified behaviorally using\r\nhigh-level languages such as SystemC, raise the level of hardware\r\ndesign abstraction. This approach crucially depends on behavioral\r\nsynthesis, which compiles ESL designs to Register Transfer Level (RTL)\r\ndesigns. However, optimizations performed by synthesis tools make\r\ntheir implementation error-prone, undermining the trustworthiness of\r\nsynthesized hardware.  \r\n\r\nThis research develops a mechanized infrastructure for certifying\r\nhardware designs generated by behavioral synthesis. It entails\r\ndeveloping a certified \"reference flow\" of synthesis transformations. \r\nThe reference flow is disentangled from the workings of a production\r\nsynthesis tool through new formal structure called \"clocked control\r\ndata flow graph\" (CCDFG) formalizing internal design representation. \r\nGiven an ESL design and its synthesized RTL, certification entails the\r\nfollowing automatic steps: (1) extracting initial CCDFG; (2) applying\r\ncertified \"primitive transformations\" from the reference flow,\r\nfollowing the application sequence by the synthesis tool, and (3)\r\nchecking equivalence between the transformed CCDFG and RTL. Theorem\r\nproving is used to certify primitive transformations off-line;\r\nequivalence checking accounts for low-level transformations and\r\nmanual tweaks. The correspondence between the transformed CCDFG and\r\nthe synthesized hardware makes equivalence checking efficient. \r\n\r\nThe project facilitates development of scalable and trustworthy\r\nhardware: adoption of ESL approach expedites design cycle while formal\r\nanalysis guarantees trust in the synthesized hardware. The reference\r\nflow makes explicit key design invariants implicitly assumed by\r\nsynthesis tools, facilitating development of more aggressive synthesis\r\ntools. Finally, the tight integration of two complementary techniques\r\n--- model checking and theorem proving --- in the certification is\r\napplicable to other domains. \r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Warren",
   "pi_last_name": "Hunt, Jr.",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Warren A Hunt, Jr.",
   "pi_email_addr": "hunt@cs.utexas.edu",
   "nsf_id": "000369883",
   "pi_start_date": "2012-08-25",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Sandip",
   "pi_last_name": "Ray",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sandip Ray",
   "pi_email_addr": "sandip@ece.ufl.edu",
   "nsf_id": "000082522",
   "pi_start_date": "2009-09-18",
   "pi_end_date": "2012-08-25"
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Warren",
   "pi_last_name": "Hunt, Jr.",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Warren A Hunt, Jr.",
   "pi_email_addr": "hunt@cs.utexas.edu",
   "nsf_id": "000369883",
   "pi_start_date": "2009-09-18",
   "pi_end_date": "2012-08-25"
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "110 INNER CAMPUS DR",
  "perf_city_name": "AUSTIN",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787121139",
  "perf_ctry_code": "US",
  "perf_cong_dist": "25",
  "perf_st_cong_dist": "TX25",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779500",
   "pgm_ele_name": "TRUSTWORTHY COMPUTING"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 80002.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 169987.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The complexity of computing systems has been increasing steadily, making it infeasible for designers to hand-craft their implementations. &nbsp;It is critical to develop tools that allow designers to specify design functionality at a high abstraction level from which implementation can be automatically synthesized. &nbsp;Behavioral synthesis is one such approach, for hardware systems; behavioral synthesis tools generate hardware implementations (called \"RTL\") from high-level specifications (called \"ESL\"). &nbsp;Albeit promising, ESL is not widely adopted. &nbsp;A key reason is the lack of designer's confidence that the synthesized RTL implements the functionality specified in ESL. &nbsp;Since the synthesis tool implements complex transformations, it is prone to errors that can introduce subtle behavior mismatches between ESL and RTL; if detected late, this can cost the producing company millions of dollars, result in costly recall of fabricated hardware, etc.<br />This collaborative project develops an approach for certifying correctness of hardware designs generated through behavioral synthesis. &nbsp;The key outcome is the development of a tool-suite, along with a process (or \"flow\") for its usage. &nbsp;Given an ESL specification E and a RTL R, if each step of the flow is successfully completed then there is a mathematical guarantee that R indeed implements E. &nbsp;Our flow has certified designs containing tens of thousands of lines of RTL, synthesized by commercial tools. &nbsp;We are not aware of any other technology to achieve certification at this scale.<br />The project develops several innovative solutions, both in technology and methodology, that overcome road-blocks in commercially deploying a certification solution in the commercial context. &nbsp;As an example of methodological road-block, most commercial synthesis tools are closed-source, making it impossible to certify by reviewing or analyzing their implementation; not to mention, the implementation is inordinately complex and likely out-of-reach for most certification tools.<br />Our approach is based on several insights. &nbsp;The first is that while implementations of most behavioral synthesis tools are not open to review or analysis, one can obtain a series of intermediate design representations (\"IRs\") E1,...,En, generated by the synthesis tool as it transforms an ESL E to RTL R. &nbsp;Furthermore, the structural correspondence between Ei and Ei+1 is typically small; thus one can develop a computer program to certify if they are equivalent. &nbsp;The transformations that destroy structural correspondence are few and hence a custom solution for each is viable. &nbsp;Finally, the IR En is close in abstraction to R, so the equivalence between the two can also be certified by an analysis tool. &nbsp;Thus we developed the following three technical approaches:<br />(1) a tool to check equivalence between closely matching consecutive IRs;<br />(2) a tool to check equivalence between an IR and RTL;<br />(3) an approach for checking equivalence between IRs without structural correspondence.<br />(1) and (2) handle a number of optimizations commonly applied by synthesis tools, e.g., addition of modules implementing power-saving functionality. &nbsp;For (3), suppose a transformation Ei-&gt;Ei+1 destroys structural correspondence. &nbsp;(A typical such transformation is loop pipelining.) &nbsp;Since the transformation implementation is closed-source, we develop our own \"reference implementation\" (using information available from the synthesis tool to ensure structural similarity with Ei+1), which can take Ei as input and generate some output Ei'. &nbsp;If Ei' is indeed structurally similar to Ei+1, we can check their equivalence. &nbsp;Finally, we employ an interactive reasoning tool, ACL2, to prove mathematically that our reference implementations are correct. &nbsp;ACL2 requires manual effort and a disc...",
  "por_txt_cntn": "\nThe complexity of computing systems has been increasing steadily, making it infeasible for designers to hand-craft their implementations.  It is critical to develop tools that allow designers to specify design functionality at a high abstraction level from which implementation can be automatically synthesized.  Behavioral synthesis is one such approach, for hardware systems; behavioral synthesis tools generate hardware implementations (called \"RTL\") from high-level specifications (called \"ESL\").  Albeit promising, ESL is not widely adopted.  A key reason is the lack of designer's confidence that the synthesized RTL implements the functionality specified in ESL.  Since the synthesis tool implements complex transformations, it is prone to errors that can introduce subtle behavior mismatches between ESL and RTL; if detected late, this can cost the producing company millions of dollars, result in costly recall of fabricated hardware, etc.\nThis collaborative project develops an approach for certifying correctness of hardware designs generated through behavioral synthesis.  The key outcome is the development of a tool-suite, along with a process (or \"flow\") for its usage.  Given an ESL specification E and a RTL R, if each step of the flow is successfully completed then there is a mathematical guarantee that R indeed implements E.  Our flow has certified designs containing tens of thousands of lines of RTL, synthesized by commercial tools.  We are not aware of any other technology to achieve certification at this scale.\nThe project develops several innovative solutions, both in technology and methodology, that overcome road-blocks in commercially deploying a certification solution in the commercial context.  As an example of methodological road-block, most commercial synthesis tools are closed-source, making it impossible to certify by reviewing or analyzing their implementation; not to mention, the implementation is inordinately complex and likely out-of-reach for most certification tools.\nOur approach is based on several insights.  The first is that while implementations of most behavioral synthesis tools are not open to review or analysis, one can obtain a series of intermediate design representations (\"IRs\") E1,...,En, generated by the synthesis tool as it transforms an ESL E to RTL R.  Furthermore, the structural correspondence between Ei and Ei+1 is typically small; thus one can develop a computer program to certify if they are equivalent.  The transformations that destroy structural correspondence are few and hence a custom solution for each is viable.  Finally, the IR En is close in abstraction to R, so the equivalence between the two can also be certified by an analysis tool.  Thus we developed the following three technical approaches:\n(1) a tool to check equivalence between closely matching consecutive IRs;\n(2) a tool to check equivalence between an IR and RTL;\n(3) an approach for checking equivalence between IRs without structural correspondence.\n(1) and (2) handle a number of optimizations commonly applied by synthesis tools, e.g., addition of modules implementing power-saving functionality.  For (3), suppose a transformation Ei-&gt;Ei+1 destroys structural correspondence.  (A typical such transformation is loop pipelining.)  Since the transformation implementation is closed-source, we develop our own \"reference implementation\" (using information available from the synthesis tool to ensure structural similarity with Ei+1), which can take Ei as input and generate some output Ei'.  If Ei' is indeed structurally similar to Ei+1, we can check their equivalence.  Finally, we employ an interactive reasoning tool, ACL2, to prove mathematically that our reference implementations are correct.  ACL2 requires manual effort and a disciplined development of the program being analyzed.  The effort is reasonable since the number of such transformations is small and verification is done off-line once for each transformation.  Our implem..."
 }
}