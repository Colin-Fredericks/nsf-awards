{
 "awd_id": "0855889",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER:  Horseshoes and Hand Grenades:  Exploiting Error Tolerance in Applications",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Ahmed Louri",
 "awd_eff_date": "2008-08-01",
 "awd_exp_date": "2012-05-31",
 "tot_intn_awd_amt": 242848.0,
 "awd_amount": 258848.0,
 "awd_min_amd_letter_date": "2009-01-23",
 "awd_max_amd_letter_date": "2011-05-06",
 "awd_abstract_narration": "The goal in most reliability projects has, traditionally, been to prevent errors of all kinds.  Researchers are now discovering that not all errors cause a failure. Some errors can be masked within the circuits as not all inputs affect final results.  By preventing all errors rather than only those errors that change a result, time and power get wasted.  This project proposes to explore techniques which allow errors to occur that do not change final results. In many applications such as facial recognition or voice recognition, many of the data errors will not be noticed by the software, depending on the particular data. For example, if we one bit gets flipped in an incoming audio signal for voice recognition, it may not affect the result at all. The proper word may be recognized despite the error in one sample. A key observation, however, is that even these applications are not very resistant to control flow errors. For example, if the voice recognition software stops before it completes its analysis of the audio signal, the wrong word would most likely be recognized leading to failure. \r\n\r\nThis project explores how to take advantage of partial tolerance to unreliability.  More efficient reliability mechanisms can be designed that are targeted towards only the important instructions, not all instructions. In even more tolerant applications, errors can be introduced into the system in order to speed up the system--allowing the process to proceed without waiting for slow operations.  In order to discover and exploit error-tolerance, this project will identify 10-15 applications that are tolerant to errors, develop heuristics to determine which instructions are more tolerant to error than others, develop specific techniques for efficiently protecting only critical instructions from errors, and develop mechanisms to introduce errors into less important, high-latency instructions in order to save power and/or improve performance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Diana",
   "pi_last_name": "Franklin",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Diana Franklin",
   "pi_email_addr": "dmfranklin@uchicago.edu",
   "nsf_id": "000444531",
   "pi_start_date": "2009-01-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Santa Barbara",
  "inst_street_address": "3227 CHEADLE HALL",
  "inst_street_address_2": "",
  "inst_city_name": "SANTA BARBARA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8058934188",
  "inst_zip_code": "931060001",
  "inst_country_name": "United States",
  "cong_dist_code": "24",
  "st_cong_dist_code": "CA24",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SANTA BARBARA",
  "org_prnt_uei_num": "",
  "org_uei_num": "G9QBQDH39DF4"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Santa Barbara",
  "perf_str_addr": "3227 CHEADLE HALL",
  "perf_city_name": "SANTA BARBARA",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "931060001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "24",
  "perf_st_cong_dist": "CA24",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0107",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 2848.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 60000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 76000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 60000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 60000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This CAREER award funded four research efforts - two in computer architecture and two outreach projects for computer science education.</p>\n<p>In our first project, we looked at how to project the computer from errors caused by unexpected errors, such as radiation from the sun.&nbsp; A common way to protect against this is to run every instruction in the program twice.&nbsp; This requires twice as much hardware for the same program.&nbsp; We found that, especially in multimedia applications like streaming video, audio, or artificial intelligence applications, there is no appreciable loss in accuracy if specific instructions are incorrect.&nbsp; Therefore, we built a system that only runs the important instructions twice.&nbsp; Depending on the application, we were able to reduce the overhead by 20-50%.</p>\n<p>Our second project looks at running parallel programs on future parallel chips more efficiently.&nbsp; There are two parts to this, the data the program uses and the instructions it runs.&nbsp; Data is a problem because the parallel programs have not caught up with parallel architectures.&nbsp; These programs were written for computers in which each part of the program ran in a separate machine with its own memory.&nbsp; Therefore, much of the same data was stored in each machine.&nbsp; Now, all of these parts of the program are run on the same chip, sharing the same memory.&nbsp; To take advantage of this, the programs would need to all be rewritten.&nbsp; We propose to have the system detect when the same data is being used and store it as one piece of data instead of a separate one for each part of the program.&nbsp; We applied this technique to a few different levels in the machine.&nbsp;&nbsp; By applying this to on-chip cache, we saw orders of magnitude speedup.&nbsp; When used in off-chip memory, we saved 37-60% of the&nbsp; memory, allowing larger programs to be executed on the same machine.&nbsp;</p>\n<p>We then tackled computation on the chip - reducing instructions rather than memory space.&nbsp; We found that for many parallel applications, they execute many of the same instructions, sometimes with the same data.&nbsp; This is not programmer error - if these instructions were normally only executed once, and all parts of the program needed the results, it would be very slow to communicate all of those results to the other parts of the program.&nbsp; We designed a processor that detects when the instructions be executed are the same.&nbsp; If so, it only executes them once.&nbsp; The key is that the communication is free because this is all done in the same processor with shared resources.</p>\n<p>Finally, we made significant contributions to broader impacts with computer science education work.&nbsp; We had three undergraduate &nbsp;students create the pilot system for a summer camp eventually funded through the NSF Broadening Participation in Computing Grant.&nbsp; This summer camp is for female and Latina/o middle school students to introduce them to computer science through engaging projects based on Mayan culture and endangered species.&nbsp; This camp has been very successful, increasing interest in computer science as a field, confidence in computer science skills, and experience with programming.&nbsp; Each summer, almost half of the females eligible to return to the camp have applied to return.&nbsp; In addition, we analyzed the needs of K-12 educational cell phone applications and compared that to the known behaviors of cell phones as they fail from old age.&nbsp; We determined that K-12 education is an excellent match for used cell phones and hope this will spur innovation in the use of cell phone technology in K-12 education.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/04/2012<br>\n\t\t\t\t\tModified by: Diana&nbsp;Franklin</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis CAREER award funded four research efforts - two in computer architecture and two outreach projects for computer science education.\n\nIn our first project, we looked at how to project the computer from errors caused by unexpected errors, such as radiation from the sun.  A common way to protect against this is to run every instruction in the program twice.  This requires twice as much hardware for the same program.  We found that, especially in multimedia applications like streaming video, audio, or artificial intelligence applications, there is no appreciable loss in accuracy if specific instructions are incorrect.  Therefore, we built a system that only runs the important instructions twice.  Depending on the application, we were able to reduce the overhead by 20-50%.\n\nOur second project looks at running parallel programs on future parallel chips more efficiently.  There are two parts to this, the data the program uses and the instructions it runs.  Data is a problem because the parallel programs have not caught up with parallel architectures.  These programs were written for computers in which each part of the program ran in a separate machine with its own memory.  Therefore, much of the same data was stored in each machine.  Now, all of these parts of the program are run on the same chip, sharing the same memory.  To take advantage of this, the programs would need to all be rewritten.  We propose to have the system detect when the same data is being used and store it as one piece of data instead of a separate one for each part of the program.  We applied this technique to a few different levels in the machine.   By applying this to on-chip cache, we saw orders of magnitude speedup.  When used in off-chip memory, we saved 37-60% of the  memory, allowing larger programs to be executed on the same machine. \n\nWe then tackled computation on the chip - reducing instructions rather than memory space.  We found that for many parallel applications, they execute many of the same instructions, sometimes with the same data.  This is not programmer error - if these instructions were normally only executed once, and all parts of the program needed the results, it would be very slow to communicate all of those results to the other parts of the program.  We designed a processor that detects when the instructions be executed are the same.  If so, it only executes them once.  The key is that the communication is free because this is all done in the same processor with shared resources.\n\nFinally, we made significant contributions to broader impacts with computer science education work.  We had three undergraduate  students create the pilot system for a summer camp eventually funded through the NSF Broadening Participation in Computing Grant.  This summer camp is for female and Latina/o middle school students to introduce them to computer science through engaging projects based on Mayan culture and endangered species.  This camp has been very successful, increasing interest in computer science as a field, confidence in computer science skills, and experience with programming.  Each summer, almost half of the females eligible to return to the camp have applied to return.  In addition, we analyzed the needs of K-12 educational cell phone applications and compared that to the known behaviors of cell phones as they fail from old age.  We determined that K-12 education is an excellent match for used cell phones and hope this will spur innovation in the use of cell phone technology in K-12 education.\n\n\t\t\t\t\tLast Modified: 07/04/2012\n\n\t\t\t\t\tSubmitted by: Diana Franklin"
 }
}