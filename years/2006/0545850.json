{
 "awd_id": "0545850",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "\"CAREER:\" Enforcing and Validating User-Defined Programming Disciplines",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "John Reppy",
 "awd_eff_date": "2006-03-15",
 "awd_exp_date": "2012-02-29",
 "tot_intn_awd_amt": 320000.0,
 "awd_amount": 400000.0,
 "awd_min_amd_letter_date": "2006-02-16",
 "awd_max_amd_letter_date": "2010-03-29",
 "awd_abstract_narration": "ABSTRACT\r\n\r\nCCF-0545850\r\nTodd Millstein\r\nUniversity of California - Los Angeles\r\n\r\nCAREER: Enforcing and Validating User-Defined Programming Disciplines\r\n\r\nProgrammers manage the complexity of developing and maintaining software systems by adhering to various programming disciplines, which impose additional structure on program entities.  However, today's\r\nprogramming languages lack support for specifying and checking important classes of programming disciplines, making these disciplines easy to forget or misuse.  This research investigates a framework for\r\nuser-defined programming disciplines.  A user of the framework specifies a programming discipline through declarative rules, which are automatically enforced on programs at compile time.  The user may also specify a discipline's intended run-time invariants, and the framework helps to ensure that the provided rules respect these invariants.  The research focuses on an instantiation of the framework for Java that targets three major discipline classes: disciplines for design patterns; disciplines that impose structure on concurrent\r\nprograms, and disciplines that ensure strong forms of object encapsulation.  The proposed framework aims to improve the quality of software systems by allowing programmers to easily document, enforce, and validate relied-upon programming disciplines.  The resulting tools will be made publicly available and incorporated in the classroom.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Todd",
   "pi_last_name": "Millstein",
   "pi_mid_init": "D",
   "pi_sufx_name": "",
   "pi_full_name": "Todd D Millstein",
   "pi_email_addr": "todd@cs.ucla.edu",
   "nsf_id": "000229495",
   "pi_start_date": "2006-02-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Los Angeles",
  "inst_street_address": "10889 WILSHIRE BLVD STE 700",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "3107940102",
  "inst_zip_code": "900244200",
  "inst_country_name": "United States",
  "cong_dist_code": "36",
  "st_cong_dist_code": "CA36",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, LOS ANGELES",
  "org_prnt_uei_num": "",
  "org_uei_num": "RN64EPNH8JC6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Los Angeles",
  "perf_str_addr": "10889 WILSHIRE BLVD STE 700",
  "perf_city_name": "LOS ANGELES",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "900244200",
  "perf_ctry_code": "US",
  "perf_cong_dist": "36",
  "perf_st_cong_dist": "CA36",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "288000",
   "pgm_ele_name": "SOFTWARE ENGINEERING AND LANGU"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0106",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0106",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0107",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2006,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 160000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 80000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software is everywhere in our society and is critical to a wide range<br />of activities, from commerce and finance to scientific research to<br />control of automotive and avionics systems.&nbsp; However, building robust<br />software systems today is a significant challenge, due in part to the<br />fragile nature of the languages in which computer programs are<br />written.&nbsp; Software programmers must get myriads of small details<br />right, and any false move or omission can lead to system crashes,<br />incorrect operation, and security vulnerabilities.<br /><br />One way that programming languages help programmers manage this<br />complexity is by checking a set of correctness constraints on<br />programs.&nbsp; The checkers, called <em>static type systems</em>, check programs<br />before they are run and guarantee basic correctness properties for all<br />possible executions of a program.&nbsp; For example, the popular Java<br />programming language includes a static type system that can catch a<br />range of errors, from simple typos (e.g., accidentally referring to<br />some program entity by the wrong name) to more subtle issues (e.g.,<br />forgetting to handle the possibility of a network disconnection).<br /><br />While static type systems are quite useful, today they are set in<br />stone by the programming language provider and only check for a small<br />set of program errors.&nbsp; Any other checks that programmers require for<br />their applications must be performed through manual code inspection<br />and testing, a process which is costly, tedious, and error prone.<br />Therefore, it is highly desirable to allow programmers to easily<br />augment a language's static type system to enforce additional<br />constraints on programs.&nbsp; Such optional type system extensions have<br />come to be known as <em>pluggable type systems</em>.<br /><br />This project has advanced both the theory and practice of pluggable<br />type systems.&nbsp; The main artifact resulting from our research is<br />JavaCOP, the first pluggable type system for the popular Java<br />programming language.&nbsp; JavaCOP includes a special language for<br />specifying new checks and includes several expressive features that we<br />found to be necessary in practice.&nbsp; We have built a diverse suite of<br />pluggable type systems in JavaCOP and used them to ensure important<br />properties and detect errors in hundreds of thousands of lines of<br />existing Java software.<br /><br />Pluggable type systems like JavaCOP help programmers to identify<br />important errors in their software.&nbsp; Once an error is found, the<br />programmer must still deduce its cause and decide how to repair the<br />error, which are themselves difficult tasks.&nbsp; Therefore in the final<br />part of this project we have developed novel approaches to automatic <em>program repair</em>.&nbsp; Our first approach is useful during the testing phase of software development.&nbsp; Given a set of test inputs for a program, some of which cause the program to behave erroneously, our approach automatically modifies the program so that it behaves correctly on all test inputs.&nbsp; Our second approach monitors a running program for errors and automatically modifies its execution state in order to restore programmer-specified correctness properties.&nbsp; This approach allows deployed software to gracefully recover from errors in order to safely continue execution.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 05/21/2012<br>\n\t\t\t\t\tModified by: Todd&nbsp;D&nbsp;Millstein</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware is everywhere in our society and is critical to a wide range\nof activities, from commerce and finance to scientific research to\ncontrol of automotive and avionics systems.  However, building robust\nsoftware systems today is a significant challenge, due in part to the\nfragile nature of the languages in which computer programs are\nwritten.  Software programmers must get myriads of small details\nright, and any false move or omission can lead to system crashes,\nincorrect operation, and security vulnerabilities.\n\nOne way that programming languages help programmers manage this\ncomplexity is by checking a set of correctness constraints on\nprograms.  The checkers, called static type systems, check programs\nbefore they are run and guarantee basic correctness properties for all\npossible executions of a program.  For example, the popular Java\nprogramming language includes a static type system that can catch a\nrange of errors, from simple typos (e.g., accidentally referring to\nsome program entity by the wrong name) to more subtle issues (e.g.,\nforgetting to handle the possibility of a network disconnection).\n\nWhile static type systems are quite useful, today they are set in\nstone by the programming language provider and only check for a small\nset of program errors.  Any other checks that programmers require for\ntheir applications must be performed through manual code inspection\nand testing, a process which is costly, tedious, and error prone.\nTherefore, it is highly desirable to allow programmers to easily\naugment a language's static type system to enforce additional\nconstraints on programs.  Such optional type system extensions have\ncome to be known as pluggable type systems.\n\nThis project has advanced both the theory and practice of pluggable\ntype systems.  The main artifact resulting from our research is\nJavaCOP, the first pluggable type system for the popular Java\nprogramming language.  JavaCOP includes a special language for\nspecifying new checks and includes several expressive features that we\nfound to be necessary in practice.  We have built a diverse suite of\npluggable type systems in JavaCOP and used them to ensure important\nproperties and detect errors in hundreds of thousands of lines of\nexisting Java software.\n\nPluggable type systems like JavaCOP help programmers to identify\nimportant errors in their software.  Once an error is found, the\nprogrammer must still deduce its cause and decide how to repair the\nerror, which are themselves difficult tasks.  Therefore in the final\npart of this project we have developed novel approaches to automatic program repair.  Our first approach is useful during the testing phase of software development.  Given a set of test inputs for a program, some of which cause the program to behave erroneously, our approach automatically modifies the program so that it behaves correctly on all test inputs.  Our second approach monitors a running program for errors and automatically modifies its execution state in order to restore programmer-specified correctness properties.  This approach allows deployed software to gracefully recover from errors in order to safely continue execution.\n\n\t\t\t\t\tLast Modified: 05/21/2012\n\n\t\t\t\t\tSubmitted by: Todd D Millstein"
 }
}