{
 "awd_id": "0546060",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Practical Transactional Memory for Highly Parallel Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Hong Jiang",
 "awd_eff_date": "2006-05-01",
 "awd_exp_date": "2013-04-30",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 250000.0,
 "awd_min_amd_letter_date": "2006-04-19",
 "awd_max_amd_letter_date": "2010-05-06",
 "awd_abstract_narration": "With uniprocessor systems running into fundamental limitations such as power consumption and design complexity, single-chip multiprocessors provide a realistic path toward scalable performance for server, embedded, and desktop applications. Nevertheless, the key factor limiting the potential of multiprocessor architectures is the difficulty of developing parallel programs. Existing multithreading models with lock-based synchronization introduce complex tradeoffs between functional correctness and performance that most programmers cannot master. Transactional memory provides an alternative model for concurrency management in multiprocessors based on the well-known database concept of atomic transactions. This project will develop new multiprocessor architectures to efficiently implement transactional memory. The first goal is to define the architectural semantics of transactional memory that support intuitive parallel programming models. The second goal is to develop practical hardware implementations of transactional memory that provide high performance in single-chip multiprocessor systems. The project will result in a restructuring of the hardware and software interfaces for synchronization and concurrency management and will pave the way towards multiprocessors that are easy to program, cost-effective to implement, and fast. The project will also provide students with the knowledge and skills necessary to develop and efficiently program the next generation of single-chip multiprocessors for server, embedded, and desktop applications.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Christoforos",
   "pi_last_name": "Kozyrakis",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Christoforos Kozyrakis",
   "pi_email_addr": "kozyraki@stanford.edu",
   "nsf_id": "000486618",
   "pi_start_date": "2006-04-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Stanford University",
  "inst_street_address": "450 JANE STANFORD WAY",
  "inst_street_address_2": "",
  "inst_city_name": "STANFORD",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "6507232300",
  "inst_zip_code": "943052004",
  "inst_country_name": "United States",
  "cong_dist_code": "16",
  "st_cong_dist_code": "CA16",
  "org_lgl_bus_name": "THE LELAND STANFORD JUNIOR UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HJD6G4D6TJY5"
 },
 "perf_inst": {
  "perf_inst_name": "Stanford University",
  "perf_str_addr": "450 JANE STANFORD WAY",
  "perf_city_name": "STANFORD",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "943052004",
  "perf_ctry_code": "US",
  "perf_cong_dist": "16",
  "perf_st_cong_dist": "CA16",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0106",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2006,
   "fund_oblg_amt": 50000.0
  },
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 100000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 50000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 50000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>With uniprocessors running into fundamental limitations, multi-core chips have become widespread in mobile, desktop, and server systems. However, the key factor limiting the potential of multi-core chips is the complexity of parallel software development using locks for concurrency management. Locking primitives introduce difficult performance-correctness tradeoffs, are not composable, and are not robust to failures. As a result, most applications are still sequential and cannot benefit from the increasing number of cores in modern systems.</p>\n<p>&nbsp;Transactional memory provides an intuitive model for concurrency management that addresses the challenges of locks. Transactions implement non-blocking synchronization, are composable, provide failure isolation, and allow for speculative parallelization of sequential code. Even though several researchers have shown the potential of hardware support for transactional memory, several challenges remain before it becomes a practical mechanism for modern systems. First, transactional memory needs to be a first-class concept in widespread instruction set architectures, including the features necessary to support modern programming languages. Second, transactional memory must be integrated with modern operating systems and virtualization techniques. Finally, we need practical and cost-efficient hardware implementations for current multi-core chips and future chips with tens or hundreds of cores.&nbsp;</p>\n<p>&nbsp;</p>\n<p>The goal of this project has been to research, develop, and disseminate the techniques necessary to make hardware transactional memory a practical and efficient mechanism for concurrency management in highly parallel systems. Our research produced the following outcomes. First, we developed instruction set extensions that define rich and clean semantics for hardware transactional memory that support modern programming practices such as nested parallelism or user-controlled exception handling, allow I/O operations and transactions to co-exist, and enable for a wide range of implementations. Second, we developed operating systems techniques that that virtualize hardware resources for transactional memory, allow for IO accesses within transactions, and provide efficient support for interrupt and exception handling. Hence, programmers can make use of large, long-lived transactions in their programs. Third, we developed a wide-range of cost-effective hardware mechanisms for transactional memory in small-scale and large-scale multi-core chips. The mechanisms included both hardware-only techniques and hybrid hardware/software mechanisms.</p>\n<p>&nbsp;</p>\n<p>To demonstrate the capabilities of these techniques, we designed prototypes of hardware systems and programming languages. We developed ATLAS, the first full-system hardware transactional memory prototype that allowed execution of transactional programs on 8 processor cores under the control of the Linux operating system. We also developed FARM, the first prototype to provide hardware transactional memory support for existing, commercial, multi-core chips. We demonstrated the benefits of transactional memory support for programming languages by developing the C-based Open-TM language and the Java-based ATOMOS language. We also showed how transactional constructs can support advanced functionality such as semantic concurrency control, garbage collection, checkpointing and snapshots, and advanced security features. Finally, we executed a systematic comparison of design and implementation options for transactional memory, including software, hardware, and hybrid approaches.</p>\n<p>&nbsp;</p>\n<p>Our project demonstrated that transactional memory allows for both simplified software development and scalable performance from current and future multi-core chips. However, it also showed that these benefits require hardware support, as software-only techniques are ins...",
  "por_txt_cntn": "\nWith uniprocessors running into fundamental limitations, multi-core chips have become widespread in mobile, desktop, and server systems. However, the key factor limiting the potential of multi-core chips is the complexity of parallel software development using locks for concurrency management. Locking primitives introduce difficult performance-correctness tradeoffs, are not composable, and are not robust to failures. As a result, most applications are still sequential and cannot benefit from the increasing number of cores in modern systems.\n\n Transactional memory provides an intuitive model for concurrency management that addresses the challenges of locks. Transactions implement non-blocking synchronization, are composable, provide failure isolation, and allow for speculative parallelization of sequential code. Even though several researchers have shown the potential of hardware support for transactional memory, several challenges remain before it becomes a practical mechanism for modern systems. First, transactional memory needs to be a first-class concept in widespread instruction set architectures, including the features necessary to support modern programming languages. Second, transactional memory must be integrated with modern operating systems and virtualization techniques. Finally, we need practical and cost-efficient hardware implementations for current multi-core chips and future chips with tens or hundreds of cores. \n\n \n\nThe goal of this project has been to research, develop, and disseminate the techniques necessary to make hardware transactional memory a practical and efficient mechanism for concurrency management in highly parallel systems. Our research produced the following outcomes. First, we developed instruction set extensions that define rich and clean semantics for hardware transactional memory that support modern programming practices such as nested parallelism or user-controlled exception handling, allow I/O operations and transactions to co-exist, and enable for a wide range of implementations. Second, we developed operating systems techniques that that virtualize hardware resources for transactional memory, allow for IO accesses within transactions, and provide efficient support for interrupt and exception handling. Hence, programmers can make use of large, long-lived transactions in their programs. Third, we developed a wide-range of cost-effective hardware mechanisms for transactional memory in small-scale and large-scale multi-core chips. The mechanisms included both hardware-only techniques and hybrid hardware/software mechanisms.\n\n \n\nTo demonstrate the capabilities of these techniques, we designed prototypes of hardware systems and programming languages. We developed ATLAS, the first full-system hardware transactional memory prototype that allowed execution of transactional programs on 8 processor cores under the control of the Linux operating system. We also developed FARM, the first prototype to provide hardware transactional memory support for existing, commercial, multi-core chips. We demonstrated the benefits of transactional memory support for programming languages by developing the C-based Open-TM language and the Java-based ATOMOS language. We also showed how transactional constructs can support advanced functionality such as semantic concurrency control, garbage collection, checkpointing and snapshots, and advanced security features. Finally, we executed a systematic comparison of design and implementation options for transactional memory, including software, hardware, and hybrid approaches.\n\n \n\nOur project demonstrated that transactional memory allows for both simplified software development and scalable performance from current and future multi-core chips. However, it also showed that these benefits require hardware support, as software-only techniques are insufficient to achieve the potential of transactional memory as a concurrency management construct. The architecture and micro-arch..."
 }
}