{
 "awd_id": "0712794",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "HCC: Evaluating the Performance of Distributed  Synchronous Collaboration Architectures",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Susan Fussell",
 "awd_eff_date": "2007-09-01",
 "awd_exp_date": "2011-08-31",
 "tot_intn_awd_amt": 0.0,
 "awd_amount": 475919.0,
 "awd_min_amd_letter_date": "2007-08-29",
 "awd_max_amd_letter_date": "2011-03-30",
 "awd_abstract_narration": "There has been a recent proliferation of industrial-strength synchronous collaborative systems, however, there has been little research comparing the performance of their distributed architectures, even though inadequate performance can be a show-stopper. In systematically examining this architectural design space, this project will provide a critical foundation for what is currently the ''black art'' of collaborative system design. This will have broad ranging impact in both research and industry.  \r\n\r\nThe architecture design space will be modeled by several architecture parameters (e.g., transport protocol, server configuration, I/O scheduling), system parameters (e.g., network latency, processing power) and task parameters (e.g., I/O size, think time) that impact performance. Equations will be developed that give the value of the time, along key metrics such as join, leave, response, feedthrough, and task-completion, as a function of the architecture, system, and task parameters. Experiments will be performed to validate these equations using logs of different kinds of collaborations such as multi-user presentations, chats, and scientific visualizations. This novel experimental test bed will enable performance comparisons that have not been possible before. \r\n\r\nBroader impact: The analytic model resulting from this research will allow application and infrastructure developers to determine the range of architectures they should implement. It will provide scientists, engineers, writers, and other users of collaboration technology a better understanding of the design space so they can choose the correct architecture to fit their needs while appreciating the performance consequences of that choice. In addition, the project infrastructure will form the first proof-of-concept system supporting the entire space of collaborative architectures, a novel research test-bed for experimentation, and a vehicle for teaching collaboration architectures. The multi-user activity logs created for these experiments will be publicized so that they can become benchmarks, in both academic and industrial research, used to compare performance of new architectures.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Prasun",
   "pi_last_name": "Dewan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Prasun Dewan",
   "pi_email_addr": "dewan@cs.unc.edu",
   "nsf_id": "000336210",
   "pi_start_date": "2007-08-29",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of North Carolina at Chapel Hill",
  "inst_street_address": "104 AIRPORT DR STE 2200",
  "inst_street_address_2": "",
  "inst_city_name": "CHAPEL HILL",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9199663411",
  "inst_zip_code": "275995023",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL",
  "org_prnt_uei_num": "D3LHU66KBLD5",
  "org_uei_num": "D3LHU66KBLD5"
 },
 "perf_inst": {
  "perf_inst_name": "University of North Carolina at Chapel Hill",
  "perf_str_addr": "104 AIRPORT DR STE 2200",
  "perf_city_name": "CHAPEL HILL",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "275995023",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736700",
   "pgm_ele_name": "HCC-Human-Centered Computing"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7367",
   "pgm_ref_txt": "Cyber-Human Systems"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0107",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 147490.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 141680.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 162749.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The increasingly popular multi-user webinars, games, and document editing are examples of distributed synchronous collaboration technology. The interactivity of a synchronous application can be the difference between life and death in synchronous collaboration. &nbsp;If a system does not display the results of an action to a user in a timely fashion, the user may get frustrated and switch to a different system or, worse, never use a collaborative system again.&nbsp; One way to improve performance is to use faster computers and communication links.&nbsp; As this solution is expensive and not always possible, our research has developed techniques that attempt to automatically optimize the use of existing resources. Rather than focusing on a particular implementation, or class of applications, we have taken an application-independent approach.</p>\n<p>In general, the computers of all users interacting with a collaborative application are involved in executing the application.&nbsp; Each of these computers gathers input from and displays output to the local user, and communicates information to other computers. Optionally, it can also perform some of the processing of user actions (such as determining the next slide to present in a webinar), and route information to other computers. &nbsp;Our experiments found that the performance of an application depends on three architectural dimensions including: (1) which computers process actions, (2) how information is routed among them, and (3) how processing and routing tasks are scheduled on different computers and how many cores are available to perform these tasks.&nbsp; One particularly interesting result had to with a new scheduling policy we invented, which was based on psychological experiments showing that users cannot perceive delays of less than 50 milliseconds. &nbsp;We found that, under this policy, a non-perceptible increase in the response time of a user could result in much larger, perceptible, reduction in response times of other users. &nbsp;This policy is an interesting example of merging computer science and psychology research</p>\n<p>The architecture factors we identified can be used to manually tune the performance of an application, but this &ldquo;trial and error&rdquo; approach is tedious and error prone. &nbsp;Therefore, we developed mathematical equations that can predict the effect of changes to these factors, and verified that these equations were consistent with our experimental observations. The final step was to develop a self optimizing software system that (a) is independent of any particular application, (b) keeps track of various performance parameters such&nbsp; how much time is taken by each computer to process actions and communicate them,&nbsp; how much time users take to think between actions, and &nbsp;network latencies to all other computers, (c) automatically changes the architecture along one of the three dimensions based on predictions of our equations,&nbsp; and (d) keeps the overhead of monitoring&nbsp; parameters and changing architecture&nbsp; low. To illustrate a simple use of this system, suppose a user on a tablet is giving a PPT presentation to a user on a smart phone. As the smart phone is slow, all PPT processing is done on the tablet.&nbsp; Suppose a new user with a powerful laptop joins the session.&nbsp; &nbsp;The PPT presentation application would automatically move to the laptop when the latecomer joins (if the equations predict that this change would be beneficial), and move back to the tablet if he/she leaves. Our work is even more important to support large scalable collaborative sessions, such as state of the union webinar presentation to the whole country or the whole world.&nbsp;</p>\n<p>The extent to which our work can help, of course, depends on various factors such as the configuration of computers and communication links and the application, but our results sh...",
  "por_txt_cntn": "\nThe increasingly popular multi-user webinars, games, and document editing are examples of distributed synchronous collaboration technology. The interactivity of a synchronous application can be the difference between life and death in synchronous collaboration.  If a system does not display the results of an action to a user in a timely fashion, the user may get frustrated and switch to a different system or, worse, never use a collaborative system again.  One way to improve performance is to use faster computers and communication links.  As this solution is expensive and not always possible, our research has developed techniques that attempt to automatically optimize the use of existing resources. Rather than focusing on a particular implementation, or class of applications, we have taken an application-independent approach.\n\nIn general, the computers of all users interacting with a collaborative application are involved in executing the application.  Each of these computers gathers input from and displays output to the local user, and communicates information to other computers. Optionally, it can also perform some of the processing of user actions (such as determining the next slide to present in a webinar), and route information to other computers.  Our experiments found that the performance of an application depends on three architectural dimensions including: (1) which computers process actions, (2) how information is routed among them, and (3) how processing and routing tasks are scheduled on different computers and how many cores are available to perform these tasks.  One particularly interesting result had to with a new scheduling policy we invented, which was based on psychological experiments showing that users cannot perceive delays of less than 50 milliseconds.  We found that, under this policy, a non-perceptible increase in the response time of a user could result in much larger, perceptible, reduction in response times of other users.  This policy is an interesting example of merging computer science and psychology research\n\nThe architecture factors we identified can be used to manually tune the performance of an application, but this \"trial and error\" approach is tedious and error prone.  Therefore, we developed mathematical equations that can predict the effect of changes to these factors, and verified that these equations were consistent with our experimental observations. The final step was to develop a self optimizing software system that (a) is independent of any particular application, (b) keeps track of various performance parameters such  how much time is taken by each computer to process actions and communicate them,  how much time users take to think between actions, and  network latencies to all other computers, (c) automatically changes the architecture along one of the three dimensions based on predictions of our equations,  and (d) keeps the overhead of monitoring  parameters and changing architecture  low. To illustrate a simple use of this system, suppose a user on a tablet is giving a PPT presentation to a user on a smart phone. As the smart phone is slow, all PPT processing is done on the tablet.  Suppose a new user with a powerful laptop joins the session.   The PPT presentation application would automatically move to the laptop when the latecomer joins (if the equations predict that this change would be beneficial), and move back to the tablet if he/she leaves. Our work is even more important to support large scalable collaborative sessions, such as state of the union webinar presentation to the whole country or the whole world. \n\nThe extent to which our work can help, of course, depends on various factors such as the configuration of computers and communication links and the application, but our results show that it cannot hurt and, in many scenarios, it can help in a significant manner. Perhaps more important, it has led to a better understanding of the architectures of collaborative appl..."
 }
}