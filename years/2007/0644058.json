{
 "awd_id": "0644058",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Foundations for Attack-Resistant, Collaborative Peer-to-peer Systems",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Jeremy Epstein",
 "awd_eff_date": "2007-09-01",
 "awd_exp_date": "2014-08-31",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 400000.0,
 "awd_min_amd_letter_date": "2007-01-18",
 "awd_max_amd_letter_date": "2011-07-20",
 "awd_abstract_narration": "Jared Saia\r\nUniversity of New Mexico\r\nCAREER: Foundations for Attack-Resistant Collaborative Peer-to-Peer Systems\r\n0644058\r\nPanel ID: 070111\r\n\r\nAbstract\r\n\r\n\r\n\r\nHow can a group of agents achieve a goal despite efforts by some of the agents to prevent this?  This important question cuts across many disciplines including political science, economics, mathematics and computer science.  In this proposal, we are exploring this question by focusing on the following problem.  A set of n agents wants to compute the value of a function, f, of n inputs, where each agent holds a unique input of f.   Our goal is to create a distributed algorithm that ensures that each agent learns the output of f.  Our algorithm will be attack-resistant in that it works correctly even when up to a constant fraction of the agents are controlled by an omniscient adversary that tries to prevent the function from being computed.  Our algorithm will also be scalable in the sense that each node in the network sends and receives a number of messages and bits that is only polylogarithmic in n i.e. O(logc n) where c is a fixed constant. We are making use of several tools to solve this problem including: the use of expander-like graphs to enable robust communication; the use of small randomly chosen committees as single trustworthy functional units; and algorithmic techniques to harden against denial of service attacks.  Solving this problem will likely have broader impact in such diverse areas as voting, spam detection, worm and malware detection, distributed file systems, auction and mechanism enforcement, collaborative filtering, and web search.\r\n\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jared",
   "pi_last_name": "Saia",
   "pi_mid_init": "C",
   "pi_sufx_name": "",
   "pi_full_name": "Jared C Saia",
   "pi_email_addr": "saia@cs.unm.edu",
   "nsf_id": "000260597",
   "pi_start_date": "2007-01-18",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of New Mexico",
  "inst_street_address": "1 UNIVERSITY OF NEW MEXICO",
  "inst_street_address_2": "",
  "inst_city_name": "ALBUQUERQUE",
  "inst_state_code": "NM",
  "inst_state_name": "New Mexico",
  "inst_phone_num": "5052774186",
  "inst_zip_code": "871310001",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "NM01",
  "org_lgl_bus_name": "UNIVERSITY OF NEW MEXICO",
  "org_prnt_uei_num": "",
  "org_uei_num": "F6XLTRUQJEN4"
 },
 "perf_inst": {
  "perf_inst_name": "University of New Mexico",
  "perf_str_addr": "1 UNIVERSITY OF NEW MEXICO",
  "perf_city_name": "ALBUQUERQUE",
  "perf_st_code": "NM",
  "perf_st_name": "New Mexico",
  "perf_zip_code": "871310001",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "NM01",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "409000",
   "pgm_ele_name": "ADVANCED NET INFRA & RSCH"
  },
  {
   "pgm_ele_code": "779500",
   "pgm_ele_name": "TRUSTWORTHY COMPUTING"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 80001.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 79999.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 80000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><strong>Intellectual Merit:</strong> This project had outcomes in two major areas related to intellectial merit. &nbsp;The first main area was designing efficient algorithms for the problem of Byzantine agreement. &nbsp;Intuitively, the Byzantine agreement problem asks if a group of processors can come to agreement on a single bit, despite the efforts of a hidden fraction of processors to subvert this goal. &nbsp;Byzantine agreement is one of the most fundamental problems in computer science and has applications in areas as diverse as airplane flight systems, data base systems, computer auctions, peer-to-peer systems and cloud computing. &nbsp;</p>\n<p>We have two major results on Byzantine agreement. &nbsp;Our first result resolves a problem that has been open since 1983: does there exist an polynomial time &nbsp;algorithm for Byzantine agreement in the <em>hard</em> model? &nbsp;Intuitively, polynomial time means efficient in terms of the amount of time the algorithm requires to terminate. &nbsp;In the&nbsp;hard model, the adversary is adaptive: it can take over processors at any point during the protocol, up to the point of taking over a certain threshold. Communication is asynchronous: the scheduling of the delivery of messages is set by the adversary, so that the delays are unpredictable to the algorithm. Finally, the adversary has full information: it knows the states of all processors at any time, and is assumed to be computationally unbounded. &nbsp;Our paper on this result was published in the prestigious conferences Foundations of Computer Science (FOCS) and Symposium on Discrete Algorithms (SODA).</p>\n<p>Our second major result in Byzantine agreement is an algorithm that is efficient in terms of badwidth i.e. the total number of messages that must be communicated among the processors. &nbsp;Previous algorithms for Byzantine agreement required each processor to send at least n messages , where n is the number of processors. &nbsp;Our algorithm reduces this amount to roughly square root of n.&nbsp;</p>\n<p>The second major area of results was for the problem of secure multiparty computation. &nbsp;The secure multiparty computation (MPC) problem is a generalization of the Byzantine agreement problem. &nbsp;In MPC, there are n processors, each with a private input that want to compute a function f over all of their inputs, without revealing any more information about the private inputs than what is revealed by the output of f. &nbsp;The problem is complicated by the fact that a hidden fraction of the players are controlled by an adversary that is actively trying to corrupt the output and/or obtain information about the inputs. &nbsp;This problem has application in many areas of computer security.</p>\n<p>Our result in this area is an algorithm that is scalable in the sense that the number of messages sent by each processor is essentially the square root of n, the number of processors. &nbsp;This contrasts with previous results for this problem where the number of messages sent is linear in n. &nbsp;Our result used mathematical and algorithmic tools that we previously developed in solving the Byzantine agreement problem. &nbsp; Our paper describing this result won a best paper award at the International Conference on Distributed Computing and Networking (ICDCN), 2014.</p>\n<p>In all, this grant has generater over 20 papers, 1 best paper award and one article in the Journal of the ACM.</p>\n<p><strong>Broader Impact:</strong></p>\n<p>This grant supported four PhD students, two of whom have graduated and two of whom are within one year of graduation. &nbsp;PhD student Muyiwa Olumuyiwasa, graduated in the spring of 2011. &nbsp;Muyiwa is a minority student (native Nigerian) and is now working at Intel Corporation. &nbsp;PhD student Navin Rustagi graduated in the summer of 2010 and became a post doc in the Statistics department at Rice University. &nbsp;PhD student Geor...",
  "por_txt_cntn": "\nIntellectual Merit: This project had outcomes in two major areas related to intellectial merit.  The first main area was designing efficient algorithms for the problem of Byzantine agreement.  Intuitively, the Byzantine agreement problem asks if a group of processors can come to agreement on a single bit, despite the efforts of a hidden fraction of processors to subvert this goal.  Byzantine agreement is one of the most fundamental problems in computer science and has applications in areas as diverse as airplane flight systems, data base systems, computer auctions, peer-to-peer systems and cloud computing.  \n\nWe have two major results on Byzantine agreement.  Our first result resolves a problem that has been open since 1983: does there exist an polynomial time  algorithm for Byzantine agreement in the hard model?  Intuitively, polynomial time means efficient in terms of the amount of time the algorithm requires to terminate.  In the hard model, the adversary is adaptive: it can take over processors at any point during the protocol, up to the point of taking over a certain threshold. Communication is asynchronous: the scheduling of the delivery of messages is set by the adversary, so that the delays are unpredictable to the algorithm. Finally, the adversary has full information: it knows the states of all processors at any time, and is assumed to be computationally unbounded.  Our paper on this result was published in the prestigious conferences Foundations of Computer Science (FOCS) and Symposium on Discrete Algorithms (SODA).\n\nOur second major result in Byzantine agreement is an algorithm that is efficient in terms of badwidth i.e. the total number of messages that must be communicated among the processors.  Previous algorithms for Byzantine agreement required each processor to send at least n messages , where n is the number of processors.  Our algorithm reduces this amount to roughly square root of n. \n\nThe second major area of results was for the problem of secure multiparty computation.  The secure multiparty computation (MPC) problem is a generalization of the Byzantine agreement problem.  In MPC, there are n processors, each with a private input that want to compute a function f over all of their inputs, without revealing any more information about the private inputs than what is revealed by the output of f.  The problem is complicated by the fact that a hidden fraction of the players are controlled by an adversary that is actively trying to corrupt the output and/or obtain information about the inputs.  This problem has application in many areas of computer security.\n\nOur result in this area is an algorithm that is scalable in the sense that the number of messages sent by each processor is essentially the square root of n, the number of processors.  This contrasts with previous results for this problem where the number of messages sent is linear in n.  Our result used mathematical and algorithmic tools that we previously developed in solving the Byzantine agreement problem.   Our paper describing this result won a best paper award at the International Conference on Distributed Computing and Networking (ICDCN), 2014.\n\nIn all, this grant has generater over 20 papers, 1 best paper award and one article in the Journal of the ACM.\n\nBroader Impact:\n\nThis grant supported four PhD students, two of whom have graduated and two of whom are within one year of graduation.  PhD student Muyiwa Olumuyiwasa, graduated in the spring of 2011.  Muyiwa is a minority student (native Nigerian) and is now working at Intel Corporation.  PhD student Navin Rustagi graduated in the summer of 2010 and became a post doc in the Statistics department at Rice University.  PhD student George Saad will be  graduating in the Spring of 2014 and plans to find a job in industry.  Finally, PhD student Jeffrey Knockel will likely graduate in 2015 or 2016.  The grant also supported one female MS student, Jenny Chen, who is graduating in the fall of 2014.\n\n \n\n..."
 }
}