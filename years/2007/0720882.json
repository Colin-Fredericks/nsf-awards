{
 "awd_id": "0720882",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Collaborative Research: CSR-EHS: Pret: Precision Timed Architectures",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2007-08-01",
 "awd_exp_date": "2013-12-31",
 "tot_intn_awd_amt": 549994.0,
 "awd_amount": 819072.0,
 "awd_min_amd_letter_date": "2007-08-07",
 "awd_max_amd_letter_date": "2011-09-16",
 "awd_abstract_narration": "Abstractions currently used in computing hide timing properties of software. As a consequence, computer scientists have developed techniques that deliver improved average-case performance and/or design convenience at the expense of timing predictability. For embedded software, which interacts closely with physical processes, timing is usually an essential property. Lack of timing in the core abstractions results in brittle and non-portable designs. Moreover, as embedded software becomes more networked, the prevailing empirical test-based approach to achieving real-time computing becomes inadequate.\r\n\r\nThis project reintroduces timing predictability as a first-class property of embedded processor architectures. It tackles the problem from the hardware design perspective, developing precision timed (PRET) machines as soft cores on FPGAs. It shows that software on PRET machines can be integrated with what would traditionally have been purely hardware designs. This project seeks to reinvigorate research in an area of computer science and computer architecure that have stagnated in research due to maturing industrial practice. This is expected to provide a starting point for a decades-long revolution that will once again make timing predictability an essential feature of processors.  This project addresses the core abstractions of computing. Rather than attempting to correct the lack of timing in these abstractions with more layers of abstraction, this project has the goal of showing that embedded processors can deliver both predictable timing and high performance. It opens up the field to new computing abstractions that include timing as a first-class property.  \r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Edward",
   "pi_last_name": "Lee",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Edward A Lee",
   "pi_email_addr": "eal@eecs.berkeley.edu",
   "nsf_id": "000479285",
   "pi_start_date": "2007-08-07",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Jan",
   "pi_last_name": "Rabaey",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jan Rabaey",
   "pi_email_addr": "jan@eecs.Berkeley.edu",
   "nsf_id": "000472478",
   "pi_start_date": "2007-08-07",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "John",
   "pi_last_name": "Wawrzynek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "John Wawrzynek",
   "pi_email_addr": "johnw@eecs.berkeley.edu",
   "nsf_id": "000063703",
   "pi_start_date": "2007-08-07",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Berkeley",
  "inst_street_address": "1608 4TH ST STE 201",
  "inst_street_address_2": "",
  "inst_city_name": "BERKELEY",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "5106433891",
  "inst_zip_code": "947101749",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "CA12",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE",
  "org_prnt_uei_num": "",
  "org_uei_num": "GS3YEVSS12N6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Berkeley",
  "perf_str_addr": "1608 4TH ST STE 201",
  "perf_city_name": "BERKELEY",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "947101749",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "CA12",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "170E",
   "pgm_ref_txt": "Interagency Agreements"
  },
  {
   "pgm_ref_code": "2801",
   "pgm_ref_txt": "EMBEDDED & HYBRID SYSTEMS(EHS)"
  },
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  },
  {
   "pgm_ref_code": "9216",
   "pgm_ref_txt": "ADVANCED SOFTWARE TECH & ALGOR"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112RB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 149999.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 99999.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 299996.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 269078.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>All widely used software abstractions lack temporal semantics. The notion of correct execution of a program written in every widely-used programming language today does not depend on the temporal behavior of the program. But temporal behavior matters in almost all systems. Even in systems with no particular real-time requirements, timing of programs is relevant to the value delivered by programs, and in the case of concurrent programs, also affects the functionality. In systems with real-time requirements, including most cyber-physical systems, temporal behavior affects not just the value delivered by a system but also its correctness.<br /><br />For concurrent software, which includes almost all interesting applications, the inability to directly control timing of software makes systems much more fragile. In particular, the behavior of a deployed system may differ considerably from the behavior of the system when being tested. Programmers are forced to use indirect methods such as setting priorities or deadlines, using synchronization primitives such as monitors and semaphores, and (often) delving into operating-system and hardware details to control interrupts and multitasking behavior. Such techniques are notoriously difficult to get right.<br /><br />Formal verification can help, but for many applications, verifying the software is not enough. We have to verify the system, which includes physical components that are not realized in software. Those physical components have temporal semantics, and the temporal behavior of the software directly impacts the overall system behavior. We cannot formally verify temporal behavior of software, however, if time is not part of the semantics of programs.<br /><br />To solve these problems, time can and must become part of the semantics of programs for a large class of applications. This NSF project has demonstrated that this is both practical and useful. The project has developed and evaluated three generations of PRET machines, where the PRET acronym stands for PREcision Timed; Predictable, REpeatable Timing; Performance with REpeatable Timing; and the French word for ``ready.'' All interpretations are valid and informative. PRET machines revise the concept of an instruction set architecture (ISA) to introduce temporal semantics. Programs written for a particular PRET ISA must meet certain timing requirements to be correctly executed. Timing becomes a correctness criterion, rather than a performance metric.<br /><br />Outcomes:<br /><br />This project started Feb. 1, 2008, ran for three years, and then received a two-year extension, for a total of five years. Over that time, the participants included, besides the three co-PIs, three visiting faculty, 10 grad students, and two postdocs.&nbsp; In addition, the project collaborated with Columbia University, University of Aukland (New Zealand), INRIA (Grenoble), National Instruments, Brigham Young University, Arizona State University, and Thales.<br /><br />The publications resulting from the project are listed at http://chess.eecs.berkeley.edu/pret/ and include 16 conference papers, one PhD thesis, 6 technical reports, and many presentations, including some invited keynote presentations.<br /><br />This project has established that it is possible to gain precise control over the timing of the actions of software without sacrificing performance. We believe that this work will lead to a generation of processors capable of precise and repeatable real-time behavior. These will be used in conjunction with general-purpose processors to provide time-sensitive services (such as high-performance networking and real-time media processing), and as processors for safety-critical and certification-intensive applications, such as automotive systems and aircraft control systems.<br /><br />Intellectual Merit:<br /><br />This project has addressed the core abstractions of computing, which th...",
  "por_txt_cntn": "\nAll widely used software abstractions lack temporal semantics. The notion of correct execution of a program written in every widely-used programming language today does not depend on the temporal behavior of the program. But temporal behavior matters in almost all systems. Even in systems with no particular real-time requirements, timing of programs is relevant to the value delivered by programs, and in the case of concurrent programs, also affects the functionality. In systems with real-time requirements, including most cyber-physical systems, temporal behavior affects not just the value delivered by a system but also its correctness.\n\nFor concurrent software, which includes almost all interesting applications, the inability to directly control timing of software makes systems much more fragile. In particular, the behavior of a deployed system may differ considerably from the behavior of the system when being tested. Programmers are forced to use indirect methods such as setting priorities or deadlines, using synchronization primitives such as monitors and semaphores, and (often) delving into operating-system and hardware details to control interrupts and multitasking behavior. Such techniques are notoriously difficult to get right.\n\nFormal verification can help, but for many applications, verifying the software is not enough. We have to verify the system, which includes physical components that are not realized in software. Those physical components have temporal semantics, and the temporal behavior of the software directly impacts the overall system behavior. We cannot formally verify temporal behavior of software, however, if time is not part of the semantics of programs.\n\nTo solve these problems, time can and must become part of the semantics of programs for a large class of applications. This NSF project has demonstrated that this is both practical and useful. The project has developed and evaluated three generations of PRET machines, where the PRET acronym stands for PREcision Timed; Predictable, REpeatable Timing; Performance with REpeatable Timing; and the French word for ``ready.'' All interpretations are valid and informative. PRET machines revise the concept of an instruction set architecture (ISA) to introduce temporal semantics. Programs written for a particular PRET ISA must meet certain timing requirements to be correctly executed. Timing becomes a correctness criterion, rather than a performance metric.\n\nOutcomes:\n\nThis project started Feb. 1, 2008, ran for three years, and then received a two-year extension, for a total of five years. Over that time, the participants included, besides the three co-PIs, three visiting faculty, 10 grad students, and two postdocs.  In addition, the project collaborated with Columbia University, University of Aukland (New Zealand), INRIA (Grenoble), National Instruments, Brigham Young University, Arizona State University, and Thales.\n\nThe publications resulting from the project are listed at http://chess.eecs.berkeley.edu/pret/ and include 16 conference papers, one PhD thesis, 6 technical reports, and many presentations, including some invited keynote presentations.\n\nThis project has established that it is possible to gain precise control over the timing of the actions of software without sacrificing performance. We believe that this work will lead to a generation of processors capable of precise and repeatable real-time behavior. These will be used in conjunction with general-purpose processors to provide time-sensitive services (such as high-performance networking and real-time media processing), and as processors for safety-critical and certification-intensive applications, such as automotive systems and aircraft control systems.\n\nIntellectual Merit:\n\nThis project has addressed the core abstractions of computing, which throughout the 20-th century, have deliberately abstracted away time. For embedded systems, this is inappropriate. Unlike most research in real-time systems, w..."
 }
}