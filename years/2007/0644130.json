{
 "awd_id": "0644130",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Hybrid Atomicity Checking",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "John Reppy",
 "awd_eff_date": "2007-04-15",
 "awd_exp_date": "2013-03-31",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 400000.0,
 "awd_min_amd_letter_date": "2007-04-13",
 "awd_max_amd_letter_date": "2011-04-06",
 "awd_abstract_narration": "The construction and validation of reliable multi-threaded programs is extremely difficult.  Threads can improve performance on multi-processor machines and multi-core processors by enabling a program to execute more than one routine simultaneously, but unintended interactions between threads are hard to recognize during testing and are a common source of errors in deployed systems.\r\n\r\nThis research develops hybrid checkers that prevent unintended thread interactions by ensuring that a program's routines are atomic.  A routine is atomic if its execution is not affected by and does not interfere with concurrently-executing threads.  Previous work on static atomicity checkers (that inspect source code) and dynamic atomicity checkers (that monitor running programs) demonstrate the potential advantages of enforcing atomicity requirements.  However, these approaches have precision or coverage limitations that reduce their ability to check large systems effectively.  Hybrid checkers synthesize the best aspects of both techniques without suffering from these limitations.\r\n\r\nThe impacts of hybrid atomicity checkers, and their integration into a broad educational program, include improved software quality and better software engineering practices.  Specifically, hybrid checkers provide a cost-effective mechanism for finding errors resistant to testing, are more usable and scalable than existing tools, and support a design methodology that encourages precisely specifying interactions between threads.\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Stephen",
   "pi_last_name": "Freund",
   "pi_mid_init": "N",
   "pi_sufx_name": "",
   "pi_full_name": "Stephen N Freund",
   "pi_email_addr": "freund@cs.williams.edu",
   "nsf_id": "000110974",
   "pi_start_date": "2007-04-13",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Williams College",
  "inst_street_address": "880 MAIN ST",
  "inst_street_address_2": "",
  "inst_city_name": "WILLIAMSTOWN",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "4135974352",
  "inst_zip_code": "012672600",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "MA01",
  "org_lgl_bus_name": "PRESIDENT & TRUSTEES OF WILLIAMS COLLEGE",
  "org_prnt_uei_num": "",
  "org_uei_num": "JVZEJJ6N5EM8"
 },
 "perf_inst": {
  "perf_inst_name": "Williams College",
  "perf_str_addr": "880 MAIN ST",
  "perf_city_name": "WILLIAMSTOWN",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "012672600",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "MA01",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 75414.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 98793.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 75925.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 73872.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 75996.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br />Computers now play a central role in virtually all parts of society,<br />and we rely on computing systems to correctly perform many tasks on<br />our behalf.&nbsp; At the same time, however, designing and implementing<br />reliable software systems remains perhaps the greatest challenge<br />facing the computing industry today.&nbsp; Despite great efforts to ensure<br />reliability, software errors still occur, sometimes with costly<br />consequences.&nbsp; Defects may be costly to find and fix, result in loss<br />of data, enable security breaches, and even endanger lives.<br /><br />The problem of ensuring software reliability has been made even more<br />challenging by the widespread adoption of multi-processor computers<br />and multi-core processors.&nbsp; These hardware architectures enable<br />programs to perform multiple tasks at the same time, and designing<br />software to have such multiple threads of control running concurrency<br />is widely believed to be the most promising way to achieve further<br />performance improvements for many computer systems.&nbsp; <br /><br />However, threads may interfere with each other in subtle ways if the<br />programmer does not properly coordinate (or synchronize) their<br />behavior.&nbsp; Errors caused by unanticipated thread interactions are<br />common but particularly difficult to discover during testing since<br />they typically happen only intermittently and are discovered only long<br />after the damaging interference actually occurs.<br /><br />In this grant, we examined automated software validation tools for<br />finding concurrency defects.&nbsp; Programmers can use such tools to<br />identify problems in software during development before they are<br />experienced by users.&nbsp; Automated checking tools have proven quite<br />useful at finding and eliminating other kinds of software defects, but<br />they have traditionally been difficult to use and ineffective for<br />finding synchronization defects in concurrent software.<br /><br />Our basic validation approach is to have programmers place \"atomic\"<br />specifications on regions of source code that should be free of<br />interference with all other threads.&nbsp; Those specifications, as well as<br />other specifications describing how threads are coordinated, are then<br />verified for correctness by an automated checker.&nbsp; If a code fragment<br />does not exhibit the specified property, a warning is reported to the<br />programmer.&nbsp; We focused on a synthesis of complementary analyses from<br />static checkers (that inspect source code) and dynamic checkers (that<br />monitor running programs) to enforce this type of requirement.&nbsp; This<br />hybrid approach scales better and increases precision over previous<br />work, as shown when we applied our techniques to validate a variety of<br />programs.<br /><br />The intellectual merit and scientific contributions of this work<br />include the development of techniques pushing forward the state of the<br />art on how to check for interference errors in concurrent programs.<br />The techniques studied are able to find concurrency defects ranging<br />from the most-basic type of conflict when two threads access a<br />specific memory location simultaneously without coordination to more<br />subtle atomicity or <span><span>serializability</span></span> problems that require enforcing<br />proper thread synchronization across much longer sequences of<br />operations.&nbsp; <br /><br />We have also built and now distribute an open source analysis<br />framework that serves as a test bed for new ideas in concurrency<br />analyses. This framework has already been used extensively by both us<br />and others.<br /><br />This work has contributed to computer science education in several<br />ways. Numerous undergraduate students were trained to perform<br />scientific research as part of this...",
  "por_txt_cntn": "\n\nComputers now play a central role in virtually all parts of society,\nand we rely on computing systems to correctly perform many tasks on\nour behalf.  At the same time, however, designing and implementing\nreliable software systems remains perhaps the greatest challenge\nfacing the computing industry today.  Despite great efforts to ensure\nreliability, software errors still occur, sometimes with costly\nconsequences.  Defects may be costly to find and fix, result in loss\nof data, enable security breaches, and even endanger lives.\n\nThe problem of ensuring software reliability has been made even more\nchallenging by the widespread adoption of multi-processor computers\nand multi-core processors.  These hardware architectures enable\nprograms to perform multiple tasks at the same time, and designing\nsoftware to have such multiple threads of control running concurrency\nis widely believed to be the most promising way to achieve further\nperformance improvements for many computer systems.  \n\nHowever, threads may interfere with each other in subtle ways if the\nprogrammer does not properly coordinate (or synchronize) their\nbehavior.  Errors caused by unanticipated thread interactions are\ncommon but particularly difficult to discover during testing since\nthey typically happen only intermittently and are discovered only long\nafter the damaging interference actually occurs.\n\nIn this grant, we examined automated software validation tools for\nfinding concurrency defects.  Programmers can use such tools to\nidentify problems in software during development before they are\nexperienced by users.  Automated checking tools have proven quite\nuseful at finding and eliminating other kinds of software defects, but\nthey have traditionally been difficult to use and ineffective for\nfinding synchronization defects in concurrent software.\n\nOur basic validation approach is to have programmers place \"atomic\"\nspecifications on regions of source code that should be free of\ninterference with all other threads.  Those specifications, as well as\nother specifications describing how threads are coordinated, are then\nverified for correctness by an automated checker.  If a code fragment\ndoes not exhibit the specified property, a warning is reported to the\nprogrammer.  We focused on a synthesis of complementary analyses from\nstatic checkers (that inspect source code) and dynamic checkers (that\nmonitor running programs) to enforce this type of requirement.  This\nhybrid approach scales better and increases precision over previous\nwork, as shown when we applied our techniques to validate a variety of\nprograms.\n\nThe intellectual merit and scientific contributions of this work\ninclude the development of techniques pushing forward the state of the\nart on how to check for interference errors in concurrent programs.\nThe techniques studied are able to find concurrency defects ranging\nfrom the most-basic type of conflict when two threads access a\nspecific memory location simultaneously without coordination to more\nsubtle atomicity or serializability problems that require enforcing\nproper thread synchronization across much longer sequences of\noperations.  \n\nWe have also built and now distribute an open source analysis\nframework that serves as a test bed for new ideas in concurrency\nanalyses. This framework has already been used extensively by both us\nand others.\n\nThis work has contributed to computer science education in several\nways. Numerous undergraduate students were trained to perform\nscientific research as part of this grant.  Four of these students are\nnow pursuing graduate degrees in computer science.  In addition, we\nhave participated in a number of curricular efforts to improve\ncomputer science education, particularly in the area of programming\nlanguages and concurrent programming.  As part of these efforts, we\ndeveloped several new models for an undergraduate curriculum in our\ndiscipline.  Those curricular ideas, as well as results from this\nresearch agenda, have been inte..."
 }
}