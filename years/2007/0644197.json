{
 "awd_id": "0644197",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Semantics and Hardware Implementation of Transactional Memory",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927498",
 "po_email": "achtchel@nsf.gov",
 "po_sign_block_name": "Almadena Chtchelkanova",
 "awd_eff_date": "2007-06-01",
 "awd_exp_date": "2013-05-31",
 "tot_intn_awd_amt": 320000.0,
 "awd_amount": 415800.0,
 "awd_min_amd_letter_date": "2007-03-26",
 "awd_max_amd_letter_date": "2011-05-05",
 "awd_abstract_narration": "After decades of research on shared-memory multiprocessors, computers with multiple processors have now been widely embraced with the arrival of the multicore revolution.  Unlike the previous microprocessor revolution---which required no fundamental software changes---the multicore revolution requires a significant shift for software.  Because much of the accustomed exponential performance improvements over the next decade will come directly from multiplying the number of processor cores on a chip, programmers that wish to harness this computational power must undertake the difficult task of creating parallel versions of their programs.\r\n\r\nTo reduce the difficulty of this task of creating correct and efficient shared-memory programs, recent work on \"transactional memory\" has focused on providing the programmer with a higher-level primitive than just lock- based critical sections for managing concurrency in their shared-memory programs: a region of code annotated to execute as if it was not running in parallel with other code.  Although conceptually serial, advanced implementations allow for concurrent execution while still providing a serializable semantics.\r\n\r\nThe goal of this research is to identify, understand, and resolve the most important semantic and implementation challenges of hardware-based transactional memory.  Just as the multiprocessor research successfully overcame important challenges, this research tackles the analogous challenges for hardware transactional memory: (i) understanding the semantics of the hardware/software interface, (ii) developing simple and fast hardware implementations, and (iii) creating critical experimental simulation and workload infrastructures.\r\n\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Milo",
   "pi_last_name": "Martin",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Milo Martin",
   "pi_email_addr": "milom@cis.upenn.edu",
   "nsf_id": "000383219",
   "pi_start_date": "2007-03-26",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Pennsylvania",
  "inst_street_address": "3451 WALNUT ST STE 440A",
  "inst_street_address_2": "",
  "inst_city_name": "PHILADELPHIA",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "2158987293",
  "inst_zip_code": "191046205",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "PA03",
  "org_lgl_bus_name": "TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE",
  "org_prnt_uei_num": "GM1XX56LEP58",
  "org_uei_num": "GM1XX56LEP58"
 },
 "perf_inst": {
  "perf_inst_name": "University of Pennsylvania",
  "perf_str_addr": "3451 WALNUT ST STE 440A",
  "perf_city_name": "PHILADELPHIA",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "191046205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "PA03",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "732900",
   "pgm_ele_name": "COMPILERS"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 160000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 15800.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 80000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Transactional memory is a ground-breaking approach for coordinating the operations of software running on multicore chips. This hardware-supported mechanism has the potential to ameliorate the traditional challenges of multicore programming that relies on conventional synchronization methods such as locks. &nbsp;Transactional memory systems allow programmers to specify regions of code, called transactions, the execution of which are logically serialized (that is, transactions are isolated from one another). &nbsp;Transactional memory systems optimistically execute transactions concurrently, yet the appearance of serialization is preserved because when two concurrent transactions share data (and at least one writes it), they are serialized by aborting, rolling back, and restarting one of them. &nbsp;The global serialization property gives transactions more powerful semantics than locks, affording programmers the simplicity of coarse-grained locks, while achieving the performance of fine-grained locks.</p>\n<p>Although the above advantages of transactional memory show tremendous potential, transactional memory faces many challenges. &nbsp;This project endeavored to address both immediate and longer term challenges. Specifically, the project focused on understanding various possible semantics and their implementation ramifications, discovering efficient and complexity-effective implementation techniques, developing the simulation and workload infrastructure necessary to evaluate transactional memory proposals, and identifying software restructurings and hardware mechanisms to avoid performance-sapping transactional conflicts.</p>\n<p>The project resulted in several advances in scientific understanding and research infrastructure. &nbsp;The project was the first to articulate the subtle semantics of transactional memory and identified the interaction of locks and transactions as an additional salient semantic barrier to the deployment of transactional memory. To improve and simplify the implementation of transactional memory, the project focused on extending the common-case implementation of transactional memory by proposing a \"permissions-only cache\". &nbsp;This cache can efficiently extend the size at which a transaction must overflow, decoupling that size from the size of the data cache. &nbsp;This technique allows a designer to engineer a system to make transactional overflow &nbsp;vanishingly rare. &nbsp;Making such overflows rare provides the opportunity to create simpler methods for handling overflows, one of which we developed and evaluated that also supports performing input/output operations within transactions. &nbsp;To address a potential performance limiter, the project developed techniques for mitigating the negative performance impact of true conflicts by using \"transactional repair\" techniques that use value-based conflict detection (rather than address-based detection), symbolic tracking of values, and recording of control flow constraints to avoid aborts via commit-time repair of transactions. &nbsp;Finally, we developed and publicly distributed the simulation tools developed in the course of this project, which have been subsequently used by other researchers in dozens of research papers.</p>\n<p>As part of the project's goal to integrate research and education, a new course on multicore programming was developed and a new \"bottom up\" introductory systems course specifically tailored to students without extensive prior computer knowledge was introduced into the curriculum. &nbsp;This award partially supported three undergraduate summer students and five different PhD students during various stages of their graduate training. &nbsp;The project's findings were broadly disseminated through publications and presentations on the work to both academic and industrial audiences. A PhD dissertation written by one of the supported students cohesively describes th...",
  "por_txt_cntn": "\nTransactional memory is a ground-breaking approach for coordinating the operations of software running on multicore chips. This hardware-supported mechanism has the potential to ameliorate the traditional challenges of multicore programming that relies on conventional synchronization methods such as locks.  Transactional memory systems allow programmers to specify regions of code, called transactions, the execution of which are logically serialized (that is, transactions are isolated from one another).  Transactional memory systems optimistically execute transactions concurrently, yet the appearance of serialization is preserved because when two concurrent transactions share data (and at least one writes it), they are serialized by aborting, rolling back, and restarting one of them.  The global serialization property gives transactions more powerful semantics than locks, affording programmers the simplicity of coarse-grained locks, while achieving the performance of fine-grained locks.\n\nAlthough the above advantages of transactional memory show tremendous potential, transactional memory faces many challenges.  This project endeavored to address both immediate and longer term challenges. Specifically, the project focused on understanding various possible semantics and their implementation ramifications, discovering efficient and complexity-effective implementation techniques, developing the simulation and workload infrastructure necessary to evaluate transactional memory proposals, and identifying software restructurings and hardware mechanisms to avoid performance-sapping transactional conflicts.\n\nThe project resulted in several advances in scientific understanding and research infrastructure.  The project was the first to articulate the subtle semantics of transactional memory and identified the interaction of locks and transactions as an additional salient semantic barrier to the deployment of transactional memory. To improve and simplify the implementation of transactional memory, the project focused on extending the common-case implementation of transactional memory by proposing a \"permissions-only cache\".  This cache can efficiently extend the size at which a transaction must overflow, decoupling that size from the size of the data cache.  This technique allows a designer to engineer a system to make transactional overflow  vanishingly rare.  Making such overflows rare provides the opportunity to create simpler methods for handling overflows, one of which we developed and evaluated that also supports performing input/output operations within transactions.  To address a potential performance limiter, the project developed techniques for mitigating the negative performance impact of true conflicts by using \"transactional repair\" techniques that use value-based conflict detection (rather than address-based detection), symbolic tracking of values, and recording of control flow constraints to avoid aborts via commit-time repair of transactions.  Finally, we developed and publicly distributed the simulation tools developed in the course of this project, which have been subsequently used by other researchers in dozens of research papers.\n\nAs part of the project's goal to integrate research and education, a new course on multicore programming was developed and a new \"bottom up\" introductory systems course specifically tailored to students without extensive prior computer knowledge was introduced into the curriculum.  This award partially supported three undergraduate summer students and five different PhD students during various stages of their graduate training.  The project's findings were broadly disseminated through publications and presentations on the work to both academic and industrial audiences. A PhD dissertation written by one of the supported students cohesively describes the core findings of this project.\n\nWhen this project began six years ago, transactional memory was a newly rediscovered academic idea, and it was ..."
 }
}