{
 "awd_id": "0702667",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Using Contracts to Support Development, Verification, and Maintenance of Multi-threaded Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2007-07-01",
 "awd_exp_date": "2012-06-30",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 430000.0,
 "awd_min_amd_letter_date": "2007-06-14",
 "awd_max_amd_letter_date": "2010-05-07",
 "awd_abstract_narration": "Stirewalt Abstract:\r\n\r\nA principal difficulty in the development of high-assurance software is to safely accommodate concurrency and synchronization.  The propensity for concurrency to engender state-explosion confounds verification, and the tendency for synchronization logic to be interleaved with \"functional\" code complicates understanding and maintenance.  Thus, development and long-term maintenance of high-assurance software requires design artifacts over which verification is feasible and processes that use these artifacts to maintain separation of concerns in the implementation.\r\n\r\nThis project aims to achieve these goals.  Specifically, it explores a design-for-verification (D4V) approach based on synchronization contracts, which provides the high level of abstraction needed to support verification while maintaining a good separation of synchronization and functional concerns.  We are developing programming systems that leverage contract awareness for analysis; to automate the generation of models from design artifacts, (e.g., UML diagrams); and to separate synchronization and functional concerns. We are conducting these explorations in the context of an existing software baseline.\r\n\r\nThe project also involves development of undergraduate courses in concurrent systems design, model-based software engineering, and D4V. One benchmark is the extent to which undergraduates are able to design and verify contract-aware programs using the tools and methods developed under this grant.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Kurt",
   "pi_last_name": "Stirewalt",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Kurt Stirewalt",
   "pi_email_addr": "stire@cse.msu.edu",
   "nsf_id": "000260086",
   "pi_start_date": "2007-06-14",
   "pi_end_date": "2010-01-27"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Laura",
   "pi_last_name": "Dillon",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Laura Dillon",
   "pi_email_addr": "ldillon@cse.msu.edu",
   "nsf_id": "000698384",
   "pi_start_date": "2010-05-07",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Laura",
   "pi_last_name": "Dillon",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Laura Dillon",
   "pi_email_addr": "ldillon@cse.msu.edu",
   "nsf_id": "000698384",
   "pi_start_date": "2007-06-14",
   "pi_end_date": "2010-01-27"
  }
 ],
 "inst": {
  "inst_name": "Michigan State University",
  "inst_street_address": "426 AUDITORIUM RD RM 2",
  "inst_street_address_2": "",
  "inst_city_name": "EAST LANSING",
  "inst_state_code": "MI",
  "inst_state_name": "Michigan",
  "inst_phone_num": "5173555040",
  "inst_zip_code": "488242600",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MI07",
  "org_lgl_bus_name": "MICHIGAN STATE UNIVERSITY",
  "org_prnt_uei_num": "VJKZC4D1JN36",
  "org_uei_num": "R28EKN92ZTZ9"
 },
 "perf_inst": {
  "perf_inst_name": "Michigan State University",
  "perf_str_addr": "426 AUDITORIUM RD RM 2",
  "perf_city_name": "EAST LANSING",
  "perf_st_code": "MI",
  "perf_st_name": "Michigan",
  "perf_zip_code": "488242600",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MI07",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "app-0107",
   "fund_name": "",
   "fund_symb_id": ""
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 135000.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 265000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 30000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The expressive power and performance gains promised by multi-threaded software comes at the expense of increased complexity. Without proper synchronization, multiple threads may concurrently access the same shared object, producing a race condition, and incorrect synchronization logic can lead to starvation and/or deadlock. Moreover, because synchronization policies and decisions are difficult to localize within software modules, concurrency confounds the development of reusable software. &nbsp;</p>\n<p><br />This project developed a model of synchronization contracts for object-oriented languages that addresses this complexity, and validated benefits of this model. Called the Synchronization Units Model (Szumo), the model's key benefits are increased design transparency, separation of synchronization code from functional code, and enhanced extensibility and maintenance. &nbsp;Separating synchronization code from functional code simplifies programming, and localizing synchronization contracts in module interfaces simplifies reasoning about synchronization errors.&nbsp;</p>\n<p><br />In this project, we demonstrated that, although the full Szumo negotiation algorithm does not scale well under high contention when compared with hand-optimized solutions, a restricted version of this algorithm reduces contention when compared to two common synchronization policies. &nbsp;This restricted algorithm is well suited to the IP telecommunication services domain. &nbsp;We used it to demonstrate that performance of contract-based automatic synchronization could be very close to that of an optimized manually synchronized implementation of an IP telecommunications service.</p>\n<p><br />Our paper on synchronization issues for IP telecommunications services was circulated to the expert group for SIP Servlet API, the current industry standard for deployment of Voice Over IP (VoIP) service, when it was actively debating a specification for a threading model for the standard. Due to our findings, the expert group decided that JSR 289 should not mandate any particular threading model (JSR 289, Section 6.4.2). Thus, our work influenced the standards body to not adopt a flawed threading model.</p>\n<p><br />In addition, empirical studies performed in this project have contributed to the body of understanding in program comprehension and software maintenance. To our knowledge, our work is the first to explore the effects of concurrency on these key software-development activities.</p>\n<p><br />Finally, our work on the use of finite-state verification to assist in the design and evaluation of user studies involving computing processes and artifacts (i.e., development methods and notations) and our development of on-line tutorials to assist in training participants prior to such studies contributes to helping make these studies more objective and to prevent erroneous or ambiguous materials from being used in these very expensive studies. This may, in the long term, help the field to reduce the effort required to run these studies and thus help bring about a greater body of empirical knowledge in software engineering.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/30/2012<br>\n\t\t\t\t\tModified by: Laura&nbsp;K&nbsp;Dillon</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe expressive power and performance gains promised by multi-threaded software comes at the expense of increased complexity. Without proper synchronization, multiple threads may concurrently access the same shared object, producing a race condition, and incorrect synchronization logic can lead to starvation and/or deadlock. Moreover, because synchronization policies and decisions are difficult to localize within software modules, concurrency confounds the development of reusable software.  \n\n\nThis project developed a model of synchronization contracts for object-oriented languages that addresses this complexity, and validated benefits of this model. Called the Synchronization Units Model (Szumo), the model's key benefits are increased design transparency, separation of synchronization code from functional code, and enhanced extensibility and maintenance.  Separating synchronization code from functional code simplifies programming, and localizing synchronization contracts in module interfaces simplifies reasoning about synchronization errors. \n\n\nIn this project, we demonstrated that, although the full Szumo negotiation algorithm does not scale well under high contention when compared with hand-optimized solutions, a restricted version of this algorithm reduces contention when compared to two common synchronization policies.  This restricted algorithm is well suited to the IP telecommunication services domain.  We used it to demonstrate that performance of contract-based automatic synchronization could be very close to that of an optimized manually synchronized implementation of an IP telecommunications service.\n\n\nOur paper on synchronization issues for IP telecommunications services was circulated to the expert group for SIP Servlet API, the current industry standard for deployment of Voice Over IP (VoIP) service, when it was actively debating a specification for a threading model for the standard. Due to our findings, the expert group decided that JSR 289 should not mandate any particular threading model (JSR 289, Section 6.4.2). Thus, our work influenced the standards body to not adopt a flawed threading model.\n\n\nIn addition, empirical studies performed in this project have contributed to the body of understanding in program comprehension and software maintenance. To our knowledge, our work is the first to explore the effects of concurrency on these key software-development activities.\n\n\nFinally, our work on the use of finite-state verification to assist in the design and evaluation of user studies involving computing processes and artifacts (i.e., development methods and notations) and our development of on-line tutorials to assist in training participants prior to such studies contributes to helping make these studies more objective and to prevent erroneous or ambiguous materials from being used in these very expensive studies. This may, in the long term, help the field to reduce the effort required to run these studies and thus help bring about a greater body of empirical knowledge in software engineering.\n\n\t\t\t\t\tLast Modified: 07/30/2012\n\n\t\t\t\t\tSubmitted by: Laura K Dillon"
 }
}