{
 "awd_id": "0709254",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Collaborative Research: CRI: IAD: Development of a Research Infrastructure for the Multithreaded Computing Community Using the Cray Eldorado Platform",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Rita Rodriguez",
 "awd_eff_date": "2007-08-01",
 "awd_exp_date": "2013-07-31",
 "tot_intn_awd_amt": 55000.0,
 "awd_amount": 45000.0,
 "awd_min_amd_letter_date": "2007-08-16",
 "awd_max_amd_letter_date": "2012-07-23",
 "awd_abstract_narration": "Abstract \r\nProposal #: CNS 07-09140 07-08307 07-08820 \r\nPI(s): Brockman, Jay B. Bader, David A. Gao, Guang R. \r\nBarabasi,Albert-Laszlo;Chawla,Nitesh;Kogge,PeterM. Vetter, Jeffrey S. \r\nInstitution: University of Notre Dame Georgia Institute Tech U.Delaware \r\nNotre Dame, IN 46556-5602 Atlanta, GA 30332-0002 Newark, DE 19716-1551 \r\nProposal #: CNS 07-09385 07-09111 07-09254 \r\nPI(s): Gilbert, John R. Upchurch, Edwin T. Yelick, Katherine A. \r\nWolski, Richard. \r\nInstitution: UC-Santa Barbara California Inst Tech UC-Berkeley \r\nSanta Barbara, CA 93106-2050 Pasadena, CA 91125-0600 Berkeley, CA 94704-5940 \r\nTitle: Colla Rsch:IAD:Dev Rsch Infr. for Multithreaded Computing Community Using Cray Eldorado Platform \r\n\r\nProject Proposed: \r\n\r\nThis collaborative project, developing a shared infrastructure needed to broaden its impact for developing software to run on the next generation of computer hardware, brings a diverse group of researchers from six universities in a joint effort. The work responds to the trend towards multicore processors where developers envision placing tens to hundreds of cores on a single die, each running multiple threads (in contrast to the currently dominant message-passing architectures resulting from the advent of MPI and Linux clusters). Three objectives are proposed: \r\n. Acquiring computer hardware as a shared community resource capable of efficiently running, in experimental and production modes, complex programs with thousands of threads in shared memory; \r\n. Assembling software infrastructure for developing and measuring performance of programs running on the hardware; and \r\n. Building stronger ties between the people themselves, creating ways for researchers at the partner institutions to collaborate and communicate their findings to the broader community. \r\nThe Cray XMT system, scheduled for delivery in 2007 serves as an ideal platform. The second bullet includes algorithms, data sets, libraries, languages, tools, and simulators to evaluate performance of program running on the hardware focusing on applications that benefit from large numbers of threats, massively data intensive, \"\"sparse-graph\"\" problems that are difficult to parallelize using conventional message-passing on clusters. Each university contributes a piece to the infrastructure, using it for support of projects. Sandia National Laboratories has agreed to host the system and provide supplementary funding. Each university will use the Cray XMT system in courses. \r\n\r\nBroader Impacts: The infrastructure measures performance providing a basis for the community to improve sharin, and build strong ties for collaboration and communication. Courses will be created and materials will be made available. Workshops for dissemination of the findings are also planned. \r\n \r\n \r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Katherine",
   "pi_last_name": "Yelick",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Katherine A Yelick",
   "pi_email_addr": "yelick@cs.berkeley.edu",
   "nsf_id": "000388740",
   "pi_start_date": "2007-08-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Berkeley",
  "inst_street_address": "1608 4TH ST STE 201",
  "inst_street_address_2": "",
  "inst_city_name": "BERKELEY",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "5106433891",
  "inst_zip_code": "947101749",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "CA12",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE",
  "org_prnt_uei_num": "",
  "org_uei_num": "GS3YEVSS12N6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Berkeley",
  "perf_str_addr": "1608 4TH ST STE 201",
  "perf_city_name": "BERKELEY",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "947101749",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "CA12",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735900",
   "pgm_ele_name": "CCRI-CISE Cmnty Rsrch Infrstrc"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0107",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "490100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "0100999999",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2007,
   "fund_oblg_amt": 5000.0
  },
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 5000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 5000.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 30000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of this project was to explore the use of <em>multithreading</em> in high performance parallel computing, where multiple threads per processor are used to mask the latency of remote accesses by running a separate thread while the remote operation completes. &nbsp; The Eldorado architecture supports this model at the hardware level, with low overhead thread creating and automatic context switching. &nbsp;The Berkeley team was exploring a particular type of programming known as Partitioned Global Address Space (PGAS) programming and how it can be used on both hardware and software implementations of multithreading. &nbsp; In collaboration with researchers at Lawrence Berkeley National Laboratory, the team explored dynamic load balancing tools for the UPC language and the use of over-provisioning processors (scheduling more than one thread per core) to hide latency on both distributed and shared memory machines. We also developed hierarchical versions of the PGAS languages to support both the hierarchical nature of future &nbsp;systems and the hierarchical parallelism that exists in some applications.&nbsp;</p>\n<p>The group performed several experiments to better understand the best type of threading mechanims to use on shared memory hardware, including both multicore or multichip shared memory nodes. The first version uses POSIX threads with shared memory for the runtime: this requires an explicit representation of thread-local data, e.g., variables that are local to a thread need to have a copy per processors, even if they are globally scoped, but such variables only have a single shared instance in the POSIX model. The second version uses processes rather than threads, and then adds some form of explicitly allocated shared memory, which is specific to the underlying operating system. In general, the thread version is more portable, but the process version offer better interoperability for message passing (MPI) programs that use a process per core. &nbsp;While threads are generally a lighter weight mechanism than processes, the process implementation often showed better performance than the threaded version. &nbsp;This performance effect was mostly attributable to the differences in synchronization required to access shared resources, such as a network interface: the process version has a higher message injection rate because the locking is handled at a lower level. &nbsp;In addition, processes may have better locality behavior within a shared memory node because they are treated differently by a scheduler and not moved as frequently as threads. &nbsp;This latter effect can be mitigated in the thread version by explicitly pinning threads to cores. &nbsp; Finally, the results show that a particuar form of limited multithreading called overprovisinging, namely running more than one thread per core, shows some of the same performance benefits of the multithreaded hardware.&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/27/2014<br>\n\t\t\t\t\tModified by: Katherine&nbsp;A&nbsp;Yelick</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe goal of this project was to explore the use of multithreading in high performance parallel computing, where multiple threads per processor are used to mask the latency of remote accesses by running a separate thread while the remote operation completes.   The Eldorado architecture supports this model at the hardware level, with low overhead thread creating and automatic context switching.  The Berkeley team was exploring a particular type of programming known as Partitioned Global Address Space (PGAS) programming and how it can be used on both hardware and software implementations of multithreading.   In collaboration with researchers at Lawrence Berkeley National Laboratory, the team explored dynamic load balancing tools for the UPC language and the use of over-provisioning processors (scheduling more than one thread per core) to hide latency on both distributed and shared memory machines. We also developed hierarchical versions of the PGAS languages to support both the hierarchical nature of future  systems and the hierarchical parallelism that exists in some applications. \n\nThe group performed several experiments to better understand the best type of threading mechanims to use on shared memory hardware, including both multicore or multichip shared memory nodes. The first version uses POSIX threads with shared memory for the runtime: this requires an explicit representation of thread-local data, e.g., variables that are local to a thread need to have a copy per processors, even if they are globally scoped, but such variables only have a single shared instance in the POSIX model. The second version uses processes rather than threads, and then adds some form of explicitly allocated shared memory, which is specific to the underlying operating system. In general, the thread version is more portable, but the process version offer better interoperability for message passing (MPI) programs that use a process per core.  While threads are generally a lighter weight mechanism than processes, the process implementation often showed better performance than the threaded version.  This performance effect was mostly attributable to the differences in synchronization required to access shared resources, such as a network interface: the process version has a higher message injection rate because the locking is handled at a lower level.  In addition, processes may have better locality behavior within a shared memory node because they are treated differently by a scheduler and not moved as frequently as threads.  This latter effect can be mitigated in the thread version by explicitly pinning threads to cores.   Finally, the results show that a particuar form of limited multithreading called overprovisinging, namely running more than one thread per core, shows some of the same performance benefits of the multithreaded hardware. \n\n \n\n\t\t\t\t\tLast Modified: 04/27/2014\n\n\t\t\t\t\tSubmitted by: Katherine A Yelick"
 }
}