{
 "awd_id": "0834323",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Collaborative Research:    CSR-PSCE, SM:   Adaptive Memory Management in Shared Environments",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Krishna Kant",
 "awd_eff_date": "2008-09-01",
 "awd_exp_date": "2012-08-31",
 "tot_intn_awd_amt": 118657.0,
 "awd_amount": 134657.0,
 "awd_min_amd_letter_date": "2008-08-19",
 "awd_max_amd_letter_date": "2010-06-24",
 "awd_abstract_narration": "Program performance is highly dependent on the amount of memory available to the\r\nprogram. In traditional computing systems, the memory working set of an application\r\nhas a bounded size - providing more memory to an application improves performance\r\nuntil its working set is met. Once the working set is met, additional memory yields little\r\nor no benefit. However, in the presence of garbage collection (a technique for memory\r\nmanagement where space that is unlikely to be reused by an application is\r\nautomatically reclaimed), the relationship between program performance and memory\r\nallocation is more complex. Data is managed at three levels: the compiler manages\r\ndata objects at the program level, the garbage collector manages the heap at the virtual\r\nmachine level, and the virtual memory manager manages virtual memory at the\r\noperating system level. The middle layer plays a critical role. Increasing an application's\r\nheap size can reduce the frequency of garbage collections and improve performance,\r\nbut too large a heap may trigger paging and degrade performance.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Matthew",
   "pi_last_name": "Hertz",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Matthew A Hertz",
   "pi_email_addr": "mhertz@buffalo.edu",
   "nsf_id": "000228258",
   "pi_start_date": "2008-08-19",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "CANISIUS UNIVERSITY OF BUFFALO NEW YORK",
  "inst_street_address": "2001 MAIN ST",
  "inst_street_address_2": "",
  "inst_city_name": "BUFFALO",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "7168882103",
  "inst_zip_code": "142081035",
  "inst_country_name": "United States",
  "cong_dist_code": "26",
  "st_cong_dist_code": "NY26",
  "org_lgl_bus_name": "CANISIUS UNIVERSITY OF BUFFALO NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "JJWLQMLKBB85"
 },
 "perf_inst": {
  "perf_inst_name": "CANISIUS UNIVERSITY OF BUFFALO NEW YORK",
  "perf_str_addr": "2001 MAIN ST",
  "perf_city_name": "BUFFALO",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "142081035",
  "perf_ctry_code": "US",
  "perf_cong_dist": "26",
  "perf_st_cong_dist": "NY26",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9216",
   "pgm_ref_txt": "ADVANCED SOFTWARE TECH & ALGOR"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 76930.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 41727.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Program performance is highly dependent on the amount of memory available to the program. While this is true for all programs, it is especially true for programs using garbage collection.&nbsp; Garbage collection (or, less formally, \"dynamic memory management\") improves program security and programmer productivity by automating several common, error-prone memory requirements.&nbsp; This improvement comes at a cost of dramatically increasing the program's overall memory demands and, in particular, the amount of memory it uses on a regular basis (its \"working set\").&nbsp; When the computer does not have enough free RAM to meet these demands, the performance of garbage collected applications plummets and quickly becomes unusable.&nbsp; While past projects had looked at improving this performance for single programs running on dedicated machines, this project developed techniques that work in the multi-programmed environments that are really used today.</p>\n<p>This process is complicated by the fact that the relationship between program performance and memory allocation is complex. Data is managed at three levels: the compiler manages data objects at the program level, the garbage collector manages the heap at the virtual machine level, and the virtual memory manager manages virtual memory at the operating system level. Our approach, which we named Poor Richard's Memory Manager, was based off the maxim \"a penny saved is a penny earned.\"&nbsp; It targets that crucial middle level, but does so in a way that is independent of the actual garbage collector.&nbsp; By making our changes small and portable, we can save the performance optimizations that already exist within existing systems. We then used a collaborative approach in which processes work from a common \"whiteboard\" to make system-wide decisions and insure that they fully utilize memory.&nbsp; The result of these decisions was an algorithm that could be easily added to any garbage collection system (it required under 100 lines of code within the actual GC) and works within any operating system. Our results showed that it improved the performance of every garbage collector on which we tried and could scale from simple single processor systems all the way up to multiprocessor, multicore workstations.&nbsp; This should greatly improve the performance of garbage collection on all these machines and make it easier to gain the program safety and improved productivity these languages provide.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2012<br>\n\t\t\t\t\tModified by: Matthew&nbsp;A&nbsp;Hertz</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nProgram performance is highly dependent on the amount of memory available to the program. While this is true for all programs, it is especially true for programs using garbage collection.  Garbage collection (or, less formally, \"dynamic memory management\") improves program security and programmer productivity by automating several common, error-prone memory requirements.  This improvement comes at a cost of dramatically increasing the program's overall memory demands and, in particular, the amount of memory it uses on a regular basis (its \"working set\").  When the computer does not have enough free RAM to meet these demands, the performance of garbage collected applications plummets and quickly becomes unusable.  While past projects had looked at improving this performance for single programs running on dedicated machines, this project developed techniques that work in the multi-programmed environments that are really used today.\n\nThis process is complicated by the fact that the relationship between program performance and memory allocation is complex. Data is managed at three levels: the compiler manages data objects at the program level, the garbage collector manages the heap at the virtual machine level, and the virtual memory manager manages virtual memory at the operating system level. Our approach, which we named Poor Richard's Memory Manager, was based off the maxim \"a penny saved is a penny earned.\"  It targets that crucial middle level, but does so in a way that is independent of the actual garbage collector.  By making our changes small and portable, we can save the performance optimizations that already exist within existing systems. We then used a collaborative approach in which processes work from a common \"whiteboard\" to make system-wide decisions and insure that they fully utilize memory.  The result of these decisions was an algorithm that could be easily added to any garbage collection system (it required under 100 lines of code within the actual GC) and works within any operating system. Our results showed that it improved the performance of every garbage collector on which we tried and could scale from simple single processor systems all the way up to multiprocessor, multicore workstations.  This should greatly improve the performance of garbage collection on all these machines and make it easier to gain the program safety and improved productivity these languages provide.\n\n\t\t\t\t\tLast Modified: 11/30/2012\n\n\t\t\t\t\tSubmitted by: Matthew A Hertz"
 }
}