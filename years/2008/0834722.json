{
 "awd_id": "0834722",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CSR-PSCE, TM:   A Declarative Approach to Managing the Complexity of Massively Parallel Programs",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2008-09-01",
 "awd_exp_date": "2013-08-31",
 "tot_intn_awd_amt": 850000.0,
 "awd_amount": 865125.0,
 "awd_min_amd_letter_date": "2008-08-12",
 "awd_max_amd_letter_date": "2011-07-28",
 "awd_abstract_narration": "Parallel programs are typically written using a style in which independent processes are expressed sequentially and use locally-expressed message passing as a means of data exchange as well as a means of inter-process synchronization. From the network relationships that are implied by messaging among processes arise implicit data structures and implicit algorithms - that is, global parallel data structures and global parallel algorithms for which there is no explicit global representation. Limited only to a local approach for creating parallel programs, achieving correctness and performance of large-scale parallel algorithms is rapidly moving beyond our reasoning abilities. To address this shortcoming, this project develops a declarative language approach for describing new high-level communication operations, a means for composing these operations with computations, and a means for expressing transformations for optimizing the resulting compositions.\r\n\r\nThis project's implementation plan is based on aggressive evolution of the technology that is currently most effective in large-scale parallel computing - namely, explicitly managed shared data. In the distributed-memory case this is achieved with message passing, but the same discipline can be applied in the shared memory case as well. This project's approach may enable higher levels of expressiveness and abstraction for data management, communication, and coordination. Moreover, the separation of concerns that is naturally imposed between communication and computation greatly simplifies the mental model and implementation effort for programmers. In order not to sacrifice performance because of this division, this scheme's composition and transformation mechanisms will allow communication and computation to be (automatically) combined in an optimized fashion so that high performance and high scalability are achieved. To facilitate adoption by practicing programmers of the paradigms and tools that are developed, integration with education is essential. Accordingly, this project will directly train undergraduate, graduate, and post-doctoral researchers and will develop supporting curricula and materials to train both students and practicing programmers. Close collaboration with large-scale real-world scientific applications will further increase the practical relevance of this work.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Andrew",
   "pi_last_name": "Lumsdaine",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Andrew Lumsdaine",
   "pi_email_addr": "al75@uw.edu",
   "nsf_id": "000420340",
   "pi_start_date": "2008-08-12",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Arun",
   "pi_last_name": "Chauhan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Arun Chauhan",
   "pi_email_addr": "achauhan@cs.indiana.edu",
   "nsf_id": "000491849",
   "pi_start_date": "2008-08-12",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Indiana University",
  "inst_street_address": "107 S INDIANA AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BLOOMINGTON",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "3172783473",
  "inst_zip_code": "474057000",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "IN09",
  "org_lgl_bus_name": "TRUSTEES OF INDIANA UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "YH86RTW2YVJ4"
 },
 "perf_inst": {
  "perf_inst_name": "Indiana University",
  "perf_str_addr": "107 S INDIANA AVE",
  "perf_city_name": "BLOOMINGTON",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "474057000",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "IN09",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7354",
   "pgm_ref_txt": "COMPUTER SYSTEMS"
  },
  {
   "pgm_ref_code": "7902",
   "pgm_ref_txt": "PSCE"
  },
  {
   "pgm_ref_code": "9178",
   "pgm_ref_txt": "UNDERGRADUATE EDUCATION"
  },
  {
   "pgm_ref_code": "9216",
   "pgm_ref_txt": "ADVANCED SOFTWARE TECH & ALGOR"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 150000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 430000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 285125.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Many successful and important applications have been written based on the combination of &nbsp;the single program multiple data (SPMD) style using the message passing interface (MPI) for communication. However, even from its early days, MPI was intended to be a transition technology that would enable yet more effective parallel programming approaches. Today it is widely recognized that message passing as it is carried out today with MPI is too low-level, too complicated, and not well matched to shared-memory programming, nor to fine-grained highly-asynchronous execution models. Inevitable advances in high-performance computing systems have only exacerbated these shortcomings.</p>\n<p>To better understand these shortcomings, we started by analyzing communication patterns that are common in parallel applications. We found that many applications use a bulk-synchronous parallel model, in which programs are divided into supersteps, each consisting of separated computation and communication phases (often with explicit or implicit synchronization). Furthermore, we found that dynamic and sparse communication patterns are important in newer applications such as graph analysis. That is, communication patterns change over time based on the program&rsquo;s input data, and each processor communicates with a small number of other processors. Finally, hardware trends are showing an increased reliance on special purpose computation accelerators.</p>\n<p>These observations informed the development of two new programming languages: Kanor for managing the communication in large scale distributed systems, and Harlan for managing the interaction between the main processor and accelerator in hybrid computers.</p>\n<p>Kanor provides a declarative language for specifying communication patterns in parallel programs. Kanor&rsquo;s lightweight syntax allows programmers to compactly specify what data needs to move where, but the details of how best to execute the transfer is left to Kanor. This creates a clean separation between the communication and computation code which captures the essence of the communication without specify irrelevant details. This in turn gives the implementation more freedom to optimize the communication code, such as by overlapping communication with computation or by taking better advantage of intra-node shared memory.</p>\n<p>High performance computing is showing increased use of special purpose accelerators. One driving force behind this trend is the concern over energy efficiency. Often, a special purpose processor can perform better and use far less energy than a general purpose processor. Yet, these hybrid systems bring their own programming challenges. To alleviate these, we have designed and implemented Harlan, a language for high level programming of accelerators. Similarly to Kanor, Harlan provides lightweight syntax for indicating which portions of the program should run on the host processor and which portions should run on the accelerator, again providing a clean separation. This in turn implicitly specifies when data needs to be accessible to each processor, and Harlan uses this to automatically manage the communication between the host processor and the accelerator. Harlan allows developers to quickly write applications targeting accelerators with far less effort than existing approaches.</p>\n<p>In addition to the technical products of this project, we have trained numerous Ph.D. students and postdocs for careers in computer science research. Our results have been published in traditional academic venues (conferences and journals).&nbsp; In addition, both the technology press and special purpose industry publications have covered our language work.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/03/2013<br>\n\t\t\t\t\tModified by: Andrew&nbsp;Lumsdaine</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nMany successful and important applications have been written based on the combination of  the single program multiple data (SPMD) style using the message passing interface (MPI) for communication. However, even from its early days, MPI was intended to be a transition technology that would enable yet more effective parallel programming approaches. Today it is widely recognized that message passing as it is carried out today with MPI is too low-level, too complicated, and not well matched to shared-memory programming, nor to fine-grained highly-asynchronous execution models. Inevitable advances in high-performance computing systems have only exacerbated these shortcomings.\n\nTo better understand these shortcomings, we started by analyzing communication patterns that are common in parallel applications. We found that many applications use a bulk-synchronous parallel model, in which programs are divided into supersteps, each consisting of separated computation and communication phases (often with explicit or implicit synchronization). Furthermore, we found that dynamic and sparse communication patterns are important in newer applications such as graph analysis. That is, communication patterns change over time based on the program\u00c6s input data, and each processor communicates with a small number of other processors. Finally, hardware trends are showing an increased reliance on special purpose computation accelerators.\n\nThese observations informed the development of two new programming languages: Kanor for managing the communication in large scale distributed systems, and Harlan for managing the interaction between the main processor and accelerator in hybrid computers.\n\nKanor provides a declarative language for specifying communication patterns in parallel programs. Kanor\u00c6s lightweight syntax allows programmers to compactly specify what data needs to move where, but the details of how best to execute the transfer is left to Kanor. This creates a clean separation between the communication and computation code which captures the essence of the communication without specify irrelevant details. This in turn gives the implementation more freedom to optimize the communication code, such as by overlapping communication with computation or by taking better advantage of intra-node shared memory.\n\nHigh performance computing is showing increased use of special purpose accelerators. One driving force behind this trend is the concern over energy efficiency. Often, a special purpose processor can perform better and use far less energy than a general purpose processor. Yet, these hybrid systems bring their own programming challenges. To alleviate these, we have designed and implemented Harlan, a language for high level programming of accelerators. Similarly to Kanor, Harlan provides lightweight syntax for indicating which portions of the program should run on the host processor and which portions should run on the accelerator, again providing a clean separation. This in turn implicitly specifies when data needs to be accessible to each processor, and Harlan uses this to automatically manage the communication between the host processor and the accelerator. Harlan allows developers to quickly write applications targeting accelerators with far less effort than existing approaches.\n\nIn addition to the technical products of this project, we have trained numerous Ph.D. students and postdocs for careers in computer science research. Our results have been published in traditional academic venues (conferences and journals).  In addition, both the technology press and special purpose industry publications have covered our language work.\n\n\t\t\t\t\tLast Modified: 12/03/2013\n\n\t\t\t\t\tSubmitted by: Andrew Lumsdaine"
 }
}