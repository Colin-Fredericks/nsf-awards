{
 "awd_id": "0810053",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Advanced Methods for Performing Static Analysis of Machine Code",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "John Reppy",
 "awd_eff_date": "2008-08-01",
 "awd_exp_date": "2012-07-31",
 "tot_intn_awd_amt": 299999.0,
 "awd_amount": 299999.0,
 "awd_min_amd_letter_date": "2008-07-22",
 "awd_max_amd_letter_date": "2010-06-21",
 "awd_abstract_narration": "\r\nThe goal of the proposed project is to help programmers create\r\ncorrect, efficient, reliable, and secure software systems by providing\r\nimproved static-analysis techniques that can (i) verify properties of\r\na program's behavior, and (ii) find potential bugs and security\r\nvulnerabilities in programs.  The project will concentrate on the\r\nanalysis of machine code: the objectives are to enhance the scientific\r\nbasis for static analysis of machine code, to create prototype tools\r\nthat apply the techniques developed in tools for analyzing safety\r\nproperties of machine-code programs, and to measure how well the tools\r\nperform.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Thomas",
   "pi_last_name": "Reps",
   "pi_mid_init": "W",
   "pi_sufx_name": "",
   "pi_full_name": "Thomas W Reps",
   "pi_email_addr": "reps@cs.wisc.edu",
   "nsf_id": "000134593",
   "pi_start_date": "2008-07-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Wisconsin-Madison",
  "inst_street_address": "21 N PARK ST STE 6301",
  "inst_street_address_2": "",
  "inst_city_name": "MADISON",
  "inst_state_code": "WI",
  "inst_state_name": "Wisconsin",
  "inst_phone_num": "6082623822",
  "inst_zip_code": "537151218",
  "inst_country_name": "United States",
  "cong_dist_code": "02",
  "st_cong_dist_code": "WI02",
  "org_lgl_bus_name": "UNIVERSITY OF WISCONSIN SYSTEM",
  "org_prnt_uei_num": "",
  "org_uei_num": "LCLSJAGTNZQ7"
 },
 "perf_inst": {
  "perf_inst_name": "University of Wisconsin-Madison",
  "perf_str_addr": "21 N PARK ST STE 6301",
  "perf_city_name": "MADISON",
  "perf_st_code": "WI",
  "perf_st_name": "Wisconsin",
  "perf_zip_code": "537151218",
  "perf_ctry_code": "US",
  "perf_cong_dist": "02",
  "perf_st_cong_dist": "WI02",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 199999.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 100000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This grant supported research in the&nbsp;field of program analysis, with the aim of helping programmers create correct, efficient, reliable, and secure software systems. In particular, the research carried out under the grant focused on the difficult and important problem of analyzing stripped machine code (i.e., neither source code nor symbol-table/debugging information is available to help the analyzer).The number of articles during the last several years about security issues---both in the popular press and in the research literature---are one measure of the importance of machine-code analysis.</p>\n<p>The applications of the work include verification that machine-code programs operate as desired, and the identification of bugs and security vulnerabilities at the machine-code level, via combinations of static analysis, dynamic analysis, and symbolic execution.</p>\n<p>During the course of the project, the main activities have been as follows:</p>\n<p>1. Development of a system, called TSL (for Transformer Specification Language), that makes it easier to implement analyses for machine code. TSL provides a platform for specifying the semantics of machine-code instruction sets and generating dynamic, symbolic, and static analyses from the semantic specification.</p>\n<p>2. Exploration of how TSL could be used to create implementations of the basic primitives used in symbolic program analysis: forward symbolic evaluation, pre-image computation, and symbolic composition.</p>\n<p>3. Exploration of how TSL could be used to specify the transition function for cache memory.</p>\n<p>4. The use of TSL to develop a tool, called BCE (Botnet Command Extractor), for automatically extracting botnet-command information from bot executables.</p>\n<p>5. The use of TSL to develop a tool, called McVeto (Machine Code VErification Tool), which uses both dynamic analysis and symbolic analysis to determine whether a certain program point of interest is reachable.</p>\n<p>6. Several investigations of fundamental issues that arise in program analyzers.&nbsp; Static-analysis techniques explore the program's behavior for all possible inputs.&nbsp; The technical challenge that one faces is ``How can one obtain information about the possible states that a program reaches during execution, but without actually running the program on specific inputs?'' To make this feasible, the program is run ``in the aggregate'' -- i.e., on descriptors that represent collections of many states.&nbsp; One of the lines of investigation concerned the development of families of descriptors suitable for use with bit-vector arithmetic (as opposed to integer arithmetic), particularly for representing inequalities. Another line of investigation concerned what we call 'symbolic abstract interpretation', which harnesses the power of modern constraint solvers to perform fundamental symbolic-reasoning operations for different families of descriptors.</p>\n<p>An overarching theme of the work has been that we have considered a number of issues that have been ignored in previous work on program analysis -- and cause previous techniques to be unsound when applied to machine code -- and shown how comparable techniques can be developed that support sound machine-code analysis.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/10/2012<br>\n\t\t\t\t\tModified by: Thomas&nbsp;W&nbsp;Reps</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis grant supported research in the field of program analysis, with the aim of helping programmers create correct, efficient, reliable, and secure software systems. In particular, the research carried out under the grant focused on the difficult and important problem of analyzing stripped machine code (i.e., neither source code nor symbol-table/debugging information is available to help the analyzer).The number of articles during the last several years about security issues---both in the popular press and in the research literature---are one measure of the importance of machine-code analysis.\n\nThe applications of the work include verification that machine-code programs operate as desired, and the identification of bugs and security vulnerabilities at the machine-code level, via combinations of static analysis, dynamic analysis, and symbolic execution.\n\nDuring the course of the project, the main activities have been as follows:\n\n1. Development of a system, called TSL (for Transformer Specification Language), that makes it easier to implement analyses for machine code. TSL provides a platform for specifying the semantics of machine-code instruction sets and generating dynamic, symbolic, and static analyses from the semantic specification.\n\n2. Exploration of how TSL could be used to create implementations of the basic primitives used in symbolic program analysis: forward symbolic evaluation, pre-image computation, and symbolic composition.\n\n3. Exploration of how TSL could be used to specify the transition function for cache memory.\n\n4. The use of TSL to develop a tool, called BCE (Botnet Command Extractor), for automatically extracting botnet-command information from bot executables.\n\n5. The use of TSL to develop a tool, called McVeto (Machine Code VErification Tool), which uses both dynamic analysis and symbolic analysis to determine whether a certain program point of interest is reachable.\n\n6. Several investigations of fundamental issues that arise in program analyzers.  Static-analysis techniques explore the program's behavior for all possible inputs.  The technical challenge that one faces is ``How can one obtain information about the possible states that a program reaches during execution, but without actually running the program on specific inputs?'' To make this feasible, the program is run ``in the aggregate'' -- i.e., on descriptors that represent collections of many states.  One of the lines of investigation concerned the development of families of descriptors suitable for use with bit-vector arithmetic (as opposed to integer arithmetic), particularly for representing inequalities. Another line of investigation concerned what we call 'symbolic abstract interpretation', which harnesses the power of modern constraint solvers to perform fundamental symbolic-reasoning operations for different families of descriptors.\n\nAn overarching theme of the work has been that we have considered a number of issues that have been ignored in previous work on program analysis -- and cause previous techniques to be unsound when applied to machine code -- and shown how comparable techniques can be developed that support sound machine-code analysis.\n\n\t\t\t\t\tLast Modified: 08/10/2012\n\n\t\t\t\t\tSubmitted by: Thomas W Reps"
 }
}