{
 "awd_id": "0746509",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER:     Automated Synthesis of High-Assurance Security Kernels",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Deborah Shands",
 "awd_eff_date": "2008-07-01",
 "awd_exp_date": "2014-06-30",
 "tot_intn_awd_amt": 450000.0,
 "awd_amount": 450000.0,
 "awd_min_amd_letter_date": "2008-01-22",
 "awd_max_amd_letter_date": "2012-08-02",
 "awd_abstract_narration": "Programming languages research has many techniques for generating efficient, correct implementations from high-level specifications. Recent research on language-based security formulates models of information security in terms of modular, algebraic structures from language semantics. This research combines these threads in novel ways to construct high-assurance secure systems in which techniques from programming language semantics provide both a mathematical basis for formal verification and a flexible, modular organizing principle for system design and implementation. This methodology is illustrated with a case study in which kernels (in particular, separation kernels) with a verified security policy are synthesized directly from formal models of security. \r\n\r\nThere is growing interest within defense and avionics circles in separation kernels as a means of coping with serious concerns for system security, safety and integrity arising from the use of high levels of integration. Multi-level security (MLS) systems can be implemented by physical separation: computations at different security levels are situated on different network nodes. However, for many defense and avionics scenarios, physical separation is infeasible due to tight resource constraints. Because sharing resources introduces potential vulnerabilities, mission- or safety-critical MLS systems require both highly integrated implementations and high-assurance security guarantees. This research will have a direct impact on how separation kernels are designed, implemented and verified. Can the rigorous techniques for constructing modular and robust secure systems be generalized to other systems? The long range goal is to facilitate the construction of systems with high assurance end-to-end guarantees, thereby making high assurance more widely available. \r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "William",
   "pi_last_name": "Harrison",
   "pi_mid_init": "L",
   "pi_sufx_name": "",
   "pi_full_name": "William L Harrison",
   "pi_email_addr": "harrisonwl@missouri.edu",
   "nsf_id": "000224591",
   "pi_start_date": "2008-01-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Missouri-Columbia",
  "inst_street_address": "121 UNIVERSITY HALL",
  "inst_street_address_2": "",
  "inst_city_name": "COLUMBIA",
  "inst_state_code": "MO",
  "inst_state_name": "Missouri",
  "inst_phone_num": "5738827560",
  "inst_zip_code": "652113020",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "MO03",
  "org_lgl_bus_name": "UNIVERSITY OF MISSOURI SYSTEM",
  "org_prnt_uei_num": "",
  "org_uei_num": "SZPJL5ZRCLF4"
 },
 "perf_inst": {
  "perf_inst_name": "University of Missouri-Columbia",
  "perf_str_addr": "121 UNIVERSITY HALL",
  "perf_city_name": "COLUMBIA",
  "perf_st_code": "MO",
  "perf_st_name": "Missouri",
  "perf_zip_code": "652113020",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "MO03",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "409000",
   "pgm_ele_name": "ADVANCED NET INFRA & RSCH"
  },
  {
   "pgm_ele_code": "779500",
   "pgm_ele_name": "TRUSTWORTHY COMPUTING"
  },
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "1187",
   "pgm_ref_txt": "PECASE- eligible"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 90000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 180000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 90000.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 90000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Embedded hardware systems have become ubiquitous. We rely on their correctness, safety and security, often without even being aware of their presence. But how do we achieve confidence that the embedded hardware we rely on is, indeed, reliable? This challenge is especially important in the realm of safety- and mission-critical embedded applications in which lives may depend on the correct and secure operation of hardware systems.</p>\n<p>Tools, techniques and methodologies for creating and maintaining secure and safe software are advanced by comparison with hardware methods and one approach to confronting the high reliability challenge in embedded hardware is to adapt some of these software ideas to hardware. This is precisely the approach that this research has taken. The main outcome of this research is a high assurance design methodology for embedded hardware that allows engineers to design, test, implement and verify hardware designs for a wide variety of systems.</p>\n<p>The main vehicle for this research is a new functional programming language called ReWire. ReWire&rsquo;s language design incorporates many of the lessons learned in previous research on constructing secure and safe software. For example, ReWire uses a strong, static type system to automatically check the consistency of ReWire designs. ReWire&rsquo;s design also enables the technology transfer to hardware systems of ideas and techniques from recent advances in so-called language-based security. ReWire&rsquo;s compiler can automatically translate hardware designs into reasonably efficient circuits on FPGA boards. Field programmable gate arrays (FPGAs) are programmable hardware platforms that can be programmed in a manner similar to software systems.</p>\n<p>In addition to the tools developed for ReWire, a number of case studies were performed to evaluate the efficiency and utility of the language and to demonstrate how ReWire designs may be proved safe and secure. A number of hardware systems were developed, including microcontrollers, many core systems, cryptographic algorithms and pattern matchers for deep packet inspection in network processors. These case studies showed that hardware designs can be rendered cleanly in ReWire and implemented efficiently using the ReWire compiler. In some cases, the performance of hardware artifacts produced with ReWire beat the state-of-the-art. An important benefit of the functional programming languages approach taken with ReWire is that hardware designs can be analyzed and proven correct and secure using mathematics &ndash; called formal verification in Computer Science. Several useful case studies of formal verification of security and correctness were performed in the course of this research.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/06/2016<br>\n\t\t\t\t\tModified by: William&nbsp;L&nbsp;Harrison</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nEmbedded hardware systems have become ubiquitous. We rely on their correctness, safety and security, often without even being aware of their presence. But how do we achieve confidence that the embedded hardware we rely on is, indeed, reliable? This challenge is especially important in the realm of safety- and mission-critical embedded applications in which lives may depend on the correct and secure operation of hardware systems.\n\nTools, techniques and methodologies for creating and maintaining secure and safe software are advanced by comparison with hardware methods and one approach to confronting the high reliability challenge in embedded hardware is to adapt some of these software ideas to hardware. This is precisely the approach that this research has taken. The main outcome of this research is a high assurance design methodology for embedded hardware that allows engineers to design, test, implement and verify hardware designs for a wide variety of systems.\n\nThe main vehicle for this research is a new functional programming language called ReWire. ReWire\u00c6s language design incorporates many of the lessons learned in previous research on constructing secure and safe software. For example, ReWire uses a strong, static type system to automatically check the consistency of ReWire designs. ReWire\u00c6s design also enables the technology transfer to hardware systems of ideas and techniques from recent advances in so-called language-based security. ReWire\u00c6s compiler can automatically translate hardware designs into reasonably efficient circuits on FPGA boards. Field programmable gate arrays (FPGAs) are programmable hardware platforms that can be programmed in a manner similar to software systems.\n\nIn addition to the tools developed for ReWire, a number of case studies were performed to evaluate the efficiency and utility of the language and to demonstrate how ReWire designs may be proved safe and secure. A number of hardware systems were developed, including microcontrollers, many core systems, cryptographic algorithms and pattern matchers for deep packet inspection in network processors. These case studies showed that hardware designs can be rendered cleanly in ReWire and implemented efficiently using the ReWire compiler. In some cases, the performance of hardware artifacts produced with ReWire beat the state-of-the-art. An important benefit of the functional programming languages approach taken with ReWire is that hardware designs can be analyzed and proven correct and secure using mathematics &ndash; called formal verification in Computer Science. Several useful case studies of formal verification of security and correctness were performed in the course of this research.\n\n \n\n\t\t\t\t\tLast Modified: 04/06/2016\n\n\t\t\t\t\tSubmitted by: William L Harrison"
 }
}