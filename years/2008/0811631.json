{
 "awd_id": "0811631",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CPA-SEL-T: Collaborative Research: Unified Open Source Transactional Infrastructure",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "John Reppy",
 "awd_eff_date": "2008-09-15",
 "awd_exp_date": "2012-12-31",
 "tot_intn_awd_amt": 500000.0,
 "awd_amount": 532000.0,
 "awd_min_amd_letter_date": "2008-09-09",
 "awd_max_amd_letter_date": "2010-05-05",
 "awd_abstract_narration": "As general-purpose computing moves into the age of pervasive parallelism, programmability becomes the key hurdle limiting the effective use of available computing resources.  Transactional memory promises to simplify parallel programming for application programmers. However, research in Transactional Memory is being seriously hampered by the lack of a reusable open source infrastructure. The project will develop the key pieces necessary to overcome this  situation: A transactional memory library built out of highly decomposed pieces will provide reusable and replaceable parts suitable for investigating tradeoffs in software TM implementations.  Standardized interfaces will allow libraries conforming to the interfaces to be used in a variety of environments. TM-aware run-time analysis tools, particularly profilers and debuggers, will provide the necessary tool support for TM implementors and application programmers to understand and improve the performance of software using transactions.  Interesting benchmarks, in a variety of high-level languages, will move forward our understanding of TM performance characteristics.\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jan",
   "pi_last_name": "Vitek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jan Vitek",
   "pi_email_addr": "j.vitek@neu.edu",
   "nsf_id": "000290862",
   "pi_start_date": "2008-09-09",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Suresh",
   "pi_last_name": "Jagannathan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Suresh Jagannathan",
   "pi_email_addr": "suresh@cs.purdue.edu",
   "nsf_id": "000181308",
   "pi_start_date": "2008-09-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Purdue University",
  "inst_street_address": "2550 NORTHWESTERN AVE # 1100",
  "inst_street_address_2": "",
  "inst_city_name": "WEST LAFAYETTE",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "7654941055",
  "inst_zip_code": "479061332",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IN04",
  "org_lgl_bus_name": "PURDUE UNIVERSITY",
  "org_prnt_uei_num": "YRXVL4JYCEF5",
  "org_uei_num": "YRXVL4JYCEF5"
 },
 "perf_inst": {
  "perf_inst_name": "Purdue University",
  "perf_str_addr": "2550 NORTHWESTERN AVE # 1100",
  "perf_city_name": "WEST LAFAYETTE",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "479061332",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IN04",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 500000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>As general-purpose computing moves into the age of pervasive parallelism forced upon us by multicore and then manycore architectures, programmability becomes the key hurdle limiting the effective use of available computing resources. &nbsp;Transactional memory (TM) holds great promise as a means to simplify parallel programming for application programmers, and it has been an extremely popular research topic in the programming languages, computer architecture, and parallel programming communities in the last few years.</p>\n<p>Prior to this project, the explosion in transactional-memory research had not been matched by the distillation of key concepts and design trade-offs required to build reusable infrastructure supporting a variety of implementation techniques, programming languages, hardware platforms, and analysis tools. The key contribution of this project has been to address this deficiency via the development of interfaces and mechanisms to allow clients to use TM (and TM components) effectively while still allowing innovation in TM techniques. &nbsp;</p>\n<p>This project has made notable contributions in four focus areas: (1) Hardware/Software interfaces, (2) Language Design, (3) Debugging Standardization, and (4) Application Development.</p>\n<p><span style=\"text-decoration: underline;\"><strong>Hardware/Software Interfaces.</strong></span></p>\n<div class=\"page\" title=\"Page 6\">\n<div class=\"layoutArea\">\n<div class=\"column\">\n<p><span>A detailed exploration of mechanisms to exploit hardware TM support in the Azul&nbsp;appliance that was purchased in a companion grant was conducted. A full-fledged port of the multi-MLton compiler and runtime onto the Azul appliance was performed and a new garbage collection algorithm that exploits hardware TM support was devised, implemented, and evaluated.&nbsp;</span>Performance analysis for both Java and ML were performed. &nbsp;A real-time transactional memory (RTTM) infrastructure as a time-predictable synchronization solution for chip-multiprocessors&nbsp;in real-time systems has been developed. This work defined hardware for time-predictable transactions and provided a bound for the&nbsp;maximum transaction retries. The proposed RTTM was evaluated with a simulation of a Java chip-multiprocessor.</p>\n<p><span style=\"text-decoration: underline;\"><strong>Language Design.</strong></span></p>\n<div class=\"page\" title=\"Page 7\">\n<div class=\"layoutArea\">\n<div class=\"column\">\n<p><span>An important outcome of this project has been the generation of new techniques to eliminate concurrency- related errors such as data races based on foundational TM principles. &nbsp;Traditional approaches to preventing data races rely on protecting instruction sequences with synchronization operations. Such control-centric approaches are inherently brittle as the burden is on the programmer to ensure that all concurrently accessed memory locations are consistently protected. Data-centric synchronization is an alternative approach that offloads some of the work onto the language implementation by grouping fields of objects into atomic sets to indicate that these fields always must be updated atomically. Each atomic set has associated units of work, code fragments that preserve the consistency of that atomic set. Synchronization operations are added automatically by the compiler. &nbsp;An extension to the Java programming language has been developed that integrates annotations for data-centric concurrency control. The resulting language, called AJ, relies on a type system that enables separate compilation and supports atomic sets that span multiple objects and that also supports full encapsulation for more efficient code generation. &nbsp;Our results indicate that data-centric synchronization is easy to use, enjoys low annotation overhead, and successfully preventing data races.&nbsp;</span></p>\n</div>\n</div>\n</div>\n<div class=\"page\" title=\"Page 7\">\n<div ...",
  "por_txt_cntn": "\nAs general-purpose computing moves into the age of pervasive parallelism forced upon us by multicore and then manycore architectures, programmability becomes the key hurdle limiting the effective use of available computing resources.  Transactional memory (TM) holds great promise as a means to simplify parallel programming for application programmers, and it has been an extremely popular research topic in the programming languages, computer architecture, and parallel programming communities in the last few years.\n\nPrior to this project, the explosion in transactional-memory research had not been matched by the distillation of key concepts and design trade-offs required to build reusable infrastructure supporting a variety of implementation techniques, programming languages, hardware platforms, and analysis tools. The key contribution of this project has been to address this deficiency via the development of interfaces and mechanisms to allow clients to use TM (and TM components) effectively while still allowing innovation in TM techniques.  \n\nThis project has made notable contributions in four focus areas: (1) Hardware/Software interfaces, (2) Language Design, (3) Debugging Standardization, and (4) Application Development.\n\nHardware/Software Interfaces.\n\n\n\n\nA detailed exploration of mechanisms to exploit hardware TM support in the Azul appliance that was purchased in a companion grant was conducted. A full-fledged port of the multi-MLton compiler and runtime onto the Azul appliance was performed and a new garbage collection algorithm that exploits hardware TM support was devised, implemented, and evaluated. Performance analysis for both Java and ML were performed.  A real-time transactional memory (RTTM) infrastructure as a time-predictable synchronization solution for chip-multiprocessors in real-time systems has been developed. This work defined hardware for time-predictable transactions and provided a bound for the maximum transaction retries. The proposed RTTM was evaluated with a simulation of a Java chip-multiprocessor.\n\nLanguage Design.\n\n\n\n\nAn important outcome of this project has been the generation of new techniques to eliminate concurrency- related errors such as data races based on foundational TM principles.  Traditional approaches to preventing data races rely on protecting instruction sequences with synchronization operations. Such control-centric approaches are inherently brittle as the burden is on the programmer to ensure that all concurrently accessed memory locations are consistently protected. Data-centric synchronization is an alternative approach that offloads some of the work onto the language implementation by grouping fields of objects into atomic sets to indicate that these fields always must be updated atomically. Each atomic set has associated units of work, code fragments that preserve the consistency of that atomic set. Synchronization operations are added automatically by the compiler.  An extension to the Java programming language has been developed that integrates annotations for data-centric concurrency control. The resulting language, called AJ, relies on a type system that enables separate compilation and supports atomic sets that span multiple objects and that also supports full encapsulation for more efficient code generation.  Our results indicate that data-centric synchronization is easy to use, enjoys low annotation overhead, and successfully preventing data races. \n\n\n\n\n\n\n\nDynamic detection of concurrency errors depend fundamentally on the level of abstraction at which one views memory. We have shown that a dynamic concurrency tool (specifically a data-race detector) operating at the binary level can lead to false positives and false negatives in terms of a higher-level\n managed language. We have demonstrated how an open API can allow a language run-time system to communicate with the low-level detector to avoid\nsources of imprecision.\n \n\n\n\n\nDebugging Standardization\n\n\n\n\nIf the transac..."
 }
}