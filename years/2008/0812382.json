{
 "awd_id": "0812382",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "HCC-Small: End-User Retrofitting of Applications By Recognizing Text and UI Components",
 "cfda_num": "47.070",
 "org_code": "05020000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Ephraim Glinert",
 "awd_eff_date": "2008-09-01",
 "awd_exp_date": "2010-08-31",
 "tot_intn_awd_amt": 0.0,
 "awd_amount": 328086.0,
 "awd_min_amd_letter_date": "2008-08-16",
 "awd_max_amd_letter_date": "2010-07-01",
 "awd_abstract_narration": "Despite the enormous effort that goes into application design, end users invariably encounter workflow scenarios that are poorly supported by even the most developed, commercial-quality applications. Lack of support for end-user extension increases the burden on application developers to exhaustively anticipate the needs of all end users and then to commit enough resources to address their needs, which often includes re-implementing solutions already found in other applications. This project develops the feasibility of externally retrofitting, without altering, running applications with new interfaces and functionality made possible by using a combination of application-independent pixel-level recognition techniques and more specialized techniques for inspecting data structures exposed by the window system or application. Users will be able to make annotations to those running applications, including hand-drawn ink, typed text, diagrams, interactive widgets, or even links to other application user interface components. Registration techniques will then be researched to associate the annotations with specific elements of an application or document so that such an annotation can be made to appear perhaps only in one place in a specific file, or whenever a certain application runs. This supports a variety of practices, including: integrating functionality from different applications, enriched collaboration, task or user customized interfaces, and adding new fine-grained user interface elements to applications. \r\n\r\nBroader Impact. Making applications more malleable by embracing customization as a first class and general notion could fundamentally shift application design. Instead of relying solely on inherently slow development of one-size-fits-all applications, end-users could become de facto participants in application design, somewhat analogous to the relationship between traditional print-copy publishing and blogging. Rather than waiting, possibly years, for even simple revisions to fix workflow inefficiencies, users will be empowered to make limited modifications to applications almost as easily as marking up a document, for example by freely rearranging applications? interfaces, or adding diagrammatic annotations displayed over documents which do not natively support them.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "IIS",
 "org_div_long_name": "Division of Information & Intelligent Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Andries",
   "pi_last_name": "van Dam",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Andries van Dam",
   "pi_email_addr": "avd@cs.brown.edu",
   "nsf_id": "000100416",
   "pi_start_date": "2008-08-16",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Brown University",
  "inst_street_address": "1 PROSPECT ST",
  "inst_street_address_2": "",
  "inst_city_name": "PROVIDENCE",
  "inst_state_code": "RI",
  "inst_state_name": "Rhode Island",
  "inst_phone_num": "4018632777",
  "inst_zip_code": "029129100",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "RI01",
  "org_lgl_bus_name": "BROWN UNIVERSITY",
  "org_prnt_uei_num": "E3FDXZ6TBHW3",
  "org_uei_num": "E3FDXZ6TBHW3"
 },
 "perf_inst": {
  "perf_inst_name": "Brown University",
  "perf_str_addr": "1 PROSPECT ST",
  "perf_city_name": "PROVIDENCE",
  "perf_st_code": "RI",
  "perf_st_name": "Rhode Island",
  "perf_zip_code": "029129100",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "RI01",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "736700",
   "pgm_ele_name": "HCC-Human-Centered Computing"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7367",
   "pgm_ref_txt": "Cyber-Human Systems"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  },
  {
   "pgm_ref_code": "9215",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING SYSTEMS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 300000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 12086.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"MsoNormal\" style=\"margin: 0in 0in 0pt;\"><span style=\"font-family: Times New Roman; font-size: small;\">Despite the enormous effort that goes into application design, end users invariably encounter workflow scenarios that are poorly supported by even the most developed, commercial-quality applications.<span style=\"mso-spacerun: yes;\">&nbsp; </span>In this project, we explored a variety of ways for end-users to modify the behavior of applications without involving technically savvy application programmers to modify the application&rsquo;s source code. <span style=\"mso-spacerun: yes;\">&nbsp;</span>The idea is essentially to model the modification of an application&rsquo;s behavior from a physically-based perspective.<span style=\"mso-spacerun: yes;\">&nbsp; </span>Instead of using programming techniques, we wanted to make an application feel more like a piece of paper that can be cut-up, re-arranged, and blended with pieces of other pieces of paper.<span style=\"mso-spacerun: yes;\">&nbsp; </span>Since the process of cutting up applications is not directly supported in existing systems, we show the users a &ldquo;copy&rdquo; of the display screen &ndash; the real, unmodified display screen (with the running applications) is never shown but still exists.<span style=\"mso-spacerun: yes;\">&nbsp; </span>Thus, the copied image can be cut apart and re-assembled since it is just an image &ndash; however, all the while we maintain a link between each piece that has been moved or changed and the unmodified &ldquo;original&rdquo;.<span style=\"mso-spacerun: yes;\">&nbsp; </span>If the user tries to interact with their modified, copied versi</span><a name=\"_GoBack\"></a><span style=\"font-family: Times New Roman; font-size: small;\">on of the screen, we transform all of their actions into corresponding interactions on the original display screen.<span style=\"mso-spacerun: yes;\">&nbsp; </span>By keeping the modified copy of the display screen synchronized with the original display screen, end-users can feel as if they have changed the application&rsquo;s behavior even though the original application is still running, unmodified, &ldquo;in the background.&rdquo;<span style=\"mso-spacerun: yes;\">&nbsp; </span>During this project, we developed techniques for recognizing application elements, techniques for copying and modifying a display screen such that it is still synchronized with the original display, and we developed a set of retrofit applications.</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0in 0in 0pt;\"><span style=\"font-family: Times New Roman; font-size: small;\">&nbsp;</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0in 0in 0pt;\"><span style=\"font-size: small;\"><span style=\"font-family: Times New Roman;\"><em style=\"mso-bidi-font-style: normal;\">Recognizing application elements</em>: <span style=\"mso-spacerun: yes;\">&nbsp;</span>There are two classes of techniques for recognizing application elements so that they can be synchronized with changes made by a user: applications can be recognized optically, the way a human recognizes an application in terms of its colors, shapes, and text labels; or applications can be recognized by probing the abstract representation of applications that operating systems may expose.<span style=\"mso-spacerun: yes;\">&nbsp; </span>The former techniques are the most general since they can work with any application, but the latter techniques can often access (&ldquo;see&rdquo;) more of an application since not all aspects of an application can be seen on the display all the time (e.g., the elements of a File menu cannot be seen before clicking on the File menu, although data structures representing elements of the File menu generally will always exist). In this project, we developed a toolkit of techniques which try to unify recognition based approaches with data structure based approaches to provide the best balance of generality and robustness.</span...",
  "por_txt_cntn": "Despite the enormous effort that goes into application design, end users invariably encounter workflow scenarios that are poorly supported by even the most developed, commercial-quality applications.  In this project, we explored a variety of ways for end-users to modify the behavior of applications without involving technically savvy application programmers to modify the application\u00c6s source code.  The idea is essentially to model the modification of an application\u00c6s behavior from a physically-based perspective.  Instead of using programming techniques, we wanted to make an application feel more like a piece of paper that can be cut-up, re-arranged, and blended with pieces of other pieces of paper.  Since the process of cutting up applications is not directly supported in existing systems, we show the users a \"copy\" of the display screen &ndash; the real, unmodified display screen (with the running applications) is never shown but still exists.  Thus, the copied image can be cut apart and re-assembled since it is just an image &ndash; however, all the while we maintain a link between each piece that has been moved or changed and the unmodified \"original\".  If the user tries to interact with their modified, copied version of the screen, we transform all of their actions into corresponding interactions on the original display screen.  By keeping the modified copy of the display screen synchronized with the original display screen, end-users can feel as if they have changed the application\u00c6s behavior even though the original application is still running, unmodified, \"in the background.\"  During this project, we developed techniques for recognizing application elements, techniques for copying and modifying a display screen such that it is still synchronized with the original display, and we developed a set of retrofit applications.\n \nRecognizing application elements:  There are two classes of techniques for recognizing application elements so that they can be synchronized with changes made by a user: applications can be recognized optically, the way a human recognizes an application in terms of its colors, shapes, and text labels; or applications can be recognized by probing the abstract representation of applications that operating systems may expose.  The former techniques are the most general since they can work with any application, but the latter techniques can often access (\"see\") more of an application since not all aspects of an application can be seen on the display all the time (e.g., the elements of a File menu cannot be seen before clicking on the File menu, although data structures representing elements of the File menu generally will always exist). In this project, we developed a toolkit of techniques which try to unify recognition based approaches with data structure based approaches to provide the best balance of generality and robustness.\n \nModifying application behavior: To modify the way applications work, we allow users to \"copy\" regions of the screen.  These screen copies know where in the original application they came from.  Thus, for example, if the user copies a button from an application, moves it somewhere else, makes it bigger, and then clicks on it, we pass that click event back to the original button in the underlying (but not visible) application and if that click modifies the appearance of the underlying application, we copy those changes back to the users modified version of the display.   By combining the ability to cut apart user interfaces with the ability to create macros (automated sequences of activities), end-users can generate novel application behaviors on their own.  For example, a user can instruct another on how to use an application by writing messages over menus and buttons; when another user runs the application, those messages will show up next to right buttons/menus even if their windows are arranged differently on the screen.  \n \nInteresting retrofit functionality: To emphasize t..."
 }
}