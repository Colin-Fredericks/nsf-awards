{
 "awd_id": "0747041",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER:  The Automata Theoretic Method in Software Verification",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2008-06-15",
 "awd_exp_date": "2014-05-31",
 "tot_intn_awd_amt": 400000.0,
 "awd_amount": 400000.0,
 "awd_min_amd_letter_date": "2008-06-10",
 "awd_max_amd_letter_date": "2012-07-17",
 "awd_abstract_narration": "Proposal Number: 0747041\r\n\r\nTITLE: The Automata Theoretic Method in Software Verification\r\nPI: Madhusudan Parthasarathy\r\nCorrect programs are hard to write. Tools that find errors automatically and reliably are essential to ensure engineering of correct software.  Automata theory has had a great impact in hardware verification, where it forms the basis of model-checking systems against temporal logics. This project leverages automata-theoretic methods to the field of software verification.  Automata theory provides several strikingly new mechanisms for verifying software, including handling of complex control flows of recursion and concurrency, and bridging logical specifications to verification algorithms.\r\nThe project will develop these mechanisms and apply them to solve key problems in the following areas of software verification:\r\n- Developing temporal logics for specifying complex event sequence properties of recursive programs;\r\n- Checking atomicity violations in concurrent programs using automata-based monitoring; and\r\n- Verifying heap properties of programs manipulating dynamic data, using a novel automata based abstraction.\r\nIn addition, two tools will be developed: one monitors concurrent programs for atomicity violations, and the second implements an abstraction framework to verify heap-intensive programs.  The techniques developed will pave innovative pathways into the fundamental problems of analyzing software. The techniques will have immediate impact on analysis tools built and used in the software industry, and significantly advance the landscape of software verification.\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Madhusudan",
   "pi_last_name": "Parthasarathy",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Madhusudan Parthasarathy",
   "pi_email_addr": "madhu@cs.uiuc.edu",
   "nsf_id": "000214557",
   "pi_start_date": "2008-06-10",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "506 S WRIGHT ST",
  "perf_city_name": "URBANA",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618013620",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0111",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001112DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2011,
   "fund_oblg_amt": 80000.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 80000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project aimed at automating several aspects of software verification, which are yet to be automated, using automata-theoretic techniques. Automata are very restricted machines that give ways to express properties of structures using finite representations, and give algorithmic ways to manipulate the finite representations. Automata hence can be seen as algorithmically amenable ways to express logical properties of structures. Automata have very interesting and deep technical properties, including decidability of concepts expressible as automata as well as a solid theory of learning associated with them. The key proposal was to use these properties to automate problems in software verification.</p>\n<p>&nbsp;</p>\n<p><strong>Intellectual Merit:</strong></p>\n<p>The work addressed several applications of automata theory to software verification. First, we addressed the problem of abstracting software using automata-based models and subsequently verifying them. This led to a general way to build efficient model-checking algorithms using a very succinct declarative representation of the algorithm to compute on the automata-theoretic model, and led to a general model-checker for both sequential and concurrent programs, with recursion. Second, automata-theoretic methods were developed to monitor executions of concurrent programs, where complex properties such as atomicity can be efficiently monitored using an automaton giving bounded memory online algorithms for this problem. This investigation then led to ways to use the monitored run to predict new executions that could have bugs, and led to an entire research program, called predictive testing, where several techniques and tools (Penelope) were developed to find errors in concurrent programs based on properties of the interleaved execution they exhibited. Third, the research fundamentally addressed the problem of expressing properties of heap structures, such as lists, arrays, and trees, using automata and using automata as a way to decide properties of program manipulating data-structures. A powerful logic called Strand and a decision technique based on automata-theory emerged from this research, and to date, is one of the most powerful decidable logics for heaps. Several connections to automata, graphs of bounded tree-width, and tree automata representing properties of data-structures were developed, along with accompanying tools. The final phase of this research led to a more tractable (but incomplete) method for reasoning about heaps, called natural proofs, that overcame the extreme complexity of deciding these logics by using much simpler proofs that can be searched for more efficiently. This technique and tool (called Dryad) is the current state-of-the-art verification tool for automated analysis of heap-based programs. Finally, the research also developed learning techniques for program verification, both using automata as well as other logical techniques. In particular, we developed new classes of automata that can express properties of heaps expressible in Strand (the decidable logic) and developed learning algorithms for these automata that can be used to learn invariants from examples. Also, an entirely new learning model for synthesizing invariants was developed, called ICE, which in addition to positive and negative samples, uses implication counterexamples to guide the learner towards an invariant. This new learning model was shown to be robust for invariant synthesis, and several learning algorithms were developed, showing robustness through experiments. Invariant synthesis allows automating the expression of invariants in program verification, automating a phase that programmers currently find very hard, and is arguably a major bottleneck for the use of formal methods in practice.</p>\n<p><strong>Broader Impact:</strong></p>\n<p>Research and Technological:</p>\n<p>The techniques and tools developed in t...",
  "por_txt_cntn": "\nThis project aimed at automating several aspects of software verification, which are yet to be automated, using automata-theoretic techniques. Automata are very restricted machines that give ways to express properties of structures using finite representations, and give algorithmic ways to manipulate the finite representations. Automata hence can be seen as algorithmically amenable ways to express logical properties of structures. Automata have very interesting and deep technical properties, including decidability of concepts expressible as automata as well as a solid theory of learning associated with them. The key proposal was to use these properties to automate problems in software verification.\n\n \n\nIntellectual Merit:\n\nThe work addressed several applications of automata theory to software verification. First, we addressed the problem of abstracting software using automata-based models and subsequently verifying them. This led to a general way to build efficient model-checking algorithms using a very succinct declarative representation of the algorithm to compute on the automata-theoretic model, and led to a general model-checker for both sequential and concurrent programs, with recursion. Second, automata-theoretic methods were developed to monitor executions of concurrent programs, where complex properties such as atomicity can be efficiently monitored using an automaton giving bounded memory online algorithms for this problem. This investigation then led to ways to use the monitored run to predict new executions that could have bugs, and led to an entire research program, called predictive testing, where several techniques and tools (Penelope) were developed to find errors in concurrent programs based on properties of the interleaved execution they exhibited. Third, the research fundamentally addressed the problem of expressing properties of heap structures, such as lists, arrays, and trees, using automata and using automata as a way to decide properties of program manipulating data-structures. A powerful logic called Strand and a decision technique based on automata-theory emerged from this research, and to date, is one of the most powerful decidable logics for heaps. Several connections to automata, graphs of bounded tree-width, and tree automata representing properties of data-structures were developed, along with accompanying tools. The final phase of this research led to a more tractable (but incomplete) method for reasoning about heaps, called natural proofs, that overcame the extreme complexity of deciding these logics by using much simpler proofs that can be searched for more efficiently. This technique and tool (called Dryad) is the current state-of-the-art verification tool for automated analysis of heap-based programs. Finally, the research also developed learning techniques for program verification, both using automata as well as other logical techniques. In particular, we developed new classes of automata that can express properties of heaps expressible in Strand (the decidable logic) and developed learning algorithms for these automata that can be used to learn invariants from examples. Also, an entirely new learning model for synthesizing invariants was developed, called ICE, which in addition to positive and negative samples, uses implication counterexamples to guide the learner towards an invariant. This new learning model was shown to be robust for invariant synthesis, and several learning algorithms were developed, showing robustness through experiments. Invariant synthesis allows automating the expression of invariants in program verification, automating a phase that programmers currently find very hard, and is arguably a major bottleneck for the use of formal methods in practice.\n\nBroader Impact:\n\nResearch and Technological:\n\nThe techniques and tools developed in this proposal are useful in both debugging as well as proving programs free of errors. In particular, the tools based on predictive analys..."
 }
}