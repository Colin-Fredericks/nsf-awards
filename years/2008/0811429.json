{
 "awd_id": "0811429",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CPA-DA: Formal Methods for Multi-core Shared Memory Protocol Design",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927843",
 "po_email": "sabasu@nsf.gov",
 "po_sign_block_name": "Sankar Basu",
 "awd_eff_date": "2008-07-01",
 "awd_exp_date": "2013-06-30",
 "tot_intn_awd_amt": 250000.0,
 "awd_amount": 298000.0,
 "awd_min_amd_letter_date": "2008-06-27",
 "awd_max_amd_letter_date": "2012-06-13",
 "awd_abstract_narration": "Title: Formal Methods for Multi-core Shared Memory Protocol Design\r\nPI: Ganesh Gopalakrishnan\r\nInst: University of Utah\r\nNSF Proposal Number: 0811429 \r\n\r\nABSTRACT:\r\nThe human society crucially depends on computing devices: from embedded computers in phones to peta-scale computing systems that can perform a million billion multiplications every second, and help simulate everything from car crashes to hurricanes. The performance of a computer must increase each year, without which the information-based human society will cease to advance. Unfortunately, past methods to increase the performance of a computer ? namely increasing the clock frequency and the functional unit complexity -- cease to be effective. These techniques now produce only a miniscule performance increase, while causing huge increases in the energy consumption. Already computing equipments consume more than 5% of the nation's electricity! The only available energy-efficient method of increasing computer performance is through the use of multiple central processing units (CPUs). Unfortunately, such organizations (called \"multi-core CPUs\") require that the accesses to the central memory be extremely efficient - requiring the use of highly complex protocols - called cache coherence protocols.  Unfortunately these protocols must be hand-crafted for high performance, and hence are extremely error-prone. Previous methods to verify cache coherence protocols were already at the limits of the capabilities of verification tools. With the advent of multi-core CPUs, the complexity has become out of reach of all published techniques. The PI and his team are the only academic group to have developed techniques to verify, using mathematically sound computer algorithms, hierarchical multi-core CPU cache coherence protocols.  Unfortunately, their methods to date have involved expert humans and often cause considerable tedium.  The proposed methods in this proposal are expected to: (1) reduce the burden of verifying cache coherence protocols, and (2) help bridge two central abstraction gaps, thus minimizing the chances of errors in microprocessors: (i) high-level to low-level behavioral modeling gap, and (ii) the low behavioral level to hardware implementation level gap.  It will help train valuable manpower - including undergraduates and under-represented groups. It will help sustain the technological momentum of the US, as the availability of sustained high performance computing power is no less important to the nation than its other basic needs such as water, clean air, and energy.  The verification tools developed in this project are expected to be technology transferred to the computer industry.  Last but not least, the students trained in this project will join the national and international high-technology labor force.\r\n\r\n",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Ganesh",
   "pi_last_name": "Gopalakrishnan",
   "pi_mid_init": "L",
   "pi_sufx_name": "",
   "pi_full_name": "Ganesh L Gopalakrishnan",
   "pi_email_addr": "ganesh@cs.utah.edu",
   "nsf_id": "000160895",
   "pi_start_date": "2008-06-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Utah",
  "inst_street_address": "201 PRESIDENTS CIR",
  "inst_street_address_2": "",
  "inst_city_name": "SALT LAKE CITY",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8015816903",
  "inst_zip_code": "841129049",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "UT01",
  "org_lgl_bus_name": "UNIVERSITY OF UTAH",
  "org_prnt_uei_num": "",
  "org_uei_num": "LL8GLEVH6MG3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Utah",
  "perf_str_addr": "201 PRESIDENTS CIR",
  "perf_city_name": "SALT LAKE CITY",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "841129049",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "UT01",
  "perf_ctry_name": "",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "735200",
   "pgm_ele_name": "COMPUTING PROCESSES & ARTIFACT"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794500",
   "pgm_ele_name": "DES AUTO FOR MICRO & NANO SYST"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7945",
   "pgm_ref_txt": "DES AUTO FOR MICRO & NANO SYST"
  },
  {
   "pgm_ref_code": "9216",
   "pgm_ref_txt": "ADVANCED SOFTWARE TECH & ALGOR"
  },
  {
   "pgm_ref_code": "9218",
   "pgm_ref_txt": "BASIC RESEARCH & HUMAN RESORCS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  },
  {
   "pgm_ref_code": "HPCC",
   "pgm_ref_txt": "HIGH PERFORMANCE COMPUTING & COMM"
  }
 ],
 "app_fund": [
  {
   "app_code": "0108",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000809DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0109",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01000910DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0110",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001011DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2008,
   "fund_oblg_amt": 223214.0
  },
  {
   "fund_oblg_fiscal_yr": 2009,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2010,
   "fund_oblg_amt": 42786.0
  },
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><br />This research targeted the fundamental challenge of ensuring that<br />computing systems that are optimized for performance are also devoid<br />of logical errors in their design. Beginning around 2005, computer<br />manufacturers catering to virtually all application classes have<br />adopted multiple central processing units (CPUs) in their design.<br />Adopting this style of multicores is the only foreseeable way<br />toward achieving high computing performance at low energy costs.<br />Unfortunately, this massive-scale usage of parallel processing<br />requires a significant amount of programmer training, <br />new methods to program safely without losing efficiency, <br />as well as incisive verification tools to detect and root-cause<br />correctness errors.<br /><br />Our research made contributions in these regards in four <br />specific areas.<br /><br />VERIFICATION OF HIERARCHICAL CACHE COHERENCE PROTOCOLS<br /><br />Multicore systems are often designed by employing a small cluster<br />of CPU cores that are tightly interconnected and a hierarchical <br />arrangement of such clusters into a larger ensemble. It is crucial<br />to ensure a consistent view of memory both within the cluster as<br />well as across the cluster. This is achieved by using suitable cache<br />coherence protocols.&nbsp; Since the memory sharing patterns as<br />well as electrical distances are different between the CPUs within<br />a cluster as well as across the cluster, different cache coherence<br />protocols are employed within a cluster and spanning multiple <br />clusters. <br /><br />Our research developed techniques for developing ``overlapping<br />abstractions.'' Intuitively, the degree of coupling between the<br />the intra-cluster and intercluster protocols is limited. This<br />observation helps us develop two simpler models, one simplifying<br />the intra-cluster protocol and the other simplifying the inter-cluster<br />model. We successfully demonstrated that non-trivial hierarchical<br />cache coherence protocols can be verified using this approach.<br /><br />A PROVER OF USER GPU PROGRAMS<br /><br />The use of multiple CPU cores takes two forms in practice: (1) the use<br />of traditional CPU cores that are eficient at handling control-flow,<br />and (2) the use of specialized processors that are oriented toward <br />large-scale data processing, and controlled by traditional CPUs for <br />offloading computations. A popular type of data-oriented processor<br />suitable for use in the ``offload model'' is the Graphical Processing<br />Unit (GPU). When we began our research on GPU programming,<br />it came to our attention that no verification methods that offered firm<br />guarantees were available for GPUs. We developed a symbolic analysis<br />method that employed the power of symbolic execution and invariant<br />generation to ensure that GPU programs do not have insidious bugs<br />such as data racs (conflicting read/write accesses that led to<br />unpredictable answers).<br /><br />VERIFICATION METHODS FOR MULTICORE COMMUNICATION APIS<br /><br />As system complexity escalates, the need for multicore chips<br />that communicate using both message passing and shared memory also<br />escalates. A recent standardization effort by the industry has<br />led to the creation of the multicore communications API (MCAPI). <br />Our research helped investigate these proposed APIs and our efforts <br />led to the creation of a dynamic analysis tool called MCC that<br />orchestrates concurrency in these two regimes<br /><br />AN EXTENSIBLE UTAH MULTICORE DESIGN<br /><br />The last component of our research on multicore programming and<br />correctness analysis was centered around building an actual multicore<br />system that communicates as per MCAPI and can be made to operate on <br />field programmable gate arrays (FPGA). This design is called eXtensible<br />Utah ...",
  "por_txt_cntn": "\n\nThis research targeted the fundamental challenge of ensuring that\ncomputing systems that are optimized for performance are also devoid\nof logical errors in their design. Beginning around 2005, computer\nmanufacturers catering to virtually all application classes have\nadopted multiple central processing units (CPUs) in their design.\nAdopting this style of multicores is the only foreseeable way\ntoward achieving high computing performance at low energy costs.\nUnfortunately, this massive-scale usage of parallel processing\nrequires a significant amount of programmer training, \nnew methods to program safely without losing efficiency, \nas well as incisive verification tools to detect and root-cause\ncorrectness errors.\n\nOur research made contributions in these regards in four \nspecific areas.\n\nVERIFICATION OF HIERARCHICAL CACHE COHERENCE PROTOCOLS\n\nMulticore systems are often designed by employing a small cluster\nof CPU cores that are tightly interconnected and a hierarchical \narrangement of such clusters into a larger ensemble. It is crucial\nto ensure a consistent view of memory both within the cluster as\nwell as across the cluster. This is achieved by using suitable cache\ncoherence protocols.  Since the memory sharing patterns as\nwell as electrical distances are different between the CPUs within\na cluster as well as across the cluster, different cache coherence\nprotocols are employed within a cluster and spanning multiple \nclusters. \n\nOur research developed techniques for developing ``overlapping\nabstractions.'' Intuitively, the degree of coupling between the\nthe intra-cluster and intercluster protocols is limited. This\nobservation helps us develop two simpler models, one simplifying\nthe intra-cluster protocol and the other simplifying the inter-cluster\nmodel. We successfully demonstrated that non-trivial hierarchical\ncache coherence protocols can be verified using this approach.\n\nA PROVER OF USER GPU PROGRAMS\n\nThe use of multiple CPU cores takes two forms in practice: (1) the use\nof traditional CPU cores that are eficient at handling control-flow,\nand (2) the use of specialized processors that are oriented toward \nlarge-scale data processing, and controlled by traditional CPUs for \noffloading computations. A popular type of data-oriented processor\nsuitable for use in the ``offload model'' is the Graphical Processing\nUnit (GPU). When we began our research on GPU programming,\nit came to our attention that no verification methods that offered firm\nguarantees were available for GPUs. We developed a symbolic analysis\nmethod that employed the power of symbolic execution and invariant\ngeneration to ensure that GPU programs do not have insidious bugs\nsuch as data racs (conflicting read/write accesses that led to\nunpredictable answers).\n\nVERIFICATION METHODS FOR MULTICORE COMMUNICATION APIS\n\nAs system complexity escalates, the need for multicore chips\nthat communicate using both message passing and shared memory also\nescalates. A recent standardization effort by the industry has\nled to the creation of the multicore communications API (MCAPI). \nOur research helped investigate these proposed APIs and our efforts \nled to the creation of a dynamic analysis tool called MCC that\norchestrates concurrency in these two regimes\n\nAN EXTENSIBLE UTAH MULTICORE DESIGN\n\nThe last component of our research on multicore programming and\ncorrectness analysis was centered around building an actual multicore\nsystem that communicates as per MCAPI and can be made to operate on \nfield programmable gate arrays (FPGA). This design is called eXtensible\nUtah Multicore (XUM), and has been released to Opencores.Org in 2011. \nThere have, to date, been over a thousand downloads of XUM.\n\nCONCLUDING REMARKS AND OUTCOMES\n\n\nIn the hierarchical cache coherence verification project, a female PhD student, Dr. Xiaofang Chen, graduated in\n2008, working on this project.  A US Citizen Mr. Michael DeLisi \ngraduated, initially as an NSF REU and later as a BS/MS student.\n Mr. DeLisi wa..."
 }
}