{
 "awd_id": "1302269",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:Medium:Overcoming the Intuition Wall: Automatic Graphical Analysis of Programs to Discover and Program New Computer Architectures",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Tao Li",
 "awd_eff_date": "2013-09-15",
 "awd_exp_date": "2016-12-31",
 "tot_intn_awd_amt": 400654.0,
 "awd_amount": 400654.0,
 "awd_min_amd_letter_date": "2013-09-09",
 "awd_max_amd_letter_date": "2013-09-09",
 "awd_abstract_narration": "Workload characterization is central to development of new computer architectures. The rise of the mobile-cloud paradigm has increased the diversity and rate at which applications are created thus challenging computer architects' ability to build optimized systems for them. In the past, architects have been able to examine software codes of interest (often through slow laborious manual inspection if necessary) when releases were far and few in between to derive intuition necessary to make architectural and microarchitectural discoveries. But this method does not scale to emerging applications that are literally hammered out in the hundreds by the day. Further, new languages and platforms have behaviors that are quite different from legacy codes and there is an urgent need for intuition on these applications. Without new methods to characterize emerging workloads, computer architects risk running into an intuition wall. This risk might prove calamitous if unmitigated, given the added reliance on (micro)architects to develop more energy efficient designs to compensate for the losses due to slowdowns in Dennard's scaling.\r\n\r\nAdvances in machine learning provide an opportunity to overcome the intuition wall. In the last decade there have been many major advances in machine learning on graphs motivated by need/benefits of mining behaviors in social networks and enabled by cheap commodity computing. In this project, the PIs plan to leverage these advances to discover and program new computer architectures. By viewing program execution as a graph, clustering these graphs, and mining them for similarities, the PIs plan to discover new behaviors that architects and microarchitects can use to develop new on-chip acceleration structures. The PIs also plan to study how legacy code can semi-automatically be converted to execute on the architectures with the new accelerators.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Simha",
   "pi_last_name": "Sethumadhavan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Simha Sethumadhavan",
   "pi_email_addr": "simha@cs.columbia.edu",
   "nsf_id": "000502420",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Gail",
   "pi_last_name": "Kaiser",
   "pi_mid_init": "E",
   "pi_sufx_name": "",
   "pi_full_name": "Gail E Kaiser",
   "pi_email_addr": "kaiser@cs.columbia.edu",
   "nsf_id": "000094973",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Tony",
   "pi_last_name": "Jebara",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Tony Jebara",
   "pi_email_addr": "jebara@cs.columbia.edu",
   "nsf_id": "000093679",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Columbia University",
  "inst_street_address": "615 W 131ST ST",
  "inst_street_address_2": "MC 8741",
  "inst_city_name": "NEW YORK",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "2128546851",
  "inst_zip_code": "100277922",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "NY13",
  "org_lgl_bus_name": "THE TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "F4N1QNPB95M4"
 },
 "perf_inst": {
  "perf_inst_name": "Columbia University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "100277003",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "NY13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "748400",
   "pgm_ele_name": "IIS Special Projects"
  },
  {
   "pgm_ele_code": "794100",
   "pgm_ele_name": "COMPUTER ARCHITECTURE"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7941",
   "pgm_ref_txt": "COMPUTER ARCHITECTURE"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 400654.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Designing and optimizing computer systems require deep understanding of the underlying system behavior. Historically many important observations that led to the development of essential hardware and software optimizations were driven by empirical observations about program behavior. &nbsp;As such this project was aimed at discovering new phenomenon across and, within programs, in large code bases. There were two significant outcomes:</p>\n<p><br />[1] We discovered and reported an interesting property of program structures by viewing dynamic program execution as a changing network. By analyzing the communication network created as a result of dynamic program execution, we found that communication patterns follow heavy-tailed distributions. In other words, a few instructions have consumers that are orders of magnitude larger than most instructions in a program. Surprisingly, these heavy-tailed distributions follow the iconic power law previously seen in man-made and natural networks. We provide empirical measurements based on the SPEC CPU2006 benchmarks to validate our findings as well as perform semantic analysis of the source code to reveal the causes of such behavior.</p>\n<p><br />[2] Detecting \"similar code\" is useful for many software and hardware engineering tasks. State-of-the-art tools and techniques can be used to detect code with similar syntactic and/or semantic features, statically (code clones) and or dynamically (simions). The dynamic methods operate at a coarse granularity of program inputs and outputs while for many software and hardware engineering tasks a finer grained view is more useful.</p>\n<p><br />We proposed the term \"code relatives\" to refer to code with similar execution behavior at a fine granularity. After introducing the concept of code relatives to the community, we then developed a new approach, DyCLINK, to detect code relatives within and across codebases.</p>\n<p>DyCLINK records instruction-level traces from sample executions, organizes the traces into instruction-level dynamic dependence graphs, and employs our specialized subgraph matching algorithm to efficiently compare the executions of candidate code relatives.</p>\n<p>In our experiments, DyCLINK analyzed 422+ million prospective subgraph matches in only 43 minutes. We compared DyCLINK to one static code clone detector from the community and to our implementation of a dynamic simion detector. The results show that DyCLINK effectively detects code relatives with a reasonable analysis time.</p>\n<p>A secondary goal has been to investigate graph matching algorithms that represent programs as graphs and then find matchings between pairs of graphs to determine how similar a given pair of programs can potentially be. This involves algorithms that estimate a graph structure from a program by observing its dynamic behavior as well as graphs that find correspondences between pairs of programs. It also involves finding synchronized correspondences between a multitude of graphs so that the matchings are consistent beyond pairwise estimates. We made progress on graph matching algorithms which was published as it resulted in significant improvements in the computer vision domain (although the technique did not help with program graphs which were the focus of this proposal).</p>\n<p><br />The interdisciplinary nature of the team helped bring together advances and applications in three different fields: Machine Learning, Software Engineering and Computer Architecture. The funding for the proposal has resulted in follow NSF proposals to further research on these topics.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/05/2017<br>\n\t\t\t\t\tModified by: L&nbsp;Sethumadhavan</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nDesigning and optimizing computer systems require deep understanding of the underlying system behavior. Historically many important observations that led to the development of essential hardware and software optimizations were driven by empirical observations about program behavior.  As such this project was aimed at discovering new phenomenon across and, within programs, in large code bases. There were two significant outcomes:\n\n\n[1] We discovered and reported an interesting property of program structures by viewing dynamic program execution as a changing network. By analyzing the communication network created as a result of dynamic program execution, we found that communication patterns follow heavy-tailed distributions. In other words, a few instructions have consumers that are orders of magnitude larger than most instructions in a program. Surprisingly, these heavy-tailed distributions follow the iconic power law previously seen in man-made and natural networks. We provide empirical measurements based on the SPEC CPU2006 benchmarks to validate our findings as well as perform semantic analysis of the source code to reveal the causes of such behavior.\n\n\n[2] Detecting \"similar code\" is useful for many software and hardware engineering tasks. State-of-the-art tools and techniques can be used to detect code with similar syntactic and/or semantic features, statically (code clones) and or dynamically (simions). The dynamic methods operate at a coarse granularity of program inputs and outputs while for many software and hardware engineering tasks a finer grained view is more useful.\n\n\nWe proposed the term \"code relatives\" to refer to code with similar execution behavior at a fine granularity. After introducing the concept of code relatives to the community, we then developed a new approach, DyCLINK, to detect code relatives within and across codebases.\n\nDyCLINK records instruction-level traces from sample executions, organizes the traces into instruction-level dynamic dependence graphs, and employs our specialized subgraph matching algorithm to efficiently compare the executions of candidate code relatives.\n\nIn our experiments, DyCLINK analyzed 422+ million prospective subgraph matches in only 43 minutes. We compared DyCLINK to one static code clone detector from the community and to our implementation of a dynamic simion detector. The results show that DyCLINK effectively detects code relatives with a reasonable analysis time.\n\nA secondary goal has been to investigate graph matching algorithms that represent programs as graphs and then find matchings between pairs of graphs to determine how similar a given pair of programs can potentially be. This involves algorithms that estimate a graph structure from a program by observing its dynamic behavior as well as graphs that find correspondences between pairs of programs. It also involves finding synchronized correspondences between a multitude of graphs so that the matchings are consistent beyond pairwise estimates. We made progress on graph matching algorithms which was published as it resulted in significant improvements in the computer vision domain (although the technique did not help with program graphs which were the focus of this proposal).\n\n\nThe interdisciplinary nature of the team helped bring together advances and applications in three different fields: Machine Learning, Software Engineering and Computer Architecture. The funding for the proposal has resulted in follow NSF proposals to further research on these topics.\n\n\t\t\t\t\tLast Modified: 04/05/2017\n\n\t\t\t\t\tSubmitted by: L Sethumadhavan"
 }
}