{
 "awd_id": "1319520",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Small: High-Level Programming Languages and Environments for Scalable Graph Processing",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2013-10-01",
 "awd_exp_date": "2016-09-30",
 "tot_intn_awd_amt": 497840.0,
 "awd_amount": 497840.0,
 "awd_min_amd_letter_date": "2013-08-26",
 "awd_max_amd_letter_date": "2016-08-23",
 "awd_abstract_narration": "Graphs and graph algorithms are fundamental to computer science.  Although historically they have not played a major role in traditional scientific computing, their importance is rapidly increasing with the emergence of informatics and data-centric applications.  Although many graph analysis tasks are performed sequentially today, problem sizes continue to grow,  necessitating the increasing use of parallel computing.  Parallel graph algorithms are already being written, but with great effort and limited code reuse.  A major issue in current ways of implementing parallel graph algorithms is the lack of performance portability: not only is it often required to reimplement algorithms on different platforms for the best performance, it is frequently also necessary to completely redesign them.\r\n\r\nTo avoid this rewriting and thus increase scientists' productivity, this project will study domain-specific programming languages allowing graph algorithms to be expressed portably, while using compilation techniques that allow the high-level expressions to achieve performance competitive with hand-written, low-level code for these algorithms.  Domain-specific languages have already shown benefit in multiple application areas.  This project will extend their benefits further in the graph domain, including to more platforms and data representations than in the past.  In particular, the project goals include finding abstractions common to the expressions of graph applications on different platforms, as well as between different applications.  To demonstrate the effectiveness of these abstractions, the project includes the creation of prototype implementations of graph algorithms for a variety of high-performance computing platforms and the evaluation of the high-level versions of algorithms against comparable low-level versions.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Andrew",
   "pi_last_name": "Lumsdaine",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Andrew Lumsdaine",
   "pi_email_addr": "al75@uw.edu",
   "nsf_id": "000420340",
   "pi_start_date": "2013-08-26",
   "pi_end_date": "2016-08-23"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Martina",
   "pi_last_name": "Barnas",
   "pi_mid_init": "M",
   "pi_sufx_name": "",
   "pi_full_name": "Martina M Barnas",
   "pi_email_addr": "mbarnas@indiana.edu",
   "nsf_id": "000683398",
   "pi_start_date": "2016-08-23",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Jeremiah",
   "pi_last_name": "Willcock",
   "pi_mid_init": "J",
   "pi_sufx_name": "",
   "pi_full_name": "Jeremiah J Willcock",
   "pi_email_addr": "jewillco@osl.iu.edu",
   "nsf_id": "000559516",
   "pi_start_date": "2013-08-26",
   "pi_end_date": "2014-09-04"
  }
 ],
 "inst": {
  "inst_name": "Indiana University",
  "inst_street_address": "107 S INDIANA AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BLOOMINGTON",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "3172783473",
  "inst_zip_code": "474057000",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "IN09",
  "org_lgl_bus_name": "TRUSTEES OF INDIANA UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "YH86RTW2YVJ4"
 },
 "perf_inst": {
  "perf_inst_name": "Indiana University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "474013654",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "IN09",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "9102",
   "pgm_ref_txt": "WOMEN, MINORITY, DISABLED, NEC"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 497840.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Graphs are a powerful conceptual tool that can be used to capture complex relationships in the real world. Graphs can be used to model social networks where the entities such as the network participants are connected through relationships such as friendship. They can be used to describe knowledge in machine learning systems (graphs capture the connections and structure of knowledge). Graphs also arise in areas such as planning and operations, where many interconnected entities interact in highly connected fashion. In short, graphs are tools necessary to capture the complexity that naturally arises in science and in many aspects of everyday world.</p>\n<p>Many graphs that arise in modern science are massive, and they require the most powerful computers to store and compute over. The focus of traditional scientific computing has been solving systems of PDEs (and the corresponding linear algebra problems). Hardware architectures, computer systems, and software platforms have evolved together to efficiently support solving these kinds of problems. Similar attention has not been devoted to efficiently solving data analytics problems. However, the executive order that created the National Strategic Computing Initiative (NSCI) specifically calls out data analytics as one of its five objectives:&nbsp;<em>Increasing coherence between the technology base used for modeling and simulation and that used for data analytic computing.</em></p>\n<p>The goal of this project is to provide unifying abstraction that addresses this objective. To achieve this, we developed models for graph computation and domain-specific languages for performance-portable graph algorithms. Such abstractions allow a single algorithm specification to apply to a wide variety of platforms and data structures. The languages are high-level yet capable of performance competitive with tuned code by expressing algorithm specifications (what the algorithm computes) independently from implementation details (how the algorithm computes its results).</p>\n<p>Some of the outcomes of this project is the Abstract Graph Machine (AGM) framework; the GL-SIMD, Datalog, and the Gizmo domain-specific languages; the pattern-based graph algorithms specification; analysis of the impact of distributed runtimes on graph algorithms; and the active messages communication framework AM++.</p>\n<p>Abstract Graph Machine (AGM), is a model for designing distributed-memory parallel graph algorithms. An algorithm designed using the AGM model starts from an initial state and goes through a series of state changes. States are changed by a &ldquo;processing function&rdquo;. The processing function takes a unit of work and returns zero or more units of work. Work units generated by the processing function are ordered using a strict weak ordering relation. The strict weak ordering divides work into ordered equivalence classes. Work in an equivalence class can be executed in parallel. Work in different equivalence classes is ordered according to the order of the equivalence classes. We show how AGM can be used to derive families of algorithms from a common high-level semantic description by modifying ordering used at different levels of a distributed machine.</p>\n<p>GL-SIMD is based on a generalized SIMD model with loose parallel synchronization, and it provides a unified framework across single-element and whole-graph expressions of algorithms. When this new model is expressed as a generic library in C++, a single algorithm implementation can be instantiated in different ways by a standard C++ compiler to apply to different data structures and models of parallelism. We used GL-SIMD to implement Datalog for graphs, a high-level language based on logic programming. We have implemented a prototype Datalog compiler &nbsp;that targets the lower-level GL-SIMD language.</p>\n<p>We also considered an abstraction for expressing graph algorithms in which the vertices and edges of the graph provide locality and communication structure and graph data are represented by property maps that associate vertices and edges to arbitrary user-defined data. Operations on the graph are expressed as patterns, which allow limited traversal of the graph and modification of property maps. Traversal is implicit and is automatically computed from the pattern's access of property map values. Patterns are declarative, but they can be used in imperative algorithms by using strategies that run in epochs. Strategies are user defined programs that apply patterns in a certain way (e.g., fixed point, once, delta-stepping), including chaining patterns in an arbitrary way..</p>\n<p>Several software artifacts were developed in this project. These artifacts are released as open source and are available to the public under non-restrictive license. We have produced several publications on different aspects of graph computation, and we have participated in standardization and development of new ideas and software interfaces. Last but not least, this project directly supported 3 PhD students over its course who completed bulk of their graduate work under this project. Master&rsquo;s and undergraduate students were supported for shorter periods of time. The project also enabled collaboration that indirectly supported graduate and undergraduate students at other institutions.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/30/2017<br>\n\t\t\t\t\tModified by: Martina&nbsp;M&nbsp;Barnas</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nGraphs are a powerful conceptual tool that can be used to capture complex relationships in the real world. Graphs can be used to model social networks where the entities such as the network participants are connected through relationships such as friendship. They can be used to describe knowledge in machine learning systems (graphs capture the connections and structure of knowledge). Graphs also arise in areas such as planning and operations, where many interconnected entities interact in highly connected fashion. In short, graphs are tools necessary to capture the complexity that naturally arises in science and in many aspects of everyday world.\n\nMany graphs that arise in modern science are massive, and they require the most powerful computers to store and compute over. The focus of traditional scientific computing has been solving systems of PDEs (and the corresponding linear algebra problems). Hardware architectures, computer systems, and software platforms have evolved together to efficiently support solving these kinds of problems. Similar attention has not been devoted to efficiently solving data analytics problems. However, the executive order that created the National Strategic Computing Initiative (NSCI) specifically calls out data analytics as one of its five objectives: Increasing coherence between the technology base used for modeling and simulation and that used for data analytic computing.\n\nThe goal of this project is to provide unifying abstraction that addresses this objective. To achieve this, we developed models for graph computation and domain-specific languages for performance-portable graph algorithms. Such abstractions allow a single algorithm specification to apply to a wide variety of platforms and data structures. The languages are high-level yet capable of performance competitive with tuned code by expressing algorithm specifications (what the algorithm computes) independently from implementation details (how the algorithm computes its results).\n\nSome of the outcomes of this project is the Abstract Graph Machine (AGM) framework; the GL-SIMD, Datalog, and the Gizmo domain-specific languages; the pattern-based graph algorithms specification; analysis of the impact of distributed runtimes on graph algorithms; and the active messages communication framework AM++.\n\nAbstract Graph Machine (AGM), is a model for designing distributed-memory parallel graph algorithms. An algorithm designed using the AGM model starts from an initial state and goes through a series of state changes. States are changed by a \"processing function\". The processing function takes a unit of work and returns zero or more units of work. Work units generated by the processing function are ordered using a strict weak ordering relation. The strict weak ordering divides work into ordered equivalence classes. Work in an equivalence class can be executed in parallel. Work in different equivalence classes is ordered according to the order of the equivalence classes. We show how AGM can be used to derive families of algorithms from a common high-level semantic description by modifying ordering used at different levels of a distributed machine.\n\nGL-SIMD is based on a generalized SIMD model with loose parallel synchronization, and it provides a unified framework across single-element and whole-graph expressions of algorithms. When this new model is expressed as a generic library in C++, a single algorithm implementation can be instantiated in different ways by a standard C++ compiler to apply to different data structures and models of parallelism. We used GL-SIMD to implement Datalog for graphs, a high-level language based on logic programming. We have implemented a prototype Datalog compiler  that targets the lower-level GL-SIMD language.\n\nWe also considered an abstraction for expressing graph algorithms in which the vertices and edges of the graph provide locality and communication structure and graph data are represented by property maps that associate vertices and edges to arbitrary user-defined data. Operations on the graph are expressed as patterns, which allow limited traversal of the graph and modification of property maps. Traversal is implicit and is automatically computed from the pattern's access of property map values. Patterns are declarative, but they can be used in imperative algorithms by using strategies that run in epochs. Strategies are user defined programs that apply patterns in a certain way (e.g., fixed point, once, delta-stepping), including chaining patterns in an arbitrary way..\n\nSeveral software artifacts were developed in this project. These artifacts are released as open source and are available to the public under non-restrictive license. We have produced several publications on different aspects of graph computation, and we have participated in standardization and development of new ideas and software interfaces. Last but not least, this project directly supported 3 PhD students over its course who completed bulk of their graduate work under this project. Master?s and undergraduate students were supported for shorter periods of time. The project also enabled collaboration that indirectly supported graduate and undergraduate students at other institutions.\n\n\t\t\t\t\tLast Modified: 01/30/2017\n\n\t\t\t\t\tSubmitted by: Martina M Barnas"
 }
}