{
 "awd_id": "1314590",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "SHF: AF: Large: Collaborative Research: Parallelism without Concurrency",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2013-07-01",
 "awd_exp_date": "2019-06-30",
 "tot_intn_awd_amt": 999458.0,
 "awd_amount": 999458.0,
 "awd_min_amd_letter_date": "2013-06-26",
 "awd_max_amd_letter_date": "2015-08-11",
 "awd_abstract_narration": "The widespread deployment of parallel machines --- from multicores to supercomputers --- has made it critical to develop simple approaches to programming them.  Significant progress has been made in simplifying parallel programming by developing programming models to support parallelism without concurrency, that is, without the nondeterminacies in the logic of programs caused by the relative and nondeterministic timing of communicating processes.  Yet most parallel programs in practice are concurrent, and hence, nondeterministic, leading to code that can only be programmed and understood by experts.  This research project aims to understand how parallel computers can be made easier to use by the vast majority of programmers by developing software technology that enables deterministic parallel computing.\r\n\r\nThe project takes a holistic view of the problem from the key perspectives of programming linguistics, software systems, algorithmic analysis, and absolute performance.  It acknowledges the reality that parallel programming cannot be fully deterministic at every level of abstraction.  It is pursuing three key strategies for dealing with concurrency: encapsulating concurrency so that it is hidden by layered abstractions at appropriate abstraction levels, avoiding concurrency by restructuring programs to employ deterministic approaches, and managing concurrency when it is impractical to either encapsulate or avoid concurrency completely. Among the specific techniques being studied are commutative building blocks, deterministic nonassociative reducers, deterministic pipelined parallelism, deterministic interfaces, and generalized race detection for detecting invariant races.  The project is developing open-source libraries, tools, and runtime extensions integrated into a multicore-software platform, as well as a problem-based benchmark suite to compare approaches.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Guy",
   "pi_last_name": "Blelloch",
   "pi_mid_init": "E",
   "pi_sufx_name": "",
   "pi_full_name": "Guy E Blelloch",
   "pi_email_addr": "guyb@cs.cmu.edu",
   "nsf_id": "000196851",
   "pi_start_date": "2013-06-26",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "Carnegie-Mellon University",
  "perf_str_addr": "5000 Forbes Avenue",
  "perf_city_name": "Pittsburgh",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "152133890",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "PA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7925",
   "pgm_ref_txt": "LARGE PROJECT"
  },
  {
   "pgm_ref_code": "7934",
   "pgm_ref_txt": "PARAL/DISTRIBUTED ALGORITHMS"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 499843.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 499615.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 0.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The high-level goal of the project was simplify the process of developing efficient parallel algorithms that run on modern multicore machines. &nbsp;We had noted that there are many issues that can make developing parallel algorithms more complicated than tradition sequential algorithms. &nbsp;One of the most challenging is that parallel/concurrent algorithms can be non-deterministic, returning different results, or running in different orders at different times. &nbsp;This can make it difficult to reason about, compose, debug, and reuse parallel algorithms. &nbsp;The focus of this grant work was on developing techniques that make programming parallel algorithms deterministic. &nbsp;The grant was joint with MIT. &nbsp;This summary focuses on the CMU portion, although some is in common.<br />To this end we developed several general techniques and many parallel algorithms based on them. &nbsp;For almost all of these we developed both theoretical results in terms of analyzing the algorithms, and practical techniques as well as code. &nbsp;One technique we developed was an approach to analyze the dependence structure of sequential algorithms to be able to show that they are in fact parallel, if false dependences are ignored. &nbsp;Based on this approach we developed efficient and simple parallel algorithms for several problems including maximum independent set, maximum matching, random permutations, tree contraction, list contraction, sorting, graph connectivity, Delaunay triangulation, fixed-dimension linear programming, nearest neighbors, and strongly connected components in a graph. &nbsp; Importantly all these algorithms are deterministic since they do the same deterministic operations as performed by the sequential algorithm.We published several papers on this topic and our code is available on github.<br />Another line of research pursued by the grant was on deterministic data structures for maintaining balanced search trees. &nbsp;Most previous work had been on parallel search trees has been on highly non-deterministic concurrent search trees. &nbsp;In this work we developed purely functional (no side effects) trees and developed efficient algorithms for a wide set of operations on such trees, including multi-insertion, intersection, union, difference, map, reduce, range queries, filter and many more. &nbsp;All operations are fully deterministic---e.g. always returning the same output trees when applied to the same input trees. &nbsp;We also support augmentation on the trees that allow keeping aggregates. &nbsp;We developed both theoretical bounds on the cost of the operations and implemented all the ideas. &nbsp;We have released the implementation as the PAM library which is available on github. &nbsp;We published four papers on the topic.<br />Finally we spent significant effort developing interfaces for efficiently developing parallel graph algorithms. &nbsp;This work started with developing Ligra (Light-weight Graph interface), and then continued with developing a version that supports compressed graphs (Ligra++), extending it to support bucketing (Julienne) and dynamic graph updates. &nbsp;Ligra has been widely used and cited. &nbsp;Using the interfaces and our other parallel tools we have developed over 20 different parallel graph algorithms and made them available as part of the Graph-Based-Benchmark-Suite (GBBS). &nbsp;In many cases our algorithms are the fastest available for multicore machines, and in some cases any machine. &nbsp; &nbsp; In all cases we have theoretical bounds on their costs. &nbsp; &nbsp;Although not all algorithms are fully deterministic, the non-determinism is encapsulated.<br />In addition to the research we developed course material for an undergraduate course we teach on parallel algorithms, we ran two tutorials on materials developed in the grant (Ligra and PAM),we published over 20 papers, trained several students, and three students at CMU got PhDs at least partially funded by the grant (one who won the ACM Dissertation Award). &nbsp; The research has had broad impact in developing techniques and code that are now being used elsewhere. &nbsp; &nbsp;The intellectual merrit includes the specific methods developed, and many ideas used in the algorithms.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 07/28/2020<br>\n\t\t\t\t\tModified by: Guy&nbsp;E&nbsp;Blelloch</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe high-level goal of the project was simplify the process of developing efficient parallel algorithms that run on modern multicore machines.  We had noted that there are many issues that can make developing parallel algorithms more complicated than tradition sequential algorithms.  One of the most challenging is that parallel/concurrent algorithms can be non-deterministic, returning different results, or running in different orders at different times.  This can make it difficult to reason about, compose, debug, and reuse parallel algorithms.  The focus of this grant work was on developing techniques that make programming parallel algorithms deterministic.  The grant was joint with MIT.  This summary focuses on the CMU portion, although some is in common.\nTo this end we developed several general techniques and many parallel algorithms based on them.  For almost all of these we developed both theoretical results in terms of analyzing the algorithms, and practical techniques as well as code.  One technique we developed was an approach to analyze the dependence structure of sequential algorithms to be able to show that they are in fact parallel, if false dependences are ignored.  Based on this approach we developed efficient and simple parallel algorithms for several problems including maximum independent set, maximum matching, random permutations, tree contraction, list contraction, sorting, graph connectivity, Delaunay triangulation, fixed-dimension linear programming, nearest neighbors, and strongly connected components in a graph.   Importantly all these algorithms are deterministic since they do the same deterministic operations as performed by the sequential algorithm.We published several papers on this topic and our code is available on github.\nAnother line of research pursued by the grant was on deterministic data structures for maintaining balanced search trees.  Most previous work had been on parallel search trees has been on highly non-deterministic concurrent search trees.  In this work we developed purely functional (no side effects) trees and developed efficient algorithms for a wide set of operations on such trees, including multi-insertion, intersection, union, difference, map, reduce, range queries, filter and many more.  All operations are fully deterministic---e.g. always returning the same output trees when applied to the same input trees.  We also support augmentation on the trees that allow keeping aggregates.  We developed both theoretical bounds on the cost of the operations and implemented all the ideas.  We have released the implementation as the PAM library which is available on github.  We published four papers on the topic.\nFinally we spent significant effort developing interfaces for efficiently developing parallel graph algorithms.  This work started with developing Ligra (Light-weight Graph interface), and then continued with developing a version that supports compressed graphs (Ligra++), extending it to support bucketing (Julienne) and dynamic graph updates.  Ligra has been widely used and cited.  Using the interfaces and our other parallel tools we have developed over 20 different parallel graph algorithms and made them available as part of the Graph-Based-Benchmark-Suite (GBBS).  In many cases our algorithms are the fastest available for multicore machines, and in some cases any machine.     In all cases we have theoretical bounds on their costs.    Although not all algorithms are fully deterministic, the non-determinism is encapsulated.\nIn addition to the research we developed course material for an undergraduate course we teach on parallel algorithms, we ran two tutorials on materials developed in the grant (Ligra and PAM),we published over 20 papers, trained several students, and three students at CMU got PhDs at least partially funded by the grant (one who won the ACM Dissertation Award).   The research has had broad impact in developing techniques and code that are now being used elsewhere.    The intellectual merrit includes the specific methods developed, and many ideas used in the algorithms.\n\n\t\t\t\t\tLast Modified: 07/28/2020\n\n\t\t\t\t\tSubmitted by: Guy E Blelloch"
 }
}