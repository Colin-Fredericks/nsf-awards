{
 "awd_id": "1318864",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative research:Complexity and feasibility for programs over coinductively-defined data",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2016-08-31",
 "tot_intn_awd_amt": 122340.0,
 "awd_amount": 122340.0,
 "awd_min_amd_letter_date": "2013-07-31",
 "awd_max_amd_letter_date": "2013-07-31",
 "awd_abstract_narration": "The typical tools of complexity theory and algorithms tend to be biased toward low-level models of computation that refer directly to bit-level representations of data.  But when programming in the large, there are layers upon layers of abstraction over any low-level details, and a key feature of modern programming is the ability to compose different abstractions without regard to such details.  Compositionality has yielded very reliable software development methodologies, in large part because the tools developed for reasoning about program correctness have developed alongside these notions of abstraction.  However, tools for reasoning about complexity have not kept pace.  The big picture of the principle investigators' research program is to develop techniques for compositional reasoning about complexity, thereby allowing for reasoning about run-time cost in all its facets of large-scale programming with methods similar to those so successfully deployed for reasoning about correctness.  The research project funded by this grant concentrates on characterizing sensible notions of feasibility for programs that use coinductively-defined data such as streams (a program that produces or processes streaming media is just the right model to have in mind) and more generally quantifying, in a machine-checkable manner, resource usage for such programs.\r\n\r\nAlthough feasibility has been well-studied in the context of finite structures, extensions to potentially infinite data structures such as streams have been somewhat piecemeal.  One facet of this research project is to develop principled notions of feasibility in this setting.  To do so, the PIs will extend tools such as logic and programming language formalisms that have previously been used to give resource-free characterizations of complexity classes for finite structures.  Such tools are already more closely tied to a compositional view of programming, and they give a jumping-off point for analyzing notions of cost in domains where the very definition of resource usage may not be so obvious.  One such tool that they developed in previous work is a framework for compositional cost analysis of higher-order programs.  This time-complexity semantics is essentially a translation of target-language programs into a domain of complexities, which encode information about evaluation and usage cost.  The translation can be automated, and so this framework not only provides a tool for reasoning compositionally about cost, but provides machine-checkable assertions about the cost of target programs.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Norman",
   "pi_last_name": "Danner",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Norman Danner",
   "pi_email_addr": "ndanner@wesleyan.edu",
   "nsf_id": "000457361",
   "pi_start_date": "2013-07-31",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Wesleyan University",
  "inst_street_address": "237 HIGH ST",
  "inst_street_address_2": "FL 3",
  "inst_city_name": "MIDDLETOWN",
  "inst_state_code": "CT",
  "inst_state_name": "Connecticut",
  "inst_phone_num": "8606853683",
  "inst_zip_code": "064593208",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "CT01",
  "org_lgl_bus_name": "WESLEYAN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "ZETJL6DKF963"
 },
 "perf_inst": {
  "perf_inst_name": "Wesleyan University",
  "perf_str_addr": "237 High St.",
  "perf_city_name": "Middletown",
  "perf_st_code": "CT",
  "perf_st_name": "Connecticut",
  "perf_zip_code": "064593208",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "CT01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 122340.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The goal of this project is to characterize notions of complexity and feasibility for programs that share data and that compute with streams of data. &nbsp;The main technical tool is the use of types to design languages in which the legal programs satisfy various complexity constraints. &nbsp;The typical target is for programs to satisfy some notion of feasibility with respect to time. &nbsp;However, while this notion is well-understood in the context of finite data without sharing, it is not when either sharing is permitted or the data itself may be infinite.</p>\n<p><br />We have extended our prior work to describe a language in which sharing of data is permitted and are close to having a complete proof that programs in this language can be executed feasibly. &nbsp;We are also close to showing that our language is complete in the sense that for any function for which there is a feasible program, there is a program in a slight extension of our language that also computes that function.</p>\n<p><br />With respect to infinite data, we have extended the language for sharing to one that allows infinite data. &nbsp;Here the notion of feasibility is even more difficult to pin down, but we are close to having done so, along with a proof that programs in our language are feasible. &nbsp;This has highlighted interesting connections between feasible computation with infinite data and topics from real analysis.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/19/2017<br>\n\t\t\t\t\tModified by: Norman&nbsp;Danner</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe goal of this project is to characterize notions of complexity and feasibility for programs that share data and that compute with streams of data.  The main technical tool is the use of types to design languages in which the legal programs satisfy various complexity constraints.  The typical target is for programs to satisfy some notion of feasibility with respect to time.  However, while this notion is well-understood in the context of finite data without sharing, it is not when either sharing is permitted or the data itself may be infinite.\n\n\nWe have extended our prior work to describe a language in which sharing of data is permitted and are close to having a complete proof that programs in this language can be executed feasibly.  We are also close to showing that our language is complete in the sense that for any function for which there is a feasible program, there is a program in a slight extension of our language that also computes that function.\n\n\nWith respect to infinite data, we have extended the language for sharing to one that allows infinite data.  Here the notion of feasibility is even more difficult to pin down, but we are close to having done so, along with a proof that programs in our language are feasible.  This has highlighted interesting connections between feasible computation with infinite data and topics from real analysis.\n\n \n\n \n\n \n\n\t\t\t\t\tLast Modified: 01/19/2017\n\n\t\t\t\t\tSubmitted by: Norman Danner"
 }
}