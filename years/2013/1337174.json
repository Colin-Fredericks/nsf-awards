{
 "awd_id": "1337174",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: CLCCA: Improving Parallel Program Reliability Through Novel Approaches to Precise Dynamic Data Race Detection",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Yuanyuan Yang",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2018-08-31",
 "tot_intn_awd_amt": 700000.0,
 "awd_amount": 700000.0,
 "awd_min_amd_letter_date": "2013-08-24",
 "awd_max_amd_letter_date": "2013-08-24",
 "awd_abstract_narration": "The ubiquity of multi-core processors in everything from servers to\r\nsmartphones has demanded a similar prevalence of multi-threaded\r\nprograms to take advantage of multiple cores. Unfortunately, writing\r\nmulti-threaded code is still in the Wild West era of error-prone manual\r\nsynchronization, unchecked concurrency bugs, and undefined semantics.\r\nOne common symptom of an error in a multi-threaded program is a data\r\nrace. Data races arise when a program performs concurrent updates to\r\nsome location without synchronization. Automatically detecting data\r\nraces during program execution enforces strong safety properties for\r\nmulti-threaded programs. While techniques for data race detection exist\r\nthey slow program execution too much to be viable for always-on\r\nenforcement.\r\n\r\nTo make always-on detection of data races practical, the project aims\r\nto develop new algorithms, language extensions, runtime systems, and\r\nhardware support to improve the efficiency of data race detection. The\r\nresearch includes validation of these techniques via formal proofs,\r\nexperiments with multi-threaded benchmark suites, and detailed hardware\r\nsimulation. The researchers plan to openly distribute the systems\r\nbuilt for this project to facilitate examination by other researchers\r\nand integrate the research results into the computer architecture\r\ncourses they teach. If successful, the proposed technology will\r\nimprove the safety and quality of the vast amounts of multi-threaded\r\ncode running on today's and tomorrow?s multi-core devices.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Joseph",
   "pi_last_name": "Devietti",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Joseph Devietti",
   "pi_email_addr": "devietti@cis.upenn.edu",
   "nsf_id": "000642229",
   "pi_start_date": "2013-08-24",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Stephan",
   "pi_last_name": "Zdancewic",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Stephan A Zdancewic",
   "pi_email_addr": "stevez@cis.upenn.edu",
   "nsf_id": "000220116",
   "pi_start_date": "2013-08-24",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Milo",
   "pi_last_name": "Martin",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Milo Martin",
   "pi_email_addr": "milom@cis.upenn.edu",
   "nsf_id": "000383219",
   "pi_start_date": "2013-08-24",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Pennsylvania",
  "inst_street_address": "3451 WALNUT ST STE 440A",
  "inst_street_address_2": "",
  "inst_city_name": "PHILADELPHIA",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "2158987293",
  "inst_zip_code": "191046205",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "PA03",
  "org_lgl_bus_name": "TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE",
  "org_prnt_uei_num": "GM1XX56LEP58",
  "org_uei_num": "GM1XX56LEP58"
 },
 "perf_inst": {
  "perf_inst_name": "University of Pennsylvania",
  "perf_str_addr": "3451 Walnu Street P-221",
  "perf_city_name": "Philadelphia",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "191046205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "PA03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": null,
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 700000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Humans often struggle with juggling multiple tasks at one time. Software developers are no exception, though they are frequently asked to write programs that perform multiple tasks at once so as to take advantage of today's ubiquitous multicore computer processors. We refer to a computer program that does multiple computations at the same time as a <em>parallel</em> computer program. Errors can arise from incorrectly managing the parallelism within a program, similar to having two chefs trying to use a single pan at the same time -- neither of their dishes&nbsp;are going to come out as intended.</p>\n<p>Data-race detection is a technique for identifying these problematic uses of parallelism within a program. Data-race detection acts like a supervisor in the kitchen, making sure that each chef uses their own pans and not someone else's. While data-race detection can identify bugs in parallel programs, it is expensive to do so. Our project seeks to make data-race detection run faster, so that more people will use it to find their software bugs.</p>\n<p>Our work in this project has followed three main directions. First, we have shown how to make data-race detection faster, without sacrificing precision, for parallel programs running on&nbsp;today's multicore processors. Second, we proposed the first precise and scalable approaches to data-race detection for programs that run on graphics cards (also called GPUs). GPU programs espouse parallelism on a massive scale, often performing millions of computations in parallel, thus increasing the scope for parallelism bugs. Techniques that work for CPU programs struggle to cope with the scale of GPU&nbsp;parallelism, which led us to invent new approaches. Finally, we also evaluated the use of custom processors with hardware support for data-race detection, to make data-race detection much faster than pure-software approaches. With published papers in each of these areas, we have advanced the state-of-the-art in data-race detection and made it easier to find and fix bugs in parallel programs.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2018<br>\n\t\t\t\t\tModified by: Joseph&nbsp;Devietti</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nHumans often struggle with juggling multiple tasks at one time. Software developers are no exception, though they are frequently asked to write programs that perform multiple tasks at once so as to take advantage of today's ubiquitous multicore computer processors. We refer to a computer program that does multiple computations at the same time as a parallel computer program. Errors can arise from incorrectly managing the parallelism within a program, similar to having two chefs trying to use a single pan at the same time -- neither of their dishes are going to come out as intended.\n\nData-race detection is a technique for identifying these problematic uses of parallelism within a program. Data-race detection acts like a supervisor in the kitchen, making sure that each chef uses their own pans and not someone else's. While data-race detection can identify bugs in parallel programs, it is expensive to do so. Our project seeks to make data-race detection run faster, so that more people will use it to find their software bugs.\n\nOur work in this project has followed three main directions. First, we have shown how to make data-race detection faster, without sacrificing precision, for parallel programs running on today's multicore processors. Second, we proposed the first precise and scalable approaches to data-race detection for programs that run on graphics cards (also called GPUs). GPU programs espouse parallelism on a massive scale, often performing millions of computations in parallel, thus increasing the scope for parallelism bugs. Techniques that work for CPU programs struggle to cope with the scale of GPU parallelism, which led us to invent new approaches. Finally, we also evaluated the use of custom processors with hardware support for data-race detection, to make data-race detection much faster than pure-software approaches. With published papers in each of these areas, we have advanced the state-of-the-art in data-race detection and made it easier to find and fix bugs in parallel programs.\n\n\t\t\t\t\tLast Modified: 11/30/2018\n\n\t\t\t\t\tSubmitted by: Joseph Devietti"
 }
}