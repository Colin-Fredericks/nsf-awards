{
 "awd_id": "1255949",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "Collaborative Research: Localized, Layered Formal Hardware/Software Resilience Methods",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927843",
 "po_email": "sabasu@nsf.gov",
 "po_sign_block_name": "Sankar Basu",
 "awd_eff_date": "2013-04-01",
 "awd_exp_date": "2016-03-31",
 "tot_intn_awd_amt": 94500.0,
 "awd_amount": 94500.0,
 "awd_min_amd_letter_date": "2013-02-04",
 "awd_max_amd_letter_date": "2015-06-16",
 "awd_abstract_narration": "The drive for increased performance and functionality has pushed computer chips to their physical limits of power/energy and reliability. Future computing systems are likely to suffer from high fault rates, undermining their programmability and usability. This research project will leverage existing techniques and invent new techniques to detect, isolate, and recover from faults and to ensure overall system resilience, with minimal impact on performance. The project taps into the rich body of past work on formal methods, which have been successful in finding logical errors in systems. Newly developed formal methods will focus on resilience enhancement. The project will also explore the inherent trade-offs between performance, power, and resilience. The project will develop an extensible platform for empirical evaluation of resilience methods. This platform will be comprised of programmable chips and accompanying software components.\r\n\r\nThis project will foster the development of new system design methods which take reliability into account. It will help fill a serious void in readily usable infrastructures for resiliency studies in the realm of parallel systems by developing and releasing tools for evaluating the methods.  The project will also develop and release rigorously specified resilience-aware system interfaces. The project emphasizes student training, including student recruitment and introduction of new classes that are integrated with resilience research.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Pedro",
   "pi_last_name": "Diniz",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Pedro Diniz",
   "pi_email_addr": "pedro@isi.edu",
   "nsf_id": "000489530",
   "pi_start_date": "2013-02-04",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Southern California",
  "inst_street_address": "3720 S FLOWER ST FL 3",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "2137407762",
  "inst_zip_code": "90033",
  "inst_country_name": "United States",
  "cong_dist_code": "34",
  "st_cong_dist_code": "CA34",
  "org_lgl_bus_name": "UNIVERSITY OF SOUTHERN CALIFORNIA",
  "org_prnt_uei_num": "",
  "org_uei_num": "G88KLJR3KYT5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Southern California",
  "perf_str_addr": "4676 Admiralty Way, Suite 1001",
  "perf_city_name": "Marina del Rey",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "902926611",
  "perf_ctry_code": "US",
  "perf_cong_dist": "36",
  "perf_st_cong_dist": "CA36",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "808100",
   "pgm_ele_name": "Failure Resistant Systems(FRS)"
  }
 ],
 "pgm_ref": null,
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 63000.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 15750.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 15750.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><strong>&nbsp;</strong>This research addresses the issues of silent data corruption that is permeating with increasingly acuteness today&rsquo;s computing infrastructures, from the occasional reboot of your desktop to the crash of your mobile device app. While in many cases there are built-in inexpensive mechanisms to deal with errors such as error correction codes are the memory level, at the core of the computing devices &ndash; the CPU &ndash; the traditional approaches to deal with error have been hardware redundancy.</p>\n<p>The replication of hardware to performance essentially the same task is expensive in particular in terms of energy &ndash; an increasingly precious commodity for both embedded devices as well as high-end computing systems. To address this issue, we have leverage the judicious use of predicates (logic expressions that have a true or false value) that should hold at specific execution points of the program and which are consistent to the correct execution of the software code. If false, such predicates would indicate that an error that was not detected by the underlying hardware error detection mechanism, indeed occurred and the computation should either halt or be redirected to an amelioration procedure.</p>\n<p>Rather than relying on hardware replication, we have explored the development of a specific predicate evaluation unit, to be coupled with the core processor on an embedded devices and be configured according to the needs of the specific predicates to be evaluated for each program. This, approach had the promise of substantial energy savings while allowing for a software-controlled definition of the selected predicates at each execution point and thus ensuring a good coverage of the types of errors.</p>\n<p>&nbsp;We have carried out research in designing, implementing and evaluation a hardware predicate unit and coupled it with a MIPS 32-bit soft-core processor core (a widely popular and available processor) implementation on configurable hardware (a Field-Programmable Gate-Array or FPGA). This predicate unit directly monitors the state of the MIPS processor by inspecting its registers and evaluates in hardware the specific predicate. We evaluated this approach in the context of a selected set of computational kernel codes written in a popular programming language, the C programming language, pervasive in the context of embedded devices. Despite, the very low execution time and silicon area space overhead, and the ability to effectively evaluate the predicates in hardware, these experiments reveal that the interactions with the compiler&rsquo;s internals when targeting this augmented resilient MIPS processor core was sophisticated and required some non-trivial investment from the compiler&rsquo;s implementation. Two scholarly publications produced as the result of this research describe in details these findings. In addition, we have also developed a set of parameterizable implementations of the predicate evaluation unit in a hardware description (Verilog) that can be integrated with the Verilog description of the MIPS 32-bit core itself as made available by the University of Utah (a partner in this research project).</p>\n<p>Last, but not the least, this project also served as the vehicle for the training of one Computer Science graduate student, Ms. Setareh Nasihati who contributed to the development of the predicate evaluation units in Verilog and supported the compiler development using LLVM.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/18/2016<br>\n\t\t\t\t\tModified by: Pedro&nbsp;Diniz</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n This research addresses the issues of silent data corruption that is permeating with increasingly acuteness today\u00c6s computing infrastructures, from the occasional reboot of your desktop to the crash of your mobile device app. While in many cases there are built-in inexpensive mechanisms to deal with errors such as error correction codes are the memory level, at the core of the computing devices &ndash; the CPU &ndash; the traditional approaches to deal with error have been hardware redundancy.\n\nThe replication of hardware to performance essentially the same task is expensive in particular in terms of energy &ndash; an increasingly precious commodity for both embedded devices as well as high-end computing systems. To address this issue, we have leverage the judicious use of predicates (logic expressions that have a true or false value) that should hold at specific execution points of the program and which are consistent to the correct execution of the software code. If false, such predicates would indicate that an error that was not detected by the underlying hardware error detection mechanism, indeed occurred and the computation should either halt or be redirected to an amelioration procedure.\n\nRather than relying on hardware replication, we have explored the development of a specific predicate evaluation unit, to be coupled with the core processor on an embedded devices and be configured according to the needs of the specific predicates to be evaluated for each program. This, approach had the promise of substantial energy savings while allowing for a software-controlled definition of the selected predicates at each execution point and thus ensuring a good coverage of the types of errors.\n\n We have carried out research in designing, implementing and evaluation a hardware predicate unit and coupled it with a MIPS 32-bit soft-core processor core (a widely popular and available processor) implementation on configurable hardware (a Field-Programmable Gate-Array or FPGA). This predicate unit directly monitors the state of the MIPS processor by inspecting its registers and evaluates in hardware the specific predicate. We evaluated this approach in the context of a selected set of computational kernel codes written in a popular programming language, the C programming language, pervasive in the context of embedded devices. Despite, the very low execution time and silicon area space overhead, and the ability to effectively evaluate the predicates in hardware, these experiments reveal that the interactions with the compiler\u00c6s internals when targeting this augmented resilient MIPS processor core was sophisticated and required some non-trivial investment from the compiler\u00c6s implementation. Two scholarly publications produced as the result of this research describe in details these findings. In addition, we have also developed a set of parameterizable implementations of the predicate evaluation unit in a hardware description (Verilog) that can be integrated with the Verilog description of the MIPS 32-bit core itself as made available by the University of Utah (a partner in this research project).\n\nLast, but not the least, this project also served as the vehicle for the training of one Computer Science graduate student, Ms. Setareh Nasihati who contributed to the development of the predicate evaluation units in Verilog and supported the compiler development using LLVM.\n\n\t\t\t\t\tLast Modified: 04/18/2016\n\n\t\t\t\t\tSubmitted by: Pedro Diniz"
 }
}