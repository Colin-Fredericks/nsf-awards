{
 "awd_id": "1318191",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: VeriF-OPT, a Verification Framework for Optimizations and Program Transformations",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 466000.0,
 "awd_amount": 466000.0,
 "awd_min_amd_letter_date": "2013-06-27",
 "awd_max_amd_letter_date": "2013-06-27",
 "awd_abstract_narration": "The modern world runs on software, and software runs on compilers, programs that bridge the gap between human-readable high-level programming languages and the low-level machine code that computers execute. Every year, millions of dollars and countless hours of effort go into ensuring that software is correct and reliable. However, the bulk of this analysis is applied at the high level, leaving the compiler as a potential weak link in the verification chain. Errors in a compiler are particularly insidious because they are difficult to isolate and reproduce, and potentially affect every program processed by that compiler.  The VeriF-OPT project aims to make it feasible to verify compilers by providing a user-friendly and reusable framework for constructing rigorous mathematical proofs of compiler correctness, thus removing a source of error that potentially undermines the verification of high-level programs.\r\n\r\nThe VeriF-OPT project will use formal methods tools, including the Isabelle proof assistant and the K Framework for programming language specification, to develop a general, reusable framework for specifying and verifying compilers for any language, lowering the high barrier to entry for compiler verification. The framework will be designed to work particularly well for optimizations for parallel programs, which are often more complex and poorly understood than their sequential counterparts.  The core components of the framework are a domain-specific language for the specification of program transformations, an executable semantics for this language that allows compiler designers to test and refine their designs before committing to verification, and a formal semantics for the language that serves as the basis for proofs of correctness.  Every verification in VeriF-OPT will produce code fragments, lemmas, and other intermediate results that, thanks to the modular design of the framework, can be reused in future projects. By helping compiler designers, testers, and verifiers work together to create compilers with strong guarantees of correctness, the project will raise the standard for software reliability and help prevent costly and dangerous failures due to undetected and unexpected bugs.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Elsa",
   "pi_last_name": "Gunter",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Elsa Gunter",
   "pi_email_addr": "egunter@cs.uiuc.edu",
   "nsf_id": "000101665",
   "pi_start_date": "2013-06-27",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Grigore",
   "pi_last_name": "Rosu",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Grigore Rosu",
   "pi_email_addr": "grosu@illinois.edu",
   "nsf_id": "000488532",
   "pi_start_date": "2013-06-27",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Illinois at Urbana-Champaign",
  "inst_street_address": "506 S WRIGHT ST",
  "inst_street_address_2": "",
  "inst_city_name": "URBANA",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "2173332187",
  "inst_zip_code": "618013620",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "IL13",
  "org_lgl_bus_name": "UNIVERSITY OF ILLINOIS",
  "org_prnt_uei_num": "V2PHZ2CSCH63",
  "org_uei_num": "Y8CWNJRCNN91"
 },
 "perf_inst": {
  "perf_inst_name": "University of Illinois at Urbana-Champaign",
  "perf_str_addr": "1901 SOUTH FIRST ST.",
  "perf_city_name": "CHAMPAIGN",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "618207473",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "IL13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 466000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>One of the most fundamental problems in programming is that of compiler correctness. &nbsp;Suppose we have a source program, written in &nbsp;a human-friendly programming language, where that program has some desirable property, such as safety or correctness. &nbsp;After the program has been compiled (translated) into a low-level language, such as machine code for some specific computer architecture, does it still have that property? &nbsp;To guarantee this, we need to know that the compiler's translation is faithful to the intended meaning of the original language in which the program was written. &nbsp;Unfortunately, compiler errors do exist, including ones that effect program outcomes and they are particularly insidious because they are difficult to isolate, may be externally noticeable in only a few select cases, potentially affect every program processed by that compiler, and are both more likely to occur and more difficult to detect when dealing with parallel programs. &nbsp;Finding such errors requires considerable effort to detect and resolve. &nbsp;The phases of a compiler where it tries to improve the efficiency of the original program (compiler optimizations) are extremely important for modern computing, but also are particularly error-prone, especially when compiling code to be run with pieces running simultaneously on multiple computer processors (parallel programs).</p>\n<p>Our contribution to the solution of this problem is a framework for <span>verifying</span> that compiler optimizations preserve the desired functional behavior of code. &nbsp;This framework has two <span>foci</span>. The first is the expression and validation of compiler optimizations. &nbsp;Did the optimization produce the translated program expected? The second is the expression and proof of correctness the optimization. &nbsp;Does the optimization always produce translated programs that behave as the original programs were designed to? &nbsp;For the first part, our framework provides an expressive language for the specification of optimizations and program transformations; semantics (meaning) for this language in an interactive theorem prover, providing a basis for formal reasoning about optimizations; and a means for directly executing optimizations expressed in this specification language, allowing compiler designers to test and refine their designs before investing in the labor-intensive process of verification. &nbsp;For the second, our framework integrates an existing system for the executable specification of programming languages (i.e. you can run code in the language directly using the language specification) with the same interactive theorem prover. &nbsp;This second part allows the compiler writer to formally prove that the optimizations specified in the first part do not alter the meaning of the programs they translate.</p>\n<p>Using this system, we have been able to prove that a collection of elementary, local optimizations for a commonly used compiler framework preserve a broad collection of program properties. We have further shown that composing these elementary optimization in our framework maintains the preservation of these program properties. &nbsp;As a proof-of-concept, we have expressed relatively complex optimizations such as loop peeling and partial redundant code elimination as a composition of these elementary local optimizations, and derived correctness properties of the complex optimizations as a direct consequence of the correctness properties of the elementary ones.</p>\n<p>Part of the impact of this project was the contribution to the technical training of students for the workforce. &nbsp;One graduate student completed his PhD while supported by this grant, and now has a position in an assistant professor at an American research university, where he continues to teach and train graduate students in the area of this grant. &nbsp;Two additional graduate students, one of whom is a female, have been funded, and were between half a year and two years away from completing their <span>PhDs</span> on work related to this grant at the end of this grant. &nbsp;One post-doc received partial summer funding on this grant. &nbsp;He has subsequently taken a position as a research assistant professor at an American research university. &nbsp;Three graduate students, including one female, did projects as a part of their <span>Master's</span> degrees using the tools built in the project. &nbsp;Five undergraduate students, including two females, wrote <span>bachelor's</span> theses based on projects using the tools and theories developed in this project, including the design, development, testing and verification of basic program transformations.</p>\n<p>This Project Outcomes Report for the General Public is displayed verbatim as submitted by the Principal Investigator (PI) for this award. Any opinions, findings, and conclusions or recommendations expressed in this Report are those of the PI and do not necessarily reflect the views of the National Science Foundation; NSF has not approved or endorsed its content.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 06/02/2019<br>\n\t\t\t\t\tModified by: Elsa&nbsp;Gunter</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nOne of the most fundamental problems in programming is that of compiler correctness.  Suppose we have a source program, written in  a human-friendly programming language, where that program has some desirable property, such as safety or correctness.  After the program has been compiled (translated) into a low-level language, such as machine code for some specific computer architecture, does it still have that property?  To guarantee this, we need to know that the compiler's translation is faithful to the intended meaning of the original language in which the program was written.  Unfortunately, compiler errors do exist, including ones that effect program outcomes and they are particularly insidious because they are difficult to isolate, may be externally noticeable in only a few select cases, potentially affect every program processed by that compiler, and are both more likely to occur and more difficult to detect when dealing with parallel programs.  Finding such errors requires considerable effort to detect and resolve.  The phases of a compiler where it tries to improve the efficiency of the original program (compiler optimizations) are extremely important for modern computing, but also are particularly error-prone, especially when compiling code to be run with pieces running simultaneously on multiple computer processors (parallel programs).\n\nOur contribution to the solution of this problem is a framework for verifying that compiler optimizations preserve the desired functional behavior of code.  This framework has two foci. The first is the expression and validation of compiler optimizations.  Did the optimization produce the translated program expected? The second is the expression and proof of correctness the optimization.  Does the optimization always produce translated programs that behave as the original programs were designed to?  For the first part, our framework provides an expressive language for the specification of optimizations and program transformations; semantics (meaning) for this language in an interactive theorem prover, providing a basis for formal reasoning about optimizations; and a means for directly executing optimizations expressed in this specification language, allowing compiler designers to test and refine their designs before investing in the labor-intensive process of verification.  For the second, our framework integrates an existing system for the executable specification of programming languages (i.e. you can run code in the language directly using the language specification) with the same interactive theorem prover.  This second part allows the compiler writer to formally prove that the optimizations specified in the first part do not alter the meaning of the programs they translate.\n\nUsing this system, we have been able to prove that a collection of elementary, local optimizations for a commonly used compiler framework preserve a broad collection of program properties. We have further shown that composing these elementary optimization in our framework maintains the preservation of these program properties.  As a proof-of-concept, we have expressed relatively complex optimizations such as loop peeling and partial redundant code elimination as a composition of these elementary local optimizations, and derived correctness properties of the complex optimizations as a direct consequence of the correctness properties of the elementary ones.\n\nPart of the impact of this project was the contribution to the technical training of students for the workforce.  One graduate student completed his PhD while supported by this grant, and now has a position in an assistant professor at an American research university, where he continues to teach and train graduate students in the area of this grant.  Two additional graduate students, one of whom is a female, have been funded, and were between half a year and two years away from completing their PhDs on work related to this grant at the end of this grant.  One post-doc received partial summer funding on this grant.  He has subsequently taken a position as a research assistant professor at an American research university.  Three graduate students, including one female, did projects as a part of their Master's degrees using the tools built in the project.  Five undergraduate students, including two females, wrote bachelor's theses based on projects using the tools and theories developed in this project, including the design, development, testing and verification of basic program transformations.\n\nThis Project Outcomes Report for the General Public is displayed verbatim as submitted by the Principal Investigator (PI) for this award. Any opinions, findings, and conclusions or recommendations expressed in this Report are those of the PI and do not necessarily reflect the views of the National Science Foundation; NSF has not approved or endorsed its content.\n\n \n\n\t\t\t\t\tLast Modified: 06/02/2019\n\n\t\t\t\t\tSubmitted by: Elsa Gunter"
 }
}