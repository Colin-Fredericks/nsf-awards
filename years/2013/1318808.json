{
 "awd_id": "1318808",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small:  Reverse Engineering Variability Implementations",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 400797.0,
 "awd_amount": 419522.0,
 "awd_min_amd_letter_date": "2013-06-24",
 "awd_max_amd_letter_date": "2017-03-31",
 "awd_abstract_narration": "Variability in software systems is very common and important to tailor\r\nthe system to user needs and to use the system flexibly in different\r\ncontexts without developing a new system from scratch for each context.\r\nFor example, embedded systems with resource constraints,\r\nhigh-performance optimizations, and end-user customizable systems all\r\nexploit variability. However variability in software systems creates a\r\nfundamental tension between (a) reuse and (b) development and\r\nmaintenance costs. On the one hand, planning variability upfront enables\r\nsystematic  reuse and promises to significantly reduce development\r\neffort, costs, and time to market. On the other hand, variability\r\nrequires an upfront investment and causes long-term maintenance costs,\r\nbecause variations give rise to an exponential number of configurations\r\n  with potentially intricate interactions. Especially if introduced in\r\nan ad-hoc fashion and not managed  appropriately, variability can\r\nincrease maintenance costs to a level that outweighs the expected\r\nbenefits.  This research develops and integrates reverse-engineering\r\ntechniques for variability to lower upfront investments for variability\r\nand to reduce the costs of long-term maintenance caused by accidental\r\ncomplexity of existing ad-hoc variability implementations.\r\n\r\nThis project revisits how variable and reusable software is implemented\r\nby encouraging lightweight and incremental implementation mechanisms and\r\nproviding migration mechanisms for all ad-hoc legacy implementations\r\ncommon in practice, including conditional compilation (#ifdef),\r\nbranches, clones, textual  patches, command-line parameters, and\r\nplug-ins.  It integrates research from different communities, including\r\nproduct- line analysis, static analysis, refactoring, concern location,\r\nand architecture  recovery toward a common goal of reverse engineering\r\nvariability implementations . This  integration will allow scaling\r\nresearch and practice of analyzing and migrating variability from core\r\ncalculi  to real-world systems of the size and complexity of the Linux\r\nkernel.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Christian",
   "pi_last_name": "Kastner",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Christian Kastner",
   "pi_email_addr": "kaestner@cmu.edu",
   "nsf_id": "000634835",
   "pi_start_date": "2013-06-24",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Carnegie-Mellon University",
  "inst_street_address": "5000 FORBES AVE",
  "inst_street_address_2": "",
  "inst_city_name": "PITTSBURGH",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "4122688746",
  "inst_zip_code": "152133815",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "PA12",
  "org_lgl_bus_name": "CARNEGIE MELLON UNIVERSITY",
  "org_prnt_uei_num": "U3NKNFLNQ613",
  "org_uei_num": "U3NKNFLNQ613"
 },
 "perf_inst": {
  "perf_inst_name": "Carnegie-Mellon University",
  "perf_str_addr": "5000 Forbes Avenue",
  "perf_city_name": "Pittsburgh",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "152133890",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "PA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7798",
   "pgm_ref_txt": "SOFTWARE & HARDWARE FOUNDATION"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 400797.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 9200.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 9525.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-c5eb11a5-1d1a-af3f-8be8-38ea199b114a\">\n<p dir=\"ltr\"><span>Variability in software systems is very common and important to tailor the system to user needs and to use the system flexibly in different contexts without developing a new system from scratch for each context. For example, embedded systems with resource constraints, high-performance optimizations, and end-user customizable systems all exploit variability. However variability in software systems creates a fundamental tension between (a) reuse and (b) development and maintenance costs. Especially if introduced in an ad-hoc fashion and not managed appropriately, variability can increase maintenance costs to a level that outweighs the expected benefits. This research developed and integrated reverse-engineering techniques for variability to lower upfront investments for variability and to reduce the costs of long-term maintenance caused by accidental complexity of existing ad-hoc variability implementations.</span></p>\n<br />\n<p dir=\"ltr\"><span>This research developed reverse engineering techniques to recover and understand variability implementations. It focused on multiple forms of variability implementations that are common in practice and easy to use initially but known to cause long-term maintenance costs.</span></p>\n<br />\n<p dir=\"ltr\"><span>First, this research developed an infrastructure to detect which code fragments are affected by load-time configuration options, such as command-line parameters and configuration files. While load-time options are easy to use, loaded and propagated with normal programming language constructs, developers quickly run into challenges understanding how the larger implementation may depend on these options and how options interact (these difficulties were also confirmed in a study as part of this research). This research developed a technique, based on static taint tracking, to track load-time configuration options to where they are used in the program and shows results to developers in terms of a configuration map. The research exploits insights about how configuration options are used in practice, which differs from normal program variables and simplifies the analysis. An evaluation shows that the system can accurately track configuration options and their values and provide insights into the variability of a system. A variant of this approach was also used to support understanding and migrating variability in build systems.</span></p>\n<br />\n<p dir=\"ltr\"><span>Second, this research extracted configuration constraints among configuration options from technical artifacts. In a nutshell, it identifies heuristics and technical constraints that can identify when two options should not be used together or when multiple options have dependencies. Extracting these constraints provides useful insights and documentation for both developers and users of the system. An evaluation showed that a significant number of constraints that developers previously documented manually could be recovered with this approach.</span></p>\n<br />\n<p dir=\"ltr\"><span>Third, this research developed technique to discover features within projects that develop variability through clown-and-own strategies. Clone-and-own is the industry term for developing variants of a system by copying and modifying a previous system without tracking of changes across variants. Again as other ad-hoc techniques, clone and own is easy and cheap in the short term, but leads to significant potential long-term maintenance costs. This research used static dependency graphs, community detection mechanisms, and information-retrieval techniques to identify and label features within changes in a copied system, thus allowing developers to monitor multiple copies and quickly gain an overview of their evolution, aggregated in terms of cohesive labeled changes rather than low-level differences. An evaluation shows that the system is effective in identifying features and provides new insights to developers about developments in variants of a project.</span></p>\n<br />\n<p dir=\"ltr\"><span>Overall, this research contributed to understanding and reverse engineering various common variability-implementation techniques that often cause significant complexities in the development and maintenance process. These results have been broadly disseminated in research publications. These techniques contribute to lowering costs in common software engineering techniques, disseminate good practices of variability use, and allow developers to make better development decisions and better scale the development of complex systems.</span></p>\n<div><span><br /></span></div>\n</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/03/2017<br>\n\t\t\t\t\tModified by: Christian&nbsp;Kastner</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nVariability in software systems is very common and important to tailor the system to user needs and to use the system flexibly in different contexts without developing a new system from scratch for each context. For example, embedded systems with resource constraints, high-performance optimizations, and end-user customizable systems all exploit variability. However variability in software systems creates a fundamental tension between (a) reuse and (b) development and maintenance costs. Especially if introduced in an ad-hoc fashion and not managed appropriately, variability can increase maintenance costs to a level that outweighs the expected benefits. This research developed and integrated reverse-engineering techniques for variability to lower upfront investments for variability and to reduce the costs of long-term maintenance caused by accidental complexity of existing ad-hoc variability implementations.\n\n\nThis research developed reverse engineering techniques to recover and understand variability implementations. It focused on multiple forms of variability implementations that are common in practice and easy to use initially but known to cause long-term maintenance costs.\n\n\nFirst, this research developed an infrastructure to detect which code fragments are affected by load-time configuration options, such as command-line parameters and configuration files. While load-time options are easy to use, loaded and propagated with normal programming language constructs, developers quickly run into challenges understanding how the larger implementation may depend on these options and how options interact (these difficulties were also confirmed in a study as part of this research). This research developed a technique, based on static taint tracking, to track load-time configuration options to where they are used in the program and shows results to developers in terms of a configuration map. The research exploits insights about how configuration options are used in practice, which differs from normal program variables and simplifies the analysis. An evaluation shows that the system can accurately track configuration options and their values and provide insights into the variability of a system. A variant of this approach was also used to support understanding and migrating variability in build systems.\n\n\nSecond, this research extracted configuration constraints among configuration options from technical artifacts. In a nutshell, it identifies heuristics and technical constraints that can identify when two options should not be used together or when multiple options have dependencies. Extracting these constraints provides useful insights and documentation for both developers and users of the system. An evaluation showed that a significant number of constraints that developers previously documented manually could be recovered with this approach.\n\n\nThird, this research developed technique to discover features within projects that develop variability through clown-and-own strategies. Clone-and-own is the industry term for developing variants of a system by copying and modifying a previous system without tracking of changes across variants. Again as other ad-hoc techniques, clone and own is easy and cheap in the short term, but leads to significant potential long-term maintenance costs. This research used static dependency graphs, community detection mechanisms, and information-retrieval techniques to identify and label features within changes in a copied system, thus allowing developers to monitor multiple copies and quickly gain an overview of their evolution, aggregated in terms of cohesive labeled changes rather than low-level differences. An evaluation shows that the system is effective in identifying features and provides new insights to developers about developments in variants of a project.\n\n\nOverall, this research contributed to understanding and reverse engineering various common variability-implementation techniques that often cause significant complexities in the development and maintenance process. These results have been broadly disseminated in research publications. These techniques contribute to lowering costs in common software engineering techniques, disseminate good practices of variability use, and allow developers to make better development decisions and better scale the development of complex systems.\n\n\n\n\n \n\n\t\t\t\t\tLast Modified: 12/03/2017\n\n\t\t\t\t\tSubmitted by: Christian Kastner"
 }
}