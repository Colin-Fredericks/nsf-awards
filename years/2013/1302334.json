{
 "awd_id": "1302334",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Medium: Collaborative Research: Workload-Aware Storage Architectures for Optimal Performance and Energy Efficiency",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2013-10-01",
 "awd_exp_date": "2017-09-30",
 "tot_intn_awd_amt": 306077.0,
 "awd_amount": 306077.0,
 "awd_min_amd_letter_date": "2013-09-09",
 "awd_max_amd_letter_date": "2013-09-09",
 "awd_abstract_narration": "The most significant performance and energy bottlenecks in a computer are\r\noften caused by the storage system, because the gap between storage device\r\nand CPU speeds is greater than in any other part of the machine.  Big data\r\nand new storage media only make things worse, because today's systems are\r\nstill optimized for legacy workloads and hard disks.  The team at Stony\r\nBrook University, Harvard University, and Harvey Mudd College has shown that\r\nlarge systems are poorly optimized, resulting in waste that increases\r\ncomputing costs, slows scientific progress, and jeopardizes the nation's\r\nenergy independence.\r\n\r\nFirst, the team is examining modern workloads running on a variety of\r\nplatforms, including individual computers, large compute farms, and a\r\nnext-generation infrastructure, such as Stony Brook's Reality Deck, a\r\nmassive gigapixel visualization facility.  These workloads produce combined\r\nperformance and energy traces that are being released to the community.\r\n\r\nSecond, the team is applying techniques such as statistical feature\r\nextraction, Hidden Markov Modeling, data-mining, and conditional likelihood\r\nmaximization to analyze these data sets and traces.  The Reality Deck is\r\nused to visualize the resulting multi-dimensional performance/energy data\r\nsets.  The team's analyses reveal fundamental phenomena and principles that\r\ninform future designs.\r\n\r\nThird, the findings from the first two efforts are being combined to develop\r\nnew storage architectures that best balance performance and energy under\r\ndifferent workloads when used with modern devices, such as solid-state\r\ndrives (SSDs), phase-change memories, etc.  The designs leverage the team's\r\nwork on storage-optimized algorithms, multi-tier storage, and new optimized\r\ndata structures.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Margo",
   "pi_last_name": "Seltzer",
   "pi_mid_init": "I",
   "pi_sufx_name": "",
   "pi_full_name": "Margo I Seltzer",
   "pi_email_addr": "margo@eecs.harvard.edu",
   "nsf_id": "000146422",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Harvard University",
  "inst_street_address": "1033 MASSACHUSETTS AVE STE 3",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6174955501",
  "inst_zip_code": "021385366",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "MA05",
  "org_lgl_bus_name": "PRESIDENT AND FELLOWS OF HARVARD COLLEGE",
  "org_prnt_uei_num": "",
  "org_uei_num": "LN53LCFJFL45"
 },
 "perf_inst": {
  "perf_inst_name": "Harvard University",
  "perf_str_addr": "33 Oxford Street",
  "perf_city_name": "Cambridge",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021383846",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "MA05",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 306077.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} -->\n<p class=\"p1\"><span class=\"s1\">Today's computers process data much more quickly than they can store that data.<span>&nbsp; </span>For example, a modern computer can process the contents of the Library of Congress American Memory collection in approximately 35 hours, while it would take 3,500 hours (146 days) to store that data onto a solid state drive (SSD), should a large enough one exist, and about 600 days to store that data on a hard drive. This project addresses the question of how one can best organize data in the presence of the enormous disparities in performance between computation and storage. This disparity is frequently referred to as the IO-gap, where IO stands for input/output and refers to the act of reading and writing data from/to persistent storage.</span></p>\n<p class=\"p1\"><span class=\"s1\">This research addressed two areas: efficient support for processing graph-structured data (e.g., a social network, a map of roads) and recent hard disk storage technologies called Shingled Magnetic Recording (SMR) drives.</span></p>\n<!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} -->\n<p class=\"p1\"><span class=\"s1\">Graph-structured data is quite different from conventional business data in that each object is relatively small and the different objects are connected in multiple, complex ways. Thus, there is no natural order to the data that allows a system to place it on persistent storage so it can be accessed efficiently. There are two different problems that must be addressed to efficiently handle graph-structured data.<span>&nbsp; </span>First, one must design efficient mechanisms to store and access data from a single machine. Second, when the data is too large to process on a single machine, it must be partitioned across multiple machines in a manner that allows each partition to be processed with little or no interaction with other partitions.</span></p>\n<!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} -->\n<p class=\"p1\"><span class=\"s1\">This research solved the first problem by introducing the Linked-node analytics using Large Multiversioned Arrays (LLAMA) library. LLAMA is a storage format that provides efficient processing of persistent graph-structured data residing on an SSD.<span>&nbsp; </span>While LLAMA is based on an existing representation, called Compressed Sparse Row (CSR), unlike prior implementations, LLAMA makes the data persistent, allows it to be modified, and can provide multiple copies of the data, representing its state at different points in time.</span></p>\n<!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} -->\n<p class=\"p1\"><span class=\"s1\">Addressing the second problem, partitioning, is challenging for two reasons.<span>&nbsp; </span>First, constructing good partitions, partitions that enable local processing with little inter-machine communication, is a slow operation. Second, since the graph is large enough to require multiple machine to process, it requires multiple machines to partition, and frequently, the algorithms used to partition the graph work well only if each machine can work independently.<span>&nbsp; </span>But this is precisely the goal of partitioning.<span>&nbsp; </span>The Scalable Host-tree Embeddings for Efficient Partitioning (SHEEP) algorithm developed in this project produces high quality partitions, rapidly and, more significantly, guarantees that the quality of the partitions is independent of how the graph is split across the multiple nodes during the partitioning. That is, the graph is randomly distributed across multiple machines, which can compute partitions in parallel and when those computations are combined, the result is guaranteed to be the same as that achieved had the entire graph been processed on a single machine.</span></p>\n<!-- p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} -->\n<p class=\"p1\"><span class=\"s1\">While LLAMA leveraged modern SSDs, SMR drives represent another promising storage technology. However, while SMR drives offer high density and outstanding sequential read and write performance, they do not handle random updates to data (e.g., changing small parts of a graph). To address this challenge, SMR vendors provide an SMR Translation Layer (STL) on the drives that stores random writes and eventually applies them sequentially.<span>&nbsp; </span>This project produced alternative approaches to the vendor-supplied STL.<span>&nbsp; </span>The research investigated the trade offs in using the vendor STL versus using a file system specifically designed to make all writes sequential (a log-structured file system) versus providing a device driver in the operating system the performs the same kinds of functions as the vendor STL, but knows more about the data being read and written and has more resources (e.g., memory) available.</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/27/2017<br>\n\t\t\t\t\tModified by: Margo&nbsp;I&nbsp;Seltzer</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nToday's computers process data much more quickly than they can store that data.  For example, a modern computer can process the contents of the Library of Congress American Memory collection in approximately 35 hours, while it would take 3,500 hours (146 days) to store that data onto a solid state drive (SSD), should a large enough one exist, and about 600 days to store that data on a hard drive. This project addresses the question of how one can best organize data in the presence of the enormous disparities in performance between computation and storage. This disparity is frequently referred to as the IO-gap, where IO stands for input/output and refers to the act of reading and writing data from/to persistent storage.\nThis research addressed two areas: efficient support for processing graph-structured data (e.g., a social network, a map of roads) and recent hard disk storage technologies called Shingled Magnetic Recording (SMR) drives.\n\nGraph-structured data is quite different from conventional business data in that each object is relatively small and the different objects are connected in multiple, complex ways. Thus, there is no natural order to the data that allows a system to place it on persistent storage so it can be accessed efficiently. There are two different problems that must be addressed to efficiently handle graph-structured data.  First, one must design efficient mechanisms to store and access data from a single machine. Second, when the data is too large to process on a single machine, it must be partitioned across multiple machines in a manner that allows each partition to be processed with little or no interaction with other partitions.\n\nThis research solved the first problem by introducing the Linked-node analytics using Large Multiversioned Arrays (LLAMA) library. LLAMA is a storage format that provides efficient processing of persistent graph-structured data residing on an SSD.  While LLAMA is based on an existing representation, called Compressed Sparse Row (CSR), unlike prior implementations, LLAMA makes the data persistent, allows it to be modified, and can provide multiple copies of the data, representing its state at different points in time.\n\nAddressing the second problem, partitioning, is challenging for two reasons.  First, constructing good partitions, partitions that enable local processing with little inter-machine communication, is a slow operation. Second, since the graph is large enough to require multiple machine to process, it requires multiple machines to partition, and frequently, the algorithms used to partition the graph work well only if each machine can work independently.  But this is precisely the goal of partitioning.  The Scalable Host-tree Embeddings for Efficient Partitioning (SHEEP) algorithm developed in this project produces high quality partitions, rapidly and, more significantly, guarantees that the quality of the partitions is independent of how the graph is split across the multiple nodes during the partitioning. That is, the graph is randomly distributed across multiple machines, which can compute partitions in parallel and when those computations are combined, the result is guaranteed to be the same as that achieved had the entire graph been processed on a single machine.\n\nWhile LLAMA leveraged modern SSDs, SMR drives represent another promising storage technology. However, while SMR drives offer high density and outstanding sequential read and write performance, they do not handle random updates to data (e.g., changing small parts of a graph). To address this challenge, SMR vendors provide an SMR Translation Layer (STL) on the drives that stores random writes and eventually applies them sequentially.  This project produced alternative approaches to the vendor-supplied STL.  The research investigated the trade offs in using the vendor STL versus using a file system specifically designed to make all writes sequential (a log-structured file system) versus providing a device driver in the operating system the performs the same kinds of functions as the vendor STL, but knows more about the data being read and written and has more resources (e.g., memory) available.\n\n \n\n\t\t\t\t\tLast Modified: 12/27/2017\n\n\t\t\t\t\tSubmitted by: Margo I Seltzer"
 }
}