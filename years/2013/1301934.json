{
 "awd_id": "1301934",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CSR: Medium: Collaborative Research: The Commutativity Rule for Scalable Systems Software",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032925197",
 "po_email": "mmcclure@nsf.gov",
 "po_sign_block_name": "Marilyn McClure",
 "awd_eff_date": "2013-10-01",
 "awd_exp_date": "2016-09-30",
 "tot_intn_awd_amt": 299995.0,
 "awd_amount": 299995.0,
 "awd_min_amd_letter_date": "2013-09-09",
 "awd_max_amd_letter_date": "2013-09-09",
 "awd_abstract_narration": "After decades of reliable improvement, processor speeds have\r\nflattened; for the foreseeable future, computers will add processing\r\npower by adding more processors, rather than faster ones. This is a\r\ntremendous challenge for software designers. It's far too easy for\r\nsoftware using multiple processors to burn up a growing fraction of\r\navailable processing power on coordination overheads like locking,\r\nrather than actual work. That is, it's far too easy for software to\r\nnot scale: to get slower as processors are added. And an important\r\nreason for this is simply that scalability is poorly understood. Some\r\nprograms don't scale because they're badly written, but others don't\r\nscale because their goals are fundamentally impossible to accomplish\r\nin a scalable way. Programmers lack effective tools for high-level\r\nreasoning about software scalability limitations, and thus waste\r\neffort on both impossible and uninteresting tasks.\r\n\r\nWe will produce the first well-grounded and formal reasoning procedure\r\nfor scalability that is flexible enough to apply to an entire\r\noperating system. Our scalability rule links commutativity and\r\nscalability. We characterize software interfaces as more or less\r\ninherently scalable depending on the contexts in which those\r\ninterfaces commute: the more commutative an interface (that is, the\r\nmore often the order of its function calls doesn't matter), the more\r\nscalable an implementation can be. We prove that a scalable\r\nimplementation exists for any commutative context. This idea can\r\nalready guide software designers in developing easily-scalable\r\ninterfaces, but we will also provide a set of automated tools for\r\nmeasuring interface commutativity and for finding implementation\r\nscalability bottlenecks, and evaluate our ideas in a highly-scalable\r\noperating system. The resulting tools and ideas could make scalable\r\nsoftware far easier to design and program, and thus help software\r\ndesigners provide the software performance on which so much of our\r\neconomy depends.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Marinus",
   "pi_last_name": "Kaashoek",
   "pi_mid_init": "F",
   "pi_sufx_name": "",
   "pi_full_name": "Marinus F Kaashoek",
   "pi_email_addr": "kaashoek@lcs.mit.edu",
   "nsf_id": "000098539",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "Morris",
   "pi_mid_init": "T",
   "pi_sufx_name": "",
   "pi_full_name": "Robert T Morris",
   "pi_email_addr": "rtm@csail.mit.edu",
   "nsf_id": "000471357",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Nickolai",
   "pi_last_name": "Zeldovich",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Nickolai Zeldovich",
   "pi_email_addr": "nickolai@csail.mit.edu",
   "nsf_id": "000520788",
   "pi_start_date": "2013-09-09",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Massachusetts Institute of Technology",
  "inst_street_address": "77 MASSACHUSETTS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CAMBRIDGE",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6172531000",
  "inst_zip_code": "021394301",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "MASSACHUSETTS INSTITUTE OF TECHNOLOGY",
  "org_prnt_uei_num": "E2NYLCDML6V1",
  "org_uei_num": "E2NYLCDML6V1"
 },
 "perf_inst": {
  "perf_inst_name": "Massachusetts Institute of Technology",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021394301",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "735400",
   "pgm_ele_name": "CSR-Computer Systems Research"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 299995.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>After decades of reliable improvement, processor speeds have flattened; for the foreseeable future, computers will add processing power by adding more processors, rather than faster ones. This is a tremendous challenge for software designers. It's far too easy for software using multiple processors to burn up a growing fraction of available processing power on coordination overheads like locking, rather than actual work. That is, it's far too easy for software to not scale: to get slower as processors are added. And an important reason for this is simply that scalability is poorly understood. Some programs don't scale because they're badly written, but others don't scale because their goals are fundamentally impossible to accomplish in a scalable way. Programmers lack effective tools for high-level reasoning about software scalability limitations, and thus waste effort on both impossible and uninteresting tasks.</p>\n<p><br />What opportunities for multicore scalability are latent in software interfaces, such as system call APIs? Can scalability challenges and opportunities be identified even before any implementation exists, simply by considering interface specifications? &nbsp;To answer these questions, this project introduces the scalable commutativity rule: \"Whenever interface operations commute, they can be implemented in a way that scales.\" &nbsp;This rule is useful throughout the development process for scalable multicore software, from the interface design through implementation, testing, and evaluation.</p>\n<p><br />This project formalizes the scalable commutativity rule. This requires defining a novel form of commutativity, SIM commutativity, that lets the rule apply even to complex and highly stateful software interfaces.</p>\n<p><br />This project also introduces a software development, called Commuter, based on the rule. &nbsp;Commuter accepts high-level interface models, generates tests of interface operations that commute and hence could scale, and uses these tests to systematically evaluates the scalability of implementations. &nbsp;Using Commuter the project highlights Linux kernel problems previously observed to limit application scalability and identifies previously unknown bottlenecks that maybe triggered by future workloads or hardware.</p>\n<p><br />Finally, the project applies the scalable commutativity rule and Commuter to the design and implementation of sv6, a new POSIX-like operating system. &nbsp;sv6's novel file and virtual memory system designs enable it to scale for almost all test cases. &nbsp;These results translate to linear scalability on an 80-core x86 machine for applications built on sv6's commutative operations. &nbsp;sv6 also provides disk performance that matches or exceeds that of Linux ext4.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/25/2017<br>\n\t\t\t\t\tModified by: M. Frans&nbsp;Kaashoek</p>\n</div>\n<div class=\"porSideCol\">\n<div class=\"each-gallery\">\n<div class=\"galContent\" id=\"gallery0\">\n<div class=\"photoCount\" id=\"photoCount0\">\n\t\t\t\t\t\t\t\t\tImage\n\t\t\t\t\t\t\t\t</div>\n<div class=\"galControls onePhoto\" id=\"controls0\"></div>\n<div class=\"galSlideshow\" id=\"slideshow0\"></div>\n<div class=\"galEmbox\" id=\"embox\">\n<div class=\"image-title\"></div>\n</div>\n</div>\n<div class=\"galNavigation onePhoto\" id=\"navigation0\">\n<ul class=\"thumbs\" id=\"thumbs0\">\n<li>\n<a href=\"/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-800width.jpg\" title=\"Heatmap\"><img src=\"/por/images/Reports/POR/2017/1301934/1301934_10277307_1492983559271_heatmap--rgov-66x44.jpg\" alt=\"Heatmap\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">A heatmap generated by Commuter for  Linux system call pairs.  Green indicates good scalability and red indicates poor scalabillty.</div>\n<div class=\"imageCredit\">Austin Clements</div>\n<div class=\"imagePermisssions\">Creative Commons</div>\n<div class=\"imageSubmitted\">M. Frans&nbsp;Kaashoek</div>\n<div class=\"imageTitle\">Heatmap</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>",
  "por_txt_cntn": "\nAfter decades of reliable improvement, processor speeds have flattened; for the foreseeable future, computers will add processing power by adding more processors, rather than faster ones. This is a tremendous challenge for software designers. It's far too easy for software using multiple processors to burn up a growing fraction of available processing power on coordination overheads like locking, rather than actual work. That is, it's far too easy for software to not scale: to get slower as processors are added. And an important reason for this is simply that scalability is poorly understood. Some programs don't scale because they're badly written, but others don't scale because their goals are fundamentally impossible to accomplish in a scalable way. Programmers lack effective tools for high-level reasoning about software scalability limitations, and thus waste effort on both impossible and uninteresting tasks.\n\n\nWhat opportunities for multicore scalability are latent in software interfaces, such as system call APIs? Can scalability challenges and opportunities be identified even before any implementation exists, simply by considering interface specifications?  To answer these questions, this project introduces the scalable commutativity rule: \"Whenever interface operations commute, they can be implemented in a way that scales.\"  This rule is useful throughout the development process for scalable multicore software, from the interface design through implementation, testing, and evaluation.\n\n\nThis project formalizes the scalable commutativity rule. This requires defining a novel form of commutativity, SIM commutativity, that lets the rule apply even to complex and highly stateful software interfaces.\n\n\nThis project also introduces a software development, called Commuter, based on the rule.  Commuter accepts high-level interface models, generates tests of interface operations that commute and hence could scale, and uses these tests to systematically evaluates the scalability of implementations.  Using Commuter the project highlights Linux kernel problems previously observed to limit application scalability and identifies previously unknown bottlenecks that maybe triggered by future workloads or hardware.\n\n\nFinally, the project applies the scalable commutativity rule and Commuter to the design and implementation of sv6, a new POSIX-like operating system.  sv6's novel file and virtual memory system designs enable it to scale for almost all test cases.  These results translate to linear scalability on an 80-core x86 machine for applications built on sv6's commutative operations.  sv6 also provides disk performance that matches or exceeds that of Linux ext4.\n\n\t\t\t\t\tLast Modified: 04/25/2017\n\n\t\t\t\t\tSubmitted by: M. Frans Kaashoek"
 }
}