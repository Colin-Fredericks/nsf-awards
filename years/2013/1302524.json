{
 "awd_id": "1302524",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CCF: SHF: Medium: Collaborative Research: A Static and Dynamic Verification Framework for Parallel Programming",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-04-15",
 "awd_exp_date": "2018-12-31",
 "tot_intn_awd_amt": 398752.0,
 "awd_amount": 398752.0,
 "awd_min_amd_letter_date": "2013-04-11",
 "awd_max_amd_letter_date": "2018-05-01",
 "awd_abstract_narration": "Human society is faced with an increasing number of problems including\r\nstubborn diseases and international security/climate threats. The\r\ncomputer simulations and advanced data management methods necessary to\r\nsolving these societal problems can only be realized through increased\r\nuse of parallel computing at all system scales, including desktops,\r\nservers and the cloud. Efficient large-scale parallel computing\r\nhowever requires advanced parallel programming methods. Such methods,\r\nunfortunately, have a greater proclivity for software bugs that\r\nincrease cost through lost cycles on super-computers and these same\r\nbugs undermine confidence in simulation results.  This research\r\naddresses the challenge of developing parallel computing software by\r\ncreating new scalable methods to support advanced parallel programming\r\nmodels that provide rigorous guarantees on program correctness. The\r\nsocietal impacts of this work stem from increasing reliability of\r\nsoftware powering the national infrastructure, advanced educational\r\nmethods to train future generations, and pedagogical material in the\r\nform of course notes and software for broad dissemination.  It also\r\nhelps maintain the United States in a leadership situation with\r\nrespect to the available talent pool in this area.\r\n\r\nProviding rigorous guarantees on correctness of existing parallel\r\ncomputing software requires that two classes of methods be developed,\r\nevaluated, and taught widely: scalable code-level (static) checking\r\nmethods, and downstream detailed (dynamic) checking methods. This\r\nproject develops these novel and much-needed correctness checking\r\nmethods around the Habanero Java programming and compilation\r\nsystem. The research is to augment the system with correctness\r\nobligations emitted during compilation and checked at all later stages\r\nof translation and deployment.  A key highlight of the project's\r\napproach is that it allows some of the correctness obligations to be\r\nchecked statically in the context of safe subsets of Habanero Java.\r\nObligations that are not able to be statically checked, especially for\r\nlarger subsets of the Habanero language, are marked for checking\r\ndynamically through novel active-testing methods. An Operational\r\nSemantics written in the Coq notation lends cohesion to the work by\r\nensuring that the division of correctness checking between static and\r\ndynamic techniques is sound. In summary, this research helps advance\r\nthe science of parallel programming in terms of rigorous correctness\r\nchecking methods, while at the same time contributing to the broad\r\npractice of programming at all scales from desktop to cloud\r\ncomputing and high-end scientific simulations.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Eric",
   "pi_last_name": "Mercer",
   "pi_mid_init": "G",
   "pi_sufx_name": "",
   "pi_full_name": "Eric G Mercer",
   "pi_email_addr": "egm@cs.byu.edu",
   "nsf_id": "000425557",
   "pi_start_date": "2013-04-11",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Brigham Young University",
  "inst_street_address": "A-153 ASB",
  "inst_street_address_2": "",
  "inst_city_name": "PROVO",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8014223360",
  "inst_zip_code": "846021128",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "UT03",
  "org_lgl_bus_name": "BRIGHAM YOUNG UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "JWSYC7RUMJD1"
 },
 "perf_inst": {
  "perf_inst_name": "Brigham Young University",
  "perf_str_addr": "",
  "perf_city_name": "Provo",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "846021231",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "UT03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794200",
   "pgm_ele_name": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7942",
   "pgm_ref_txt": "HIGH-PERFORMANCE COMPUTING"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 195423.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 203329.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Task parallel programming models such as OpenMP, Cilk, X10, and Habanero help developers write idiomatic parallel programs that avoid common concurrency errors. The models provide a task abstraction for concurrency that is agnostic of the underlying runtime implementation to simplify programming. The models then structure how tasks are created and synchronized in a way that guarantees deadlock freedom, determinism, and that the program can be serialized by removing all task related keywords.&nbsp;</p>\n<p>These properties rely on the program being free of data-race. Data-race is where two tasks access the same memory and at least one access is a write.&nbsp; Data-race introduces non-determinism into the program and undermines the correctness guarantees provided by the task abstraction. It is also hard to detect statically or dynamically in a program.&nbsp;</p>\n<p>The primary outcomes for the research from this grant center around proving data-race freedom in idiomatic parallel programs. The research uses Habanero for the programming model and provides several artifacts for the Java implementation of Habanero to support data-race freedom verification.<br />The first outcome is a Habanero runtime for test, debug, and verification. Most data-race approaches focus on detection rather than verification and utilize a full production runtime; low overhead and minimal impact on runtime performance are the primary goals. Research in this grant rather focuses on proving data-race freedom and provides a runtime that is well suited for running standalone for test, in a debugger, or in a model checker for verification.</p>\n<p>The runtime leaves behind complex task implementations and the complicated ways to work steal, load balance, and schedule tasks. Performance is not the primary objective. Rather the objective is simplicity over performance so that practitioners are able to first test, debug, and understand the parallel program before deploying it on a full-scale production system. As such the Habanero Java verification runtime works seamlessly in the Java Pathfinder (JPF) model checker with no modification to JPF and uses a simple thread implementation for the task abstraction. It is small and simple enough to be reasonably argued by code inspection that is a faithful implementation of the Habanero model.</p>\n<p>The second outcome is a collection of data-race verification algorithms integrated into JPF for the Habanero model with a rich collection of common data-race benchmarks collected from recent and past publications, other benchmark suites, and corner cases that arise in algorithm development. The new algorithms in this research center around the computation graph that captures concurrency in the program execution as a partial order and blend concepts from existing algorithms that use partial orders and access sets to detect data-race. The algorithms are shown in results on the benchmark suite to be more efficient in time and space in proving data-race freedom. These are available, with the Habanero runtime, at https://bitbucket.org/byu-vv/jpf-hj/src/master/ and https://bitbucket.org/byu-vv/jpf-hj/src/master/.</p>\n<p>The third outcome is a much deeper understanding of data race detection using partial orders and that in idiomatic parallel programs using access sets.&nbsp; This research blends ideas from both approaches and shows where one approach is preferred over the other based not just on program structure but the number of shared objects. It further takes the partial order approaches and weakens those relations to the point where they become unsound for general concurrency but still absolutely sound for idiomatic programs due to how they limit synchronization between tasks.&nbsp; The weakest partial order in this research is the does-not-commute partial order, and that is proven to be sound in idiomatic parallel programs with mutual exclusion. This result includes a mechanical proof in Coq of the soundness and an implementation in JPF showing a significant reduction in the number of schedules needed to prove data-race freedom in Habanero programs.</p>\n<p>The broader impact of the research from this grant is the accessibility of the tools to a larger community of practitioners and researchers.&nbsp; The JPF extension includes the implementation of several state-of-art data-race detection algorithms as well as the algorithms in this research. It also includes in one place a rich set of benchmarks that are now characterized over these several algorithms. These are all freely available for download. The distribution also includes a build system to simplify not just the build but test automation, regression, and experiments on the benchmarks. This single source of algorithms and benchmarks built on the open source JPF model checker with the Habanero verification runtime enables practitioners to build better systems and researchers to better characterize new contributions and applications.</p>\n<p><br />Finally the research in this grant has involved a diverse set of students giving them opportunity to research problems that are hard to solve and may not even have workable solutions. These students have untold impact as they go forward and grow the reach of concurrent systems and shape the future of concurrent programming models in systems and society.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 05/17/2019<br>\n\t\t\t\t\tModified by: Eric&nbsp;G&nbsp;Mercer</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nTask parallel programming models such as OpenMP, Cilk, X10, and Habanero help developers write idiomatic parallel programs that avoid common concurrency errors. The models provide a task abstraction for concurrency that is agnostic of the underlying runtime implementation to simplify programming. The models then structure how tasks are created and synchronized in a way that guarantees deadlock freedom, determinism, and that the program can be serialized by removing all task related keywords. \n\nThese properties rely on the program being free of data-race. Data-race is where two tasks access the same memory and at least one access is a write.  Data-race introduces non-determinism into the program and undermines the correctness guarantees provided by the task abstraction. It is also hard to detect statically or dynamically in a program. \n\nThe primary outcomes for the research from this grant center around proving data-race freedom in idiomatic parallel programs. The research uses Habanero for the programming model and provides several artifacts for the Java implementation of Habanero to support data-race freedom verification.\nThe first outcome is a Habanero runtime for test, debug, and verification. Most data-race approaches focus on detection rather than verification and utilize a full production runtime; low overhead and minimal impact on runtime performance are the primary goals. Research in this grant rather focuses on proving data-race freedom and provides a runtime that is well suited for running standalone for test, in a debugger, or in a model checker for verification.\n\nThe runtime leaves behind complex task implementations and the complicated ways to work steal, load balance, and schedule tasks. Performance is not the primary objective. Rather the objective is simplicity over performance so that practitioners are able to first test, debug, and understand the parallel program before deploying it on a full-scale production system. As such the Habanero Java verification runtime works seamlessly in the Java Pathfinder (JPF) model checker with no modification to JPF and uses a simple thread implementation for the task abstraction. It is small and simple enough to be reasonably argued by code inspection that is a faithful implementation of the Habanero model.\n\nThe second outcome is a collection of data-race verification algorithms integrated into JPF for the Habanero model with a rich collection of common data-race benchmarks collected from recent and past publications, other benchmark suites, and corner cases that arise in algorithm development. The new algorithms in this research center around the computation graph that captures concurrency in the program execution as a partial order and blend concepts from existing algorithms that use partial orders and access sets to detect data-race. The algorithms are shown in results on the benchmark suite to be more efficient in time and space in proving data-race freedom. These are available, with the Habanero runtime, at https://bitbucket.org/byu-vv/jpf-hj/src/master/ and https://bitbucket.org/byu-vv/jpf-hj/src/master/.\n\nThe third outcome is a much deeper understanding of data race detection using partial orders and that in idiomatic parallel programs using access sets.  This research blends ideas from both approaches and shows where one approach is preferred over the other based not just on program structure but the number of shared objects. It further takes the partial order approaches and weakens those relations to the point where they become unsound for general concurrency but still absolutely sound for idiomatic programs due to how they limit synchronization between tasks.  The weakest partial order in this research is the does-not-commute partial order, and that is proven to be sound in idiomatic parallel programs with mutual exclusion. This result includes a mechanical proof in Coq of the soundness and an implementation in JPF showing a significant reduction in the number of schedules needed to prove data-race freedom in Habanero programs.\n\nThe broader impact of the research from this grant is the accessibility of the tools to a larger community of practitioners and researchers.  The JPF extension includes the implementation of several state-of-art data-race detection algorithms as well as the algorithms in this research. It also includes in one place a rich set of benchmarks that are now characterized over these several algorithms. These are all freely available for download. The distribution also includes a build system to simplify not just the build but test automation, regression, and experiments on the benchmarks. This single source of algorithms and benchmarks built on the open source JPF model checker with the Habanero verification runtime enables practitioners to build better systems and researchers to better characterize new contributions and applications.\n\n\nFinally the research in this grant has involved a diverse set of students giving them opportunity to research problems that are hard to solve and may not even have workable solutions. These students have untold impact as they go forward and grow the reach of concurrent systems and shape the future of concurrent programming models in systems and society.\n\n\t\t\t\t\tLast Modified: 05/17/2019\n\n\t\t\t\t\tSubmitted by: Eric G Mercer"
 }
}