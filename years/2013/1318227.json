{
 "awd_id": "1318227",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Havoc: Verified Compilation of Concurrent Managed Languages",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2018-08-31",
 "tot_intn_awd_amt": 475000.0,
 "awd_amount": 475000.0,
 "awd_min_amd_letter_date": "2013-08-07",
 "awd_max_amd_letter_date": "2016-11-22",
 "awd_abstract_narration": "The goals of the Havoc project are to provide (a) foundational results on verified compilation of important concurrency abstractions (e.g., locks, monitors, stacks, queues, hash-tables, etc.) into efficient non-blocking variants, (b) a precise memory model for reasoning about the correctness of program transformations performed by the compiler in a shared-memory concurrency programming model, along with detailed experimental validation on the impact of the model's design on compiler transformations and optimizations, and (c) a methodology to formally reason about complex concurrent interactions between application threads and managed components like modern garbage collectors. The primary artifacts of this effort will be formally certified tools, specifically, compilers, and runtime components found in modern managed languages that can be used to replace existing infrastructure, as well as new language-level memory models that are both conceptually cleaner to reason about and deploy within a verified optimizing compiler framework.  \r\n\r\nThese artifacts will dramatically change the safety-critical application landscape, which increasingly contains concurrent components, relieving the need for costly manual inspection of source and binary, and enabling a richer class of optimizations.  They will greatly assist engineers in the task of constructing high-assurance, mission-critical software systems, such as avionics, medical systems, and military communications systems.\r\n\r\nThe proposed research focus will be on the specification and verification of optimization passes from Java bytecodes generated from a Java application to a low-level intermediate representation (register transfer language), used in the CompcertTSO certified compiler previously developed by the PIs. In addition, the project will undertake the formalization of salient runtime components, including memory management and threads.  While patterned after the Java memory model, the memory abstraction underlying the language semantics will be carefully tailored to facilitate mechanized reasoning about program transformations and will be cognizant of the relaxed memory features of the underlying hardware.  This project combines infrastructure engineering and scientific advances in software verification.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Sunil",
   "pi_last_name": "Prabhakar",
   "pi_mid_init": "K",
   "pi_sufx_name": "",
   "pi_full_name": "Sunil K Prabhakar",
   "pi_email_addr": "sunil@purdue.edu",
   "nsf_id": "000490800",
   "pi_start_date": "2015-09-14",
   "pi_end_date": "2016-11-22"
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Jan",
   "pi_last_name": "Vitek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jan Vitek",
   "pi_email_addr": "j.vitek@neu.edu",
   "nsf_id": "000290862",
   "pi_start_date": "2013-10-01",
   "pi_end_date": "2014-09-11"
  },
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Suresh",
   "pi_last_name": "Jagannathan",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Suresh Jagannathan",
   "pi_email_addr": "suresh@cs.purdue.edu",
   "nsf_id": "000181308",
   "pi_start_date": "2016-11-22",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Gustavo",
   "pi_last_name": "Petri",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Gustavo Petri",
   "pi_email_addr": "gpetri@purdue.edu",
   "nsf_id": "000653846",
   "pi_start_date": "2015-01-27",
   "pi_end_date": "2015-09-14"
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Jan",
   "pi_last_name": "Vitek",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jan Vitek",
   "pi_email_addr": "j.vitek@neu.edu",
   "nsf_id": "000290862",
   "pi_start_date": "2016-11-22",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Gustavo",
   "pi_last_name": "Petri",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Gustavo Petri",
   "pi_email_addr": "gpetri@purdue.edu",
   "nsf_id": "000653846",
   "pi_start_date": "2013-09-30",
   "pi_end_date": "2014-09-11"
  }
 ],
 "inst": {
  "inst_name": "Purdue University",
  "inst_street_address": "2550 NORTHWESTERN AVE # 1100",
  "inst_street_address_2": "",
  "inst_city_name": "WEST LAFAYETTE",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "7654941055",
  "inst_zip_code": "479061332",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IN04",
  "org_lgl_bus_name": "PURDUE UNIVERSITY",
  "org_prnt_uei_num": "YRXVL4JYCEF5",
  "org_uei_num": "YRXVL4JYCEF5"
 },
 "perf_inst": {
  "perf_inst_name": "Purdue University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "479072017",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IN04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794300",
   "pgm_ele_name": "PROGRAMMING LANGUAGES"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 475000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Modern-day software applications execute on a complex software stack, comprising sophisticated libraries and managed runtime services that interact with one another using subtle (often racy) concurrency patterns.&nbsp; Precisely reasoning about application correctness in the face of this complexity requires devising new modular verification methods.&nbsp; This project explores this question by considering a verification infrastructure capable of reasoning about high-level concurrent programming applications that use managed runtime services, such as garbage collectors.&nbsp; &nbsp;Concurrency abstractions available to source programs are usually translated to sophisticated lower-level patterns that expose greater concurrency, at the expense of ease of reasoning.&nbsp; Managed services are themselves highly concurrent, and exhibit subtle interactions with source applications.&nbsp; &nbsp; A new verification methodology, along with new proof engineering principles, capable of modular verification of concurrent Java programs interacting with state-of-the-art concurrent collectors, defines the main contributions of this project.&nbsp; &nbsp;The outcome of this work paves the way for developing a full end-to-end verification pipeline for next-generation software architectures and compilers.</p>\n<p>There were two significant results produced under this effort.&nbsp; (1)&nbsp; A framework (i.e, proof methodology) for the verified compilation of high-level languages like Java or C\\# whose intermediate representations provide support for shared-memory synchronization and automatic memory management. In this environment, the interactions between application threads and the language runtime (the garbage collector) are regulated by compiler-injected code snippets that help specify the creation, reclamation, and status of heap-allocated memory objects.&nbsp; The proof structure developed in this project</p>\n<p>helps to precisely relate concurrent code expressed at different abstraction levels.&nbsp; Our technique allows the compiler writer to reason compositionally about the safety of low-level concurrent code used to implement managed services. (2)&nbsp; As a significant follow-on to result (1), we developed a fully verified mechanized proof of a state-of-the-art concurrent garbage collector.&nbsp; Critical to the proof effort is the design of a new compiler intermediate representation (IR) with strong type guarantees, dedicated support for abstract concurrent data structures, and high-level control structures designed with proof engineering in mind.&nbsp; The resulting artefact supports an incremental proof methodology where annotations and invariants can be progressively enriched.&nbsp; The formalization of concurrency abstractions, compilation framework, IR, proof system, and soundness results, all given using the Coq proof assistant, and collectively defines a notable advance in the state-of-the-art of concurrent program verification.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 09/16/2018<br>\n\t\t\t\t\tModified by: Suresh&nbsp;Jagannathan</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nModern-day software applications execute on a complex software stack, comprising sophisticated libraries and managed runtime services that interact with one another using subtle (often racy) concurrency patterns.  Precisely reasoning about application correctness in the face of this complexity requires devising new modular verification methods.  This project explores this question by considering a verification infrastructure capable of reasoning about high-level concurrent programming applications that use managed runtime services, such as garbage collectors.   Concurrency abstractions available to source programs are usually translated to sophisticated lower-level patterns that expose greater concurrency, at the expense of ease of reasoning.  Managed services are themselves highly concurrent, and exhibit subtle interactions with source applications.    A new verification methodology, along with new proof engineering principles, capable of modular verification of concurrent Java programs interacting with state-of-the-art concurrent collectors, defines the main contributions of this project.   The outcome of this work paves the way for developing a full end-to-end verification pipeline for next-generation software architectures and compilers.\n\nThere were two significant results produced under this effort.  (1)  A framework (i.e, proof methodology) for the verified compilation of high-level languages like Java or C\\# whose intermediate representations provide support for shared-memory synchronization and automatic memory management. In this environment, the interactions between application threads and the language runtime (the garbage collector) are regulated by compiler-injected code snippets that help specify the creation, reclamation, and status of heap-allocated memory objects.  The proof structure developed in this project\n\nhelps to precisely relate concurrent code expressed at different abstraction levels.  Our technique allows the compiler writer to reason compositionally about the safety of low-level concurrent code used to implement managed services. (2)  As a significant follow-on to result (1), we developed a fully verified mechanized proof of a state-of-the-art concurrent garbage collector.  Critical to the proof effort is the design of a new compiler intermediate representation (IR) with strong type guarantees, dedicated support for abstract concurrent data structures, and high-level control structures designed with proof engineering in mind.  The resulting artefact supports an incremental proof methodology where annotations and invariants can be progressively enriched.  The formalization of concurrency abstractions, compilation framework, IR, proof system, and soundness results, all given using the Coq proof assistant, and collectively defines a notable advance in the state-of-the-art of concurrent program verification.\n\n \n\n\t\t\t\t\tLast Modified: 09/16/2018\n\n\t\t\t\t\tSubmitted by: Suresh Jagannathan"
 }
}