{
 "awd_id": "1319459",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Pushing the Frontier of Linear-Time Model-Checking Technology",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 304582.0,
 "awd_amount": 304582.0,
 "awd_min_amd_letter_date": "2013-06-25",
 "awd_max_amd_letter_date": "2013-06-25",
 "awd_abstract_narration": "Model checking is a technique for verifying the correctness of computer \r\nsystems. Different implementations are in wide industrial usage today. \r\nThere are still, however, many large gaps in our understanding of the \r\nalgorithmic issues involved in model checking, and the technology is still \r\ngreatly challenged by industrial designs. For example, in hardware-design \r\nverification, it is rarely possible to apply existing tools to complete units \r\nwith clear functionality. This project is pushing the frontier of this \r\ntechnology with the goal of scaling its applicability to functional system \r\nunits by developing novel scalable algorithms for model checking. The \r\nresult will be increased reliability of computer systems. \r\n\r\nThis project will explore the mathematical approach to design \r\nverification that uses automata theory as a unifying paradigm for design \r\nspecification and verification. The automata-theoretic approach separates the \r\nlogical and the combinatorial aspects of reasoning about systems. The translation \r\nof specifications to automata handles the logic and shifts all the combinatorial \r\ndifficulties to questions about automata, yielding clean and asymptotically optimal \r\nalgorithms. While the fundamental theory is well understood, there are \r\nstill many challenging gaps and improved algorithms can enhance the \r\nscalability of this approach significantly. This project investigates ways of improving \r\nautomata-theoretic algorithms so they are more suitable for model checking \r\nat scale.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Moshe",
   "pi_last_name": "Vardi",
   "pi_mid_init": "Y",
   "pi_sufx_name": "",
   "pi_full_name": "Moshe Y Vardi",
   "pi_email_addr": "vardi@rice.edu",
   "nsf_id": "000462277",
   "pi_start_date": "2013-06-25",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "William Marsh Rice University",
  "inst_street_address": "6100 MAIN ST",
  "inst_street_address_2": "",
  "inst_city_name": "Houston",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "7133484820",
  "inst_zip_code": "770051827",
  "inst_country_name": "United States",
  "cong_dist_code": "09",
  "st_cong_dist_code": "TX09",
  "org_lgl_bus_name": "WILLIAM MARSH RICE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "K51LECU1G8N3"
 },
 "perf_inst": {
  "perf_inst_name": "William Marsh Rice University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "770051827",
  "perf_ctry_code": "US",
  "perf_cong_dist": "09",
  "perf_st_cong_dist": "TX09",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 304582.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Pushing the Frontier of Linear-Time Model-Checking Technology:</p>\n<p><br />Model checking is a verification technology that enables reasoning about&nbsp;the behavior of interactive compuing systems, resulting in more reliable&nbsp;systems.&nbsp; The basic theory of model checking was worked out in the 1980s&nbsp;and 1990s, and tools based in this approach are in wide industrial usage&nbsp;today.&nbsp; It turns out, however, that there are still many large gaps in&nbsp;&nbsp;our understanding of the algorithmic issues involved in model checking,&nbsp;and the technology is still greatly challenged by industrial designs.&nbsp;For example, in hardware-design verification, it is rarely possible to&nbsp;&nbsp;apply existing tools to units with clear functionality.&nbsp; Instead,&nbsp;verification engineers typically have to chop such units into blocks&nbsp;without clear functionality, demanding extensive effort .&nbsp; This project is aimed at pushing the frontier of&nbsp;&nbsp;this technology with the goal of scaling its applicability to functional&nbsp;system units, by developing novel scalable algorithms for checking.</p>\n<p>The intellectual merit of this project is the application of the&nbsp;theoretical ideas to industrial design verification, which uses the theoryof finite-state machines as a unifying paradigm for design specification,&nbsp;verification, and synthesis.&nbsp; This perspective considers the relationships&nbsp;between designs and their specifications as relationships between formal&nbsp;languages. By translating design and logical specificationsto finite-state machines, questions about programs and their specifications&nbsp;can be reduced to questions about finite-state machines. More specifically,&nbsp;questions such as satisfiability of specifications and correctness of designs&nbsp;with respect to their specifications can be reduced to questions such as&nbsp;non-emptiness and containment of automata.&nbsp; This approach separates&nbsp;the logical and the combinatorial aspects of reasoning about systems.&nbsp;&nbsp;this approach significantly.~&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/07/2017<br>\n\t\t\t\t\tModified by: Moshe&nbsp;Y&nbsp;Vardi</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nPushing the Frontier of Linear-Time Model-Checking Technology:\n\n\nModel checking is a verification technology that enables reasoning about the behavior of interactive compuing systems, resulting in more reliable systems.  The basic theory of model checking was worked out in the 1980s and 1990s, and tools based in this approach are in wide industrial usage today.  It turns out, however, that there are still many large gaps in  our understanding of the algorithmic issues involved in model checking, and the technology is still greatly challenged by industrial designs. For example, in hardware-design verification, it is rarely possible to  apply existing tools to units with clear functionality.  Instead, verification engineers typically have to chop such units into blocks without clear functionality, demanding extensive effort .  This project is aimed at pushing the frontier of  this technology with the goal of scaling its applicability to functional system units, by developing novel scalable algorithms for checking.\n\nThe intellectual merit of this project is the application of the theoretical ideas to industrial design verification, which uses the theoryof finite-state machines as a unifying paradigm for design specification, verification, and synthesis.  This perspective considers the relationships between designs and their specifications as relationships between formal languages. By translating design and logical specificationsto finite-state machines, questions about programs and their specifications can be reduced to questions about finite-state machines. More specifically, questions such as satisfiability of specifications and correctness of designs with respect to their specifications can be reduced to questions such as non-emptiness and containment of automata.  This approach separates the logical and the combinatorial aspects of reasoning about systems.  this approach significantly.~                            \n\n \n\n\t\t\t\t\tLast Modified: 12/07/2017\n\n\t\t\t\t\tSubmitted by: Moshe Y Vardi"
 }
}