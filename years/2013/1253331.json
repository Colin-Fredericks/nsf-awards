{
 "awd_id": "1253331",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Verifying Threaded Software Using Resource Bounds -- An Approach Towards Dependable Concurrency",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2013-05-01",
 "awd_exp_date": "2019-08-31",
 "tot_intn_awd_amt": 515495.0,
 "awd_amount": 515495.0,
 "awd_min_amd_letter_date": "2013-01-18",
 "awd_max_amd_letter_date": "2017-05-30",
 "awd_abstract_narration": "Software development is facing a paradigm shift towards ubiquitous\r\nconcurrent programming, giving rise to software that is among the most\r\ncomplex technical artifacts ever created by humans. Concurrent programming\r\npresents several risks and dangers for programmers who are overwhelmed by puzzling \r\nand irreproducible concurrent program behavior, and  by new types of bugs that elude \r\ntraditional quality assurance techniques.  If this situation is not addressed, we are \r\ndrifting into an era of widespread  unreliable software, with consequences ranging \r\nfrom collapsed programmer productivity, to catastrophic failures in mission-critical systems.\r\n\r\nThis project will take steps against a concurrent software crisis, by\r\nproducing verification technology that assists non-specialist programmers\r\nin detecting concurrency errors, or demonstrating their absence. The\r\nproposed technology will confront the concurrency explosion problem that\r\nverification methods often suffer from. The project's goal is a framework\r\nunder which the analysis of programs with unbounded concurrency resources\r\n(such as threads of execution) can be soundly reduced to an analysis under\r\na small constant resource bound, making the use of state space explorers\r\npractical. As a result, the project will largely eliminate the impact of\r\nunspecified computational resources as the major cause of complexity in\r\nanalyzing concurrent programs. By developing tools for detecting otherwise \r\nundetectable misbehavior and vulnerabilities in concurrent programs, the \r\nproject will contribute its part to averting a looming software quality crisis.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Thomas",
   "pi_last_name": "Wahl",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Thomas Wahl",
   "pi_email_addr": "wahl@ccs.neu.edu",
   "nsf_id": "000608439",
   "pi_start_date": "2013-01-18",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "360 Huntington Ave",
  "perf_city_name": "Boston",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "794400",
   "pgm_ele_name": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 209458.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 99013.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 101982.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 105042.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>As the dependence of society on software and computer systems increases, so does the need for ensuring their reliable operation. An unresponsive node in a distributed computing environment, or a process that attempts to execute an illegal instruction and is thus terminated by the operating system are examples of failures that are, unfortunately, widespread in today's software. Consequences range from an \"inconvenience\" to the potential of catastrophes. The thriving field of Formal Verification aims, among others, at thoroughly investigating software for the presence of such potential failures, before the software is deployed.<br /><br />In this project, we focus specifically on the formal verification of threaded software: programs that consist of multiple, more or less independent threads of computation that pursue their own \"agenda\" and compete with other threads, such as dynamic threads in a shared-memory computing environment. The analysis of such software for certain patterns of errors, which are often very intricate and hard to comprehend or even reproduce by the software engineer, is a long-standing problem in computer science.<br /><br />Toward this goal, the present project started from the assumption that virtually all computer programs rely on the existence of certain <em>resources</em> for them to use, such as the storage capacity of a data structure used by the programs, or the degree of concurrency (number of spawnable threads). Programmers charged with analyzing concurrent software for errors often employ a not-so-secret weapon to reduce the complexity of the analysis: they bound each resource to some finite capacity. Imagine a distributed system where participating nodes send each other messages via unbounded queues, engendering an infinite state space. For analysis purposes, if we assume that the queues can only hold some number k of messages, then we may have a shot at exploring all possible states of the queues, since there can now only be a finite number of messages in them.<br /><br />But, ultimately, we need to make a statement about the unbounded-resource software, which is the abstraction commonly (and reasonably) used during software design. In this project we have developed techniques that empower the software engineer to build on top of existing bounded-resource analyses and extend them to enable guarantees even in the unbounded-resource case. More precisely, the framework presented here suggests to perform a sequence of bounded analyses with increasing resource capacities. If any such analysis discover a software problem, we report it as a failure to the programmer. Otherwise, we have to decide when to stop increasing the resource capacity, arguing that further increases cannot possibly reveal software failures that we haven't observed yet up to this point.<br /><br />We have successfully applied this approach to a number of complex system designs. \"Complex\" here means that there are theoretical and unsurmountable limits to the full verification of such systems (the problem is <em>undecidable</em>). The goal then is to be able to design analyses that work in many cases in practice. Our application scenarios include distributed systems of communicating state machines, and collections of recursive functions executing in parallel and communicating via shared memory. The outcomes include partial verification techniques for such systems, but more significantly an analysis framework that can be adapted to new application scenarios with only moderate effort. These outcomes have led to scientific publications in the top dissemination venues in the fields of programming languages and verification.<br /><br />One impact of the wide applicability of this paradigm is that the project has enabled the broad participation of students at various educational stages, from doctoral candidates to freshman (!) undergraduates. This has helped not only to engage these students in research---some at the earliest possible stage---, but also to educate them about the pitfalls of concurrency, and about program semantics and verification, which will in the end turn these future computer scientists into better program developers.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/20/2019<br>\n\t\t\t\t\tModified by: Thomas&nbsp;Wahl</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nAs the dependence of society on software and computer systems increases, so does the need for ensuring their reliable operation. An unresponsive node in a distributed computing environment, or a process that attempts to execute an illegal instruction and is thus terminated by the operating system are examples of failures that are, unfortunately, widespread in today's software. Consequences range from an \"inconvenience\" to the potential of catastrophes. The thriving field of Formal Verification aims, among others, at thoroughly investigating software for the presence of such potential failures, before the software is deployed.\n\nIn this project, we focus specifically on the formal verification of threaded software: programs that consist of multiple, more or less independent threads of computation that pursue their own \"agenda\" and compete with other threads, such as dynamic threads in a shared-memory computing environment. The analysis of such software for certain patterns of errors, which are often very intricate and hard to comprehend or even reproduce by the software engineer, is a long-standing problem in computer science.\n\nToward this goal, the present project started from the assumption that virtually all computer programs rely on the existence of certain resources for them to use, such as the storage capacity of a data structure used by the programs, or the degree of concurrency (number of spawnable threads). Programmers charged with analyzing concurrent software for errors often employ a not-so-secret weapon to reduce the complexity of the analysis: they bound each resource to some finite capacity. Imagine a distributed system where participating nodes send each other messages via unbounded queues, engendering an infinite state space. For analysis purposes, if we assume that the queues can only hold some number k of messages, then we may have a shot at exploring all possible states of the queues, since there can now only be a finite number of messages in them.\n\nBut, ultimately, we need to make a statement about the unbounded-resource software, which is the abstraction commonly (and reasonably) used during software design. In this project we have developed techniques that empower the software engineer to build on top of existing bounded-resource analyses and extend them to enable guarantees even in the unbounded-resource case. More precisely, the framework presented here suggests to perform a sequence of bounded analyses with increasing resource capacities. If any such analysis discover a software problem, we report it as a failure to the programmer. Otherwise, we have to decide when to stop increasing the resource capacity, arguing that further increases cannot possibly reveal software failures that we haven't observed yet up to this point.\n\nWe have successfully applied this approach to a number of complex system designs. \"Complex\" here means that there are theoretical and unsurmountable limits to the full verification of such systems (the problem is undecidable). The goal then is to be able to design analyses that work in many cases in practice. Our application scenarios include distributed systems of communicating state machines, and collections of recursive functions executing in parallel and communicating via shared memory. The outcomes include partial verification techniques for such systems, but more significantly an analysis framework that can be adapted to new application scenarios with only moderate effort. These outcomes have led to scientific publications in the top dissemination venues in the fields of programming languages and verification.\n\nOne impact of the wide applicability of this paradigm is that the project has enabled the broad participation of students at various educational stages, from doctoral candidates to freshman (!) undergraduates. This has helped not only to engage these students in research---some at the earliest possible stage---, but also to educate them about the pitfalls of concurrency, and about program semantics and verification, which will in the end turn these future computer scientists into better program developers.\n\n\t\t\t\t\tLast Modified: 12/20/2019\n\n\t\t\t\t\tSubmitted by: Thomas Wahl"
 }
}