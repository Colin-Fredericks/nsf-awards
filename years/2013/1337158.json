{
 "awd_id": "1337158",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: CLCCA: On the Hunt for Correctness and Performance Bugs in Large-scale Programs",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2013-09-15",
 "awd_exp_date": "2016-08-31",
 "tot_intn_awd_amt": 260331.0,
 "awd_amount": 292331.0,
 "awd_min_amd_letter_date": "2013-09-13",
 "awd_max_amd_letter_date": "2015-04-24",
 "awd_abstract_narration": "The scale of computing applications has been dramatically increasing over the past several years. As applications in domains such as computational genomics, data mining, and machine learning are let loose on ever-more-complex problems, the scale of the inputs to these applications has shot up. And as the pursuit of parallelism has led to increasing core counts for servers, and increasing numbers of servers and racks for data centers, the scale of the systems that these applications must run on has also dramatically risen. A critical problem in developing large scale applications is detecting and debugging scaling issues, which are problems with program behavior that emerge only as a program scales up. Scaling issues show up as correctness bugs or performance bottlenecks. Unfortunately, detecting bugs that arise at large scales is difficult. Manually poring through logs or performance profiling individual application processes is not practical. Moreover, the developer may not have access to the inputs and systems necessary to run the application at large scales. This research project aims to develop automated techniques to detect and diagnose correctness and performance bugs for large-scale programs using program behavior modeling, training at small scale runs, and extrapolating to large-scale runs.\r\n\r\nTo achieve our objectives, we build statistical models that incorporate scale. By relating program scale to program behavior, we can predict how a program behaves at large scales, without ever seeing correct behavior at that scale, and use those predictions to detect and diagnose bugs. The project is structured around three thrusts, each using the computational genomics applications for context. In the first, we build statistical models of program behavior that incorporate scale. In the second, we build statistical techniques for detecting when there is an error and then drilling down to identify potential root causes in the software. In the third, we build a testing tool which will allow us to uncover such scaling issues in an accelerated manner.  In aggregate, the project combines in innovative ways applications of static analysis, dynamic instrumentation, modeling, and machine learning-based data analysis.  The project will use computational genomics applications, such as Blast, Bowtie, Trinity/Butterfly, and Margin, to evaluate the approach.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Milind",
   "pi_last_name": "Kulkarni",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Milind Kulkarni",
   "pi_email_addr": "milind@purdue.edu",
   "nsf_id": "000549148",
   "pi_start_date": "2013-09-13",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Michael",
   "pi_last_name": "Gribskov",
   "pi_mid_init": "R",
   "pi_sufx_name": "",
   "pi_full_name": "Michael R Gribskov",
   "pi_email_addr": "gribskov@purdue.edu",
   "nsf_id": "000434915",
   "pi_start_date": "2013-09-13",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Saurabh",
   "pi_last_name": "Bagchi",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Saurabh Bagchi",
   "pi_email_addr": "sbagchi@purdue.edu",
   "nsf_id": "000309372",
   "pi_start_date": "2013-09-13",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Purdue University",
  "inst_street_address": "2550 NORTHWESTERN AVE # 1100",
  "inst_street_address_2": "",
  "inst_city_name": "WEST LAFAYETTE",
  "inst_state_code": "IN",
  "inst_state_name": "Indiana",
  "inst_phone_num": "7654941055",
  "inst_zip_code": "479061332",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "IN04",
  "org_lgl_bus_name": "PURDUE UNIVERSITY",
  "org_prnt_uei_num": "YRXVL4JYCEF5",
  "org_uei_num": "YRXVL4JYCEF5"
 },
 "perf_inst": {
  "perf_inst_name": "Purdue University",
  "perf_str_addr": "465 Northwestern Ave.",
  "perf_city_name": "West Lafayette",
  "perf_st_code": "IN",
  "perf_st_name": "Indiana",
  "perf_zip_code": "479072035",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "IN04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 260331.0
  },
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 16000.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Genomics is an important area of study that holds the promise of unraveling mysteries of how our genes guide our lives and how personalized gene therapies may be used to treat various medical conditions. The increasing adoption of massively-parallel sequencing technologies, known as next generation sequencing (NGS) technologies, has resulted in a situation where computation has become the bottleneck in our ability to ingest all the genetic information and to synthesize actionable knowledge from this information.</p>\n<p><br /><strong>Intellectual Merit</strong></p>\n<p>We addressed this problem by developing computational approaches, with a focus on the above domain of computational genomics.<br /><br /><strong>Extracting parallelism</strong>. We developed a principled way to extract parallelism from applications. We leveraged the approximate nature of some of these applications (e.g., the DNA sequence match does not need to be exact) to aid in the parallelism. We identified coarse-grained, inter-query parallelism and fine-grained, intra-query parallelism inherent in many of the genomics workflows. We developed parallel building blocks for alignment of genomic sequences, assembly of genomes, and pattern mining for determining regulatory elements in the genome, epigenome, and metagenome.<br /><br /><strong>Modeling</strong>. The quality of the scaling model determines how well our system can predict the behavior of a program at large scales. We extended existing modeling techniques that can capture a wide variety of scaling behaviors and automatically select which program behaviors to track. We also modeled the data dependence that many of the target algorithms exhibit and came up with techniques to quantify the confidence in the output of the model.<br /><br /><strong>Detection and diagnosis</strong>. Because the scaling model captures the relationship between scale and behavior, we used it to predict a program&rsquo;s behavior even when run at a new, heretofore-unseen scale. Thus, discrepancy between the predicted behavior and the observed behavior was an indicator that there is a manifested software bug. By isolating the source of those deviations to particular program behaviors, such as a particular loop&rsquo;s executing too many times, we could localize the source of the bug. The key feature of our approach is that the modeling can be done, efficiently, at small scales, and the model applied for detection and diagnosis at large production scales.</p>\n<p><br /><strong>Broader Impact</strong></p>\n<p>We disseminated the deliverables of the project through open source software, a domain specific language geared toward genomics researchers and practitioners who want to develop scalable and high-performing applications, and tutorials presented at the Biology Division of the Argonne National Laboratory. To further simplify the use of our deliverables, we created a web server that can take queries about which parts of the human epigenome exert a regulatory effect and visualize it. At the backend, this runs a distributed machine learning algorithm that runs a classification task.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 01/15/2017<br>\n\t\t\t\t\tModified by: Milind&nbsp;Kulkarni</p>\n</div>\n<div class=\"porSideCol\">\n<div class=\"each-gallery\">\n<div class=\"galContent\" id=\"gallery0\">\n<div class=\"photoCount\" id=\"photoCount0\">\n\t\t\t\t\t\t\t\t\tImages (<span id=\"selectedPhoto0\">1</span> of <span class=\"totalNumber\"></span>)\t\t\n\t\t\t\t\t\t\t\t</div>\n<div class=\"galControls\" id=\"controls0\"></div>\n<div class=\"galSlideshow\" id=\"slideshow0\"></div>\n<div class=\"galEmbox\" id=\"embox\">\n<div class=\"image-title\"></div>\n</div>\n</div>\n<div class=\"galNavigation\" id=\"navigation0\">\n<ul class=\"thumbs\" id=\"thumbs0\">\n<li>\n<a href=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230488800_sarvavid--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230488800_sarvavid--rgov-800width.jpg\" title=\"Sarvavid genomics DSL\"><img src=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230488800_sarvavid--rgov-66x44.jpg\" alt=\"Sarvavid genomics DSL\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">Many computational genomics applications can be decomposed into reusable software building blocks. Our Domain Specific Language Sarvavid provides such building blocks and enables one to compose them easily, while its compiler infrastructure creates efficient binaries.</div>\n<div class=\"imageCredit\">Project team members</div>\n<div class=\"imagePermisssions\">Public Domain</div>\n<div class=\"imageSubmitted\">Saurabh&nbsp;Bagchi</div>\n<div class=\"imageTitle\">Sarvavid genomics DSL</div>\n</div>\n</li>\n<li>\n<a href=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230903392_dbg--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230903392_dbg--rgov-800width.jpg\" title=\"Vanilla De Brujn graph construction\"><img src=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484230903392_dbg--rgov-66x44.jpg\" alt=\"Vanilla De Brujn graph construction\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">A sample genomic assembly process that uses De Brujn graph for assembly. In this, the algorithm (such as, IDBA or SPAdes) iterates through multiple k values in the k-mer construction. This shows the serial bottleneck in the assembly process which prevents it from working at large scales.</div>\n<div class=\"imageCredit\">Project team members</div>\n<div class=\"imagePermisssions\">Public Domain</div>\n<div class=\"imageSubmitted\">Saurabh&nbsp;Bagchi</div>\n<div class=\"imageTitle\">Vanilla De Brujn graph construction</div>\n</div>\n</li>\n<li>\n<a href=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231131757_dbgk2--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231131757_dbgk2--rgov-800width.jpg\" title=\"Parallel De Brujn graph construction\"><img src=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231131757_dbgk2--rgov-66x44.jpg\" alt=\"Parallel De Brujn graph construction\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">This shows our contribution in doing parallel De Brujn graph construction for genomic assembly. The insight is that the k-mer graphs for different k values can be constructed in parallel and then \"patched up\".</div>\n<div class=\"imageCredit\">Project team members</div>\n<div class=\"imagePermisssions\">Public Domain</div>\n<div class=\"imageSubmitted\">Saurabh&nbsp;Bagchi</div>\n<div class=\"imageTitle\">Parallel De Brujn graph construction</div>\n</div>\n</li>\n<li>\n<a href=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231378392_avishkar--rgov-214x142.jpg\" original=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231378392_avishkar--rgov-800width.jpg\" title=\"Avishkar: Machine learning for identifying genomic regulatory elements\"><img src=\"/por/images/Reports/POR/2017/1337158/1337158_10280114_1484231378392_avishkar--rgov-66x44.jpg\" alt=\"Avishkar: Machine learning for identifying genomic regulatory elements\"></a>\n<div class=\"imageCaptionContainer\">\n<div class=\"imageCaption\">This shows our contribution of distributed machine learning algorithms for mining patterns in the human epigenome to determine which ones affect gene expression levels. Our algorithm runs on a Spark backend and is the first to run on the entire human epigenome based on public dataset from NCBI.</div>\n<div class=\"imageCredit\">Project team members</div>\n<div class=\"imageSubmitted\">Saurabh&nbsp;Bagchi</div>\n<div class=\"imageTitle\">Avishkar: Machine learning for identifying genomic regulatory elements</div>\n</div>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>",
  "por_txt_cntn": "\nGenomics is an important area of study that holds the promise of unraveling mysteries of how our genes guide our lives and how personalized gene therapies may be used to treat various medical conditions. The increasing adoption of massively-parallel sequencing technologies, known as next generation sequencing (NGS) technologies, has resulted in a situation where computation has become the bottleneck in our ability to ingest all the genetic information and to synthesize actionable knowledge from this information.\n\n\nIntellectual Merit\n\nWe addressed this problem by developing computational approaches, with a focus on the above domain of computational genomics.\n\nExtracting parallelism. We developed a principled way to extract parallelism from applications. We leveraged the approximate nature of some of these applications (e.g., the DNA sequence match does not need to be exact) to aid in the parallelism. We identified coarse-grained, inter-query parallelism and fine-grained, intra-query parallelism inherent in many of the genomics workflows. We developed parallel building blocks for alignment of genomic sequences, assembly of genomes, and pattern mining for determining regulatory elements in the genome, epigenome, and metagenome.\n\nModeling. The quality of the scaling model determines how well our system can predict the behavior of a program at large scales. We extended existing modeling techniques that can capture a wide variety of scaling behaviors and automatically select which program behaviors to track. We also modeled the data dependence that many of the target algorithms exhibit and came up with techniques to quantify the confidence in the output of the model.\n\nDetection and diagnosis. Because the scaling model captures the relationship between scale and behavior, we used it to predict a program?s behavior even when run at a new, heretofore-unseen scale. Thus, discrepancy between the predicted behavior and the observed behavior was an indicator that there is a manifested software bug. By isolating the source of those deviations to particular program behaviors, such as a particular loop?s executing too many times, we could localize the source of the bug. The key feature of our approach is that the modeling can be done, efficiently, at small scales, and the model applied for detection and diagnosis at large production scales.\n\n\nBroader Impact\n\nWe disseminated the deliverables of the project through open source software, a domain specific language geared toward genomics researchers and practitioners who want to develop scalable and high-performing applications, and tutorials presented at the Biology Division of the Argonne National Laboratory. To further simplify the use of our deliverables, we created a web server that can take queries about which parts of the human epigenome exert a regulatory effect and visualize it. At the backend, this runs a distributed machine learning algorithm that runs a classification task.\n\n\t\t\t\t\tLast Modified: 01/15/2017\n\n\t\t\t\t\tSubmitted by: Milind Kulkarni"
 }
}