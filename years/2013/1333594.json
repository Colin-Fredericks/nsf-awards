{
 "awd_id": "1333594",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS:CLCCA:Collaborative Research:Harnessing Highly Threaded Hardware for Server Workloads",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2013-09-15",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 341617.0,
 "awd_amount": 341617.0,
 "awd_min_amd_letter_date": "2013-09-11",
 "awd_max_amd_letter_date": "2014-06-09",
 "awd_abstract_narration": "Data centers provide the computational and storage infrastructure required to meet today's ever increasing demand for Internet-based services. Web servers deliver a vast range of information on demand, ranging from static content such as files, images, video and audio streaming services, to dynamic content created via scripting languages (e.g,. PHP) or stand alone C/C++ applications (e.g., search results).  Server performance, scaling and energy efficiency (throughput/Watt) are crucial factors in reducing total cost of ownership (TCO) in today's server-based industries.  Unfortunately, current system designs based on commodity multicore processors may not be the most power/energy efficient for all server workloads.  \r\n\r\nToday?s massively parallel accelerators (e.g., GPUs) provide exceptional performance per Watt for certain workloads versus conventional many core CPUs. Unfortunately, these devices have not found wide-spread general purpose use outside the high-performance computing domain. This project expands the use of massively parallel accelerators to server and operating system-intensive workloads by innovating across the application, runtime, operating system, and architecture layers.\r\n\r\nThis research builds on the observation that server workload execution patterns are not completely unique across multiple requests. The goal of this project is to develop computer systems (software and hardware) that exploit similarity across requests to improve server performance and power/energy efficiency by launching data parallel executions for request cohorts.  The three primary aspects of this research are 1) mapping traditional thread/task parallel workloads onto data parallel hardware, 2) developing a new accelerator-centric operating system architecture, and 3) developing new architectural mechanisms to support this new class of accelerator workloads and operating system software.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Emmett",
   "pi_last_name": "Witchel",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Emmett Witchel",
   "pi_email_addr": "witchel@cs.utexas.edu",
   "nsf_id": "000164959",
   "pi_start_date": "2013-09-11",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Co-Principal Investigator",
   "pi_first_name": "Mark",
   "pi_last_name": "Silberstein",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Mark Silberstein",
   "pi_email_addr": "marks@cs.utexas.edu",
   "nsf_id": "000611398",
   "pi_start_date": "2013-09-11",
   "pi_end_date": "2014-05-05"
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "P.O. Box 7726",
  "perf_city_name": "Austin",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787137726",
  "perf_ctry_code": "US",
  "perf_cong_dist": "37",
  "perf_st_cong_dist": "TX37",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": null,
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 341617.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Today's massively parallel accelerators (e.g., GPUs) provide exceptional performance per Watt for certain workloads compared with conventional many core CPUs.&nbsp; Unfortunately, these devices have not found wide-spread general purpose use outside the high-performance computing domain.&nbsp; This project has developed prototype systems to use parallel accelerators for server-type workloads by innovating across the application, runtime, operating system, and architecture layers.</p>\n<p>GPUs lack software abstractions to direct the flow of data within a system, leaving the developer with only low-level control over I/O. Therefore, certain classes of applications that could benefit from GPU's computational density require unacceptable development costs to realize their full performance potential.</p>\n<p>Major project accomplishments include the GPUnet framework for developing GPU programs that directly control the network.&nbsp; Also, the Rhythm system showed how to exploit similarity across requests to improve server performance and power/energy efficiency by enabling data parallel executions for server code.&nbsp; At UT Austin, the focus has been on supporting operating system abstractions for GPU processors: GPUfs for the file system and GPUnet for the network.</p>\n<p>The intellectual merit of GPUnet comes from defining a native GPU networking layer that provides a socket abstraction and high-level networking APIs to GPU programs. GPUnet enables individual threads in one GPU to communicate with threads in other GPUs or CPUs via standard and familiar socket interfaces, regardless of whether they are in the same or different machines. Native GPU networking cuts the CPU out of GPU-NIC interactions, simplifying code and increasing performance. It also unifies application compute and I/O logic within the GPU program, providing a simpler programming model. GPUnet uses advanced NIC and GPU hardware capabilities and applies sophisticated code optimizations that yield high application performance equal to or exceeding hand-tuned traditional implementations.</p>\n<p>We have quantitatively evaluated GPUnet in two major ways: by building an in-memory MapReduce framework and a face verification server.&nbsp; Our distributed in-GPU-memory MapReduce framework allows GPUs to fully control all of the I/O: they read and write files (via GPUfs), and communicate with other GPUs (via GPUnet).&nbsp; This architecture demonstrates the ability of GPUnet to support complex communication patterns across GPUs, and for the word count and K-means workloads, it scales to four GPUs providing speedups of 2.9-3.5x over a single GPU.</p>\n<p>We build a face verification server that matches images and interacts with a memory cache running on the CPU (memcached) directly from GPU code.&nbsp; The server processes 53K client requests/second on a single NVIDIA K20Xm GPU, exceeding the throughput of a 6-core Intel CPU and a CUDA-based server by 1.5x and 2.3x respectively, while maintaining 3x lower latency than the CPU and requiring half as much code than the other versions.</p>\n<p>The broader impacts of the project come from professional development for students including two doctoral theses, five masters theses, and three undergraduate projects. The ideas in the project have influenced corporate directions at NVIDIA.&nbsp; Finally, work from the project has been integrated into graduate and undergraduate computer systems curricula.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/19/2017<br>\n\t\t\t\t\tModified by: Emmett&nbsp;Witchel</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nToday's massively parallel accelerators (e.g., GPUs) provide exceptional performance per Watt for certain workloads compared with conventional many core CPUs.  Unfortunately, these devices have not found wide-spread general purpose use outside the high-performance computing domain.  This project has developed prototype systems to use parallel accelerators for server-type workloads by innovating across the application, runtime, operating system, and architecture layers.\n\nGPUs lack software abstractions to direct the flow of data within a system, leaving the developer with only low-level control over I/O. Therefore, certain classes of applications that could benefit from GPU's computational density require unacceptable development costs to realize their full performance potential.\n\nMajor project accomplishments include the GPUnet framework for developing GPU programs that directly control the network.  Also, the Rhythm system showed how to exploit similarity across requests to improve server performance and power/energy efficiency by enabling data parallel executions for server code.  At UT Austin, the focus has been on supporting operating system abstractions for GPU processors: GPUfs for the file system and GPUnet for the network.\n\nThe intellectual merit of GPUnet comes from defining a native GPU networking layer that provides a socket abstraction and high-level networking APIs to GPU programs. GPUnet enables individual threads in one GPU to communicate with threads in other GPUs or CPUs via standard and familiar socket interfaces, regardless of whether they are in the same or different machines. Native GPU networking cuts the CPU out of GPU-NIC interactions, simplifying code and increasing performance. It also unifies application compute and I/O logic within the GPU program, providing a simpler programming model. GPUnet uses advanced NIC and GPU hardware capabilities and applies sophisticated code optimizations that yield high application performance equal to or exceeding hand-tuned traditional implementations.\n\nWe have quantitatively evaluated GPUnet in two major ways: by building an in-memory MapReduce framework and a face verification server.  Our distributed in-GPU-memory MapReduce framework allows GPUs to fully control all of the I/O: they read and write files (via GPUfs), and communicate with other GPUs (via GPUnet).  This architecture demonstrates the ability of GPUnet to support complex communication patterns across GPUs, and for the word count and K-means workloads, it scales to four GPUs providing speedups of 2.9-3.5x over a single GPU.\n\nWe build a face verification server that matches images and interacts with a memory cache running on the CPU (memcached) directly from GPU code.  The server processes 53K client requests/second on a single NVIDIA K20Xm GPU, exceeding the throughput of a 6-core Intel CPU and a CUDA-based server by 1.5x and 2.3x respectively, while maintaining 3x lower latency than the CPU and requiring half as much code than the other versions.\n\nThe broader impacts of the project come from professional development for students including two doctoral theses, five masters theses, and three undergraduate projects. The ideas in the project have influenced corporate directions at NVIDIA.  Finally, work from the project has been integrated into graduate and undergraduate computer systems curricula.\n\n \n\n \n\n\t\t\t\t\tLast Modified: 10/19/2017\n\n\t\t\t\t\tSubmitted by: Emmett Witchel"
 }
}