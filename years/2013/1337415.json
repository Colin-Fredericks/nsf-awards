{
 "awd_id": "1337415",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: FP: Program Synthesis for Low-Power Spatial Architectures",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2013-10-01",
 "awd_exp_date": "2017-09-30",
 "tot_intn_awd_amt": 749879.0,
 "awd_amount": 765879.0,
 "awd_min_amd_letter_date": "2013-09-23",
 "awd_max_amd_letter_date": "2015-09-03",
 "awd_abstract_narration": "New computing applications require dramatic increases in the energy efficiency of processors.  These applications include personal health monitoring with wearable body sensors and data processing onboard tiny robotic rescue helicopters.  Energy efficiency allows such applications to run on small batteries, thus achieving the necessary small form factor.  Until recently, energy efficiency was achieved by shrinking transistors.  While the Moore's Law still keeps shrinking transistors, the smaller transistors are no longer significantly more energy efficient than large ones.  As a result, the quest for energy efficiency has shifted from transistor fabrication to designing software and hardware that work well together.  Among key questions is how minimalistic can hardware be without affecting the productivity of programming that hardware.  Minimalistic hardware would not burn energy on tasks that support programmability, so investigating how to compile programs for minimalistic hardware is of increased interest.\r\n\r\nTraditionally, hardware complexity has been hidden under a programming model and a compiler. The less heroic the compiler, the more likely was the technology to succeed (c.f., CUDA's widespread adoption).  Unfortunately, a simple compiler breaks down on hardware without programmability features such as caches.  This proposal investigates extending the compiler with a synthesizer, which has the power to search a space of alternative programs.  The design decision to rely on search frees the compiler writer from having to develop a (deterministic) compilation algorithm.  As a case study, this project addresses the programmability question through a programming framework for a spatial ultra-low-power processor design.  The framework includes a programming model and a synthesis-aided compiler tool chain.  The programming model develops a solver-aided domain specific language (SDSL) that includes constructs for partitioning programs across processor cores.  The SDLS is implemented on the Rosette framework for SDSL construction.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "George",
   "pi_last_name": "Necula",
   "pi_mid_init": "C",
   "pi_sufx_name": "",
   "pi_full_name": "George C Necula",
   "pi_email_addr": "necula@cs.berkeley.edu",
   "nsf_id": "000215459",
   "pi_start_date": "2015-09-03",
   "pi_end_date": null
  },
  {
   "pi_role": "Former Principal Investigator",
   "pi_first_name": "Rastislav",
   "pi_last_name": "Bodik",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Rastislav Bodik",
   "pi_email_addr": "bodik@uw.edu",
   "nsf_id": "000207383",
   "pi_start_date": "2013-09-23",
   "pi_end_date": "2015-09-03"
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Emina",
   "pi_last_name": "Torlak",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Emina Torlak",
   "pi_email_addr": "emina@cs.washington.edu",
   "nsf_id": "000642956",
   "pi_start_date": "2013-09-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Berkeley",
  "inst_street_address": "1608 4TH ST STE 201",
  "inst_street_address_2": "",
  "inst_city_name": "BERKELEY",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "5106433891",
  "inst_zip_code": "947101749",
  "inst_country_name": "United States",
  "cong_dist_code": "12",
  "st_cong_dist_code": "CA12",
  "org_lgl_bus_name": "REGENTS OF THE UNIVERSITY OF CALIFORNIA, THE",
  "org_prnt_uei_num": "",
  "org_uei_num": "GS3YEVSS12N6"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-Berkeley",
  "perf_str_addr": "773 Soda Hall",
  "perf_city_name": "Berkeley",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "947201776",
  "perf_ctry_code": "US",
  "perf_cong_dist": "12",
  "perf_st_cong_dist": "CA12",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "828300",
   "pgm_ele_name": "Exploiting Parallel&Scalabilty"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0113",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001314DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2013,
   "fund_oblg_amt": 749879.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 16000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><span id=\"docs-internal-guid-652cb54d-aac8-de8c-9a29-578dab059523\">\n<p dir=\"ltr\"><span>Project Details</span></p>\n<p dir=\"ltr\"><span>We have designed, built, evaluated, disseminated several programmer tools built on these ideas. These tools are described below, along with their applications related to XPS. </span></p>\n<br />\n<p dir=\"ltr\"><span>Rosette:</span><span> &nbsp;</span><a href=\"https://emina.github.io/rosette/\"><span>Rosette</span></a><span> is a solver-aided programming language that extends </span><a href=\"http://racket-lang.org/\"><span>Racket</span></a><span> with language constructs for program synthesis, verification, and more. To verify or synthesize code, Rosette compiles it to logical constraints solved with off-the-shelf </span><a href=\"http://smtlib.cs.uiowa.edu/\"><span>SMT</span></a><span> solvers. By combining virtualized access to solvers with Racket&rsquo;s metaprogramming, Rosette makes it easy to develop synthesis and verification tools for new languages. You simply write an interpreter for your language in Rosette, and you get the tools for free! &nbsp;We used Rosette to develop the four tools mentioned below. </span></p>\n<br />\n<p dir=\"ltr\"><span>Chlorophyll: </span><a href=\"http://pl.eecs.berkeley.edu/projects/chlorophyll/\"><span>Chlorophyll</span></a><span> is a synthesis-aided compiler for ultra-low-power spatial architectures. The primary goal of the Chlorophyll effort is to develop a new method for constructing compilers that are expected to perform non-traditional optimizations, such code partitioning and code generation for stack-based instruction set architectures (ISAs). &nbsp;The goal was to produce compilers that generate high-efficiency code while producing these compilers rapidly. &nbsp;</span></p>\n<br />\n<p dir=\"ltr\"><span>GreenThumb: </span><a href=\"http://pl.eecs.berkeley.edu/projects/greenthumb/\"><span>GreenThumb</span></a><span> is a framework for building superoptimizers. A superoptimizer is a special kind of synthesizer that generates optimal sequences of instructions by searching all possible sequences of instructions. &nbsp;GreenThumb was designed to be portable to new target ISAs. The framework provides an efficient cooperative search strategy that combines unique properties of superoptimization algorithms, namely symbolic, stochastic, and enumerative algorithms. &nbsp;Additionally, GreenThumb executes parallel instances of these algorithms, making them communicate their results. Among the alternative strategies is our new enumerative search technique, called LENS, that rapidly prunes away invalid candidate programs by applying selective refinement and bidirectional search.</span></p>\n<br />\n<p dir=\"ltr\"><span>MemSynth: </span><span>MemSynth is the first system for automatic synthesis of axiomatic memory model specifications from litmus tests. MemSynth provides an expressive language for specifying the axioms that define a class of memory models, sketching a memory model specification within that class, and writing litmus tests for the desired model. Its synthesis engine takes the axioms, sketch, and tests as input, and searches for a memory model (if any) that gives the desired outcomes on all tests. The MemSynth engine is an optimized deep embedding of bounded relational logic in Rosette, and solves complex synthesis queries intractable to existing solvers. This design also enables MemSynth to solve novel queries, such as a uniqueness check to discover ambiguities in memory model specifications.</span></p>\n<br />\n<p dir=\"ltr\"><span>Ferrite:</span><span> </span><span>We developed crash-consistency models, analogous to memory consistency models, which describe the behavior of a file system across crashes. </span><a href=\"http://sandcat.cs.washington.edu/ferrite/\"><span>Ferrite</span></a><span> is a toolkit for validating those models against real file system implementations. We develop a crash-consistency model for ext4, and use Ferrite to demonstrate unintuitive crash behaviors of the ext4 implementation. To demonstrate the utility of crash-consistency models to application writers, we use our models to prototype proof-of-concept verification and synthesis tools, as well as new library interfaces for crash-safe applications.</span></p>\n<br />\n<p dir=\"ltr\"><span>Floem: </span><span>Floem is a programming system for NIC-accelerated network applications. Offloading data center applications to programmable NICs is becoming increasingly popular because of both performance and energy benefits. Collaborating with networking and system researchers at the University of Washington, we designed a programming model that facilitates design space explorations by introducing convenient constructs for programmers to map computation to hardware resources (i.e., a CPU and a NIC), parallelize program components, and restructure the program to enable lock-free communication when possible. To ease programming across the CPU-NIC boundary, the language hides packet marshaling under an illusion of shared address space, and the runtime hides complicated DMA access optimization details under the abstraction of coherent shared memory tailored to implementing concurrent queues. </span></p>\n<br />\n<p dir=\"ltr\"><span>Broader Impacts</span></p>\n<p dir=\"ltr\"><span>Our project has had impacts beyond the project itself. Several PhD students and one undergraduate researchers worked on the project and through their involvement obtained access to an interdisciplinary array projects that span formal methods, parallel programming, low-power computing, networking, and language design. They were also exposed to co-advising with advisors from a variety of disciplines within the broader area of programming systems. </span></p>\n<br />\n<p dir=\"ltr\"><span>In the private sector, the GreenThumb generator of super-optimizers was transferred to Reservoir Labs, for a proprietary high-performance architecture and to a small consulting company who works with customers needing highly optimized code kernels.</span></p>\n<br />\n<p dir=\"ltr\"><span>And in the medical field, Rosette was used to verify correctness of an proton therapy radiation machine at the University of Washington. </span></p>\n<br />\n<p dir=\"ltr\"><span>We released five different open-source software: Rosette, Chlorophyll, GreenThumb, MemSynth, Ferrite. </span></p>\n<div><span><br /></span></div>\n</span></p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/30/2017<br>\n\t\t\t\t\tModified by: Emina&nbsp;Torlak</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n\nProject Details\nWe have designed, built, evaluated, disseminated several programmer tools built on these ideas. These tools are described below, along with their applications related to XPS. \n\n\nRosette:  Rosette is a solver-aided programming language that extends Racket with language constructs for program synthesis, verification, and more. To verify or synthesize code, Rosette compiles it to logical constraints solved with off-the-shelf SMT solvers. By combining virtualized access to solvers with Racket?s metaprogramming, Rosette makes it easy to develop synthesis and verification tools for new languages. You simply write an interpreter for your language in Rosette, and you get the tools for free!  We used Rosette to develop the four tools mentioned below. \n\n\nChlorophyll: Chlorophyll is a synthesis-aided compiler for ultra-low-power spatial architectures. The primary goal of the Chlorophyll effort is to develop a new method for constructing compilers that are expected to perform non-traditional optimizations, such code partitioning and code generation for stack-based instruction set architectures (ISAs).  The goal was to produce compilers that generate high-efficiency code while producing these compilers rapidly.  \n\n\nGreenThumb: GreenThumb is a framework for building superoptimizers. A superoptimizer is a special kind of synthesizer that generates optimal sequences of instructions by searching all possible sequences of instructions.  GreenThumb was designed to be portable to new target ISAs. The framework provides an efficient cooperative search strategy that combines unique properties of superoptimization algorithms, namely symbolic, stochastic, and enumerative algorithms.  Additionally, GreenThumb executes parallel instances of these algorithms, making them communicate their results. Among the alternative strategies is our new enumerative search technique, called LENS, that rapidly prunes away invalid candidate programs by applying selective refinement and bidirectional search.\n\n\nMemSynth: MemSynth is the first system for automatic synthesis of axiomatic memory model specifications from litmus tests. MemSynth provides an expressive language for specifying the axioms that define a class of memory models, sketching a memory model specification within that class, and writing litmus tests for the desired model. Its synthesis engine takes the axioms, sketch, and tests as input, and searches for a memory model (if any) that gives the desired outcomes on all tests. The MemSynth engine is an optimized deep embedding of bounded relational logic in Rosette, and solves complex synthesis queries intractable to existing solvers. This design also enables MemSynth to solve novel queries, such as a uniqueness check to discover ambiguities in memory model specifications.\n\n\nFerrite: We developed crash-consistency models, analogous to memory consistency models, which describe the behavior of a file system across crashes. Ferrite is a toolkit for validating those models against real file system implementations. We develop a crash-consistency model for ext4, and use Ferrite to demonstrate unintuitive crash behaviors of the ext4 implementation. To demonstrate the utility of crash-consistency models to application writers, we use our models to prototype proof-of-concept verification and synthesis tools, as well as new library interfaces for crash-safe applications.\n\n\nFloem: Floem is a programming system for NIC-accelerated network applications. Offloading data center applications to programmable NICs is becoming increasingly popular because of both performance and energy benefits. Collaborating with networking and system researchers at the University of Washington, we designed a programming model that facilitates design space explorations by introducing convenient constructs for programmers to map computation to hardware resources (i.e., a CPU and a NIC), parallelize program components, and restructure the program to enable lock-free communication when possible. To ease programming across the CPU-NIC boundary, the language hides packet marshaling under an illusion of shared address space, and the runtime hides complicated DMA access optimization details under the abstraction of coherent shared memory tailored to implementing concurrent queues. \n\n\nBroader Impacts\nOur project has had impacts beyond the project itself. Several PhD students and one undergraduate researchers worked on the project and through their involvement obtained access to an interdisciplinary array projects that span formal methods, parallel programming, low-power computing, networking, and language design. They were also exposed to co-advising with advisors from a variety of disciplines within the broader area of programming systems. \n\n\nIn the private sector, the GreenThumb generator of super-optimizers was transferred to Reservoir Labs, for a proprietary high-performance architecture and to a small consulting company who works with customers needing highly optimized code kernels.\n\n\nAnd in the medical field, Rosette was used to verify correctness of an proton therapy radiation machine at the University of Washington. \n\n\nWe released five different open-source software: Rosette, Chlorophyll, GreenThumb, MemSynth, Ferrite. \n\n\n\n\n \n\n\t\t\t\t\tLast Modified: 12/30/2017\n\n\t\t\t\t\tSubmitted by: Emina Torlak"
 }
}