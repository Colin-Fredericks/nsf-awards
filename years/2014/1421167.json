{
 "awd_id": "1421167",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF:Small:Designing Architectures to be Formally Verifiable",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2014-08-15",
 "awd_exp_date": "2018-07-31",
 "tot_intn_awd_amt": 340000.0,
 "awd_amount": 348000.0,
 "awd_min_amd_letter_date": "2014-08-14",
 "awd_max_amd_letter_date": "2016-04-29",
 "awd_abstract_narration": "Computer systems are exceedingly complicated, and a major challenge is\r\nverifying that they are correct in all situations.  Hardware industry\r\naccordingly spends more effort on verification than it does on actual\r\ndesign, yet functional design bugs still exist in today's computer\r\nsystems, including shipped processor chips from major vendors.  This\r\nproject seeks to overcome this verification challenge through a\r\nverification-aware design methodology.  \r\n\r\nThis project designs systems such that they can be verified with existing \r\nformal verification methodologies, rather than expecting arbitrary designs \r\nto be verifiable.  Rather than design a system and then try to verify it, \r\nthe proposed philosophy is to understand the capabilities of existing verification \r\nmethodologies and then try to design the best possible systems that are compatible\r\nwith these methodologies. In this work, the verification is performed \r\nwith existing verification tools and the innovation is in the design.  \r\nThe broad impact of this work is the development of computer systems, \r\nor portions thereof, that are formally verified and thus provably correct \r\nin all cases.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Daniel",
   "pi_last_name": "Sorin",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Daniel Sorin",
   "pi_email_addr": "sorin@ee.duke.edu",
   "nsf_id": "000280417",
   "pi_start_date": "2014-08-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Duke University",
  "inst_street_address": "2200 W MAIN ST",
  "inst_street_address_2": "",
  "inst_city_name": "DURHAM",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "9196843030",
  "inst_zip_code": "277054640",
  "inst_country_name": "United States",
  "cong_dist_code": "04",
  "st_cong_dist_code": "NC04",
  "org_lgl_bus_name": "DUKE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "TP7EK8DZV6N5"
 },
 "perf_inst": {
  "perf_inst_name": "Duke University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "277080291",
  "perf_ctry_code": "US",
  "perf_cong_dist": "04",
  "perf_st_cong_dist": "NC04",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "8206",
   "pgm_ref_txt": "Formal Methods and Verification"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 340000.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>One of the most difficult aspects of designing a computer processor is verifying that the design is correct.&nbsp; Processors are extremely complicated and it is often difficult, if not impossible, to fully verify that the design is bug-free.&nbsp; Typically, computer architects design the processors so as to maximize performance and minimize power consumption, and then the verification team tries to find as many bugs as possible before shipping the product.<br />In this project, we have made verifiability a key goal, such that we are designing the processors so as to be provably verifiable.&nbsp; Our goal is formal (mathematical) verification that the processor is bug-free, and not simply testing in search of bugs, which is never complete for systems this complicated.&nbsp; Initially, we assumed that we were starting with the best available formal theory and tools for formal verification, and we figured out how to design parts of the processor such that they could be verified with existing tools.&nbsp; We focused on protocols, both for power management and for cache coherence, which is a mechanism for keeping data up-to-date in the many small on-chip memories.&nbsp; Protocols are notoriously difficult to verify, particularly for large numbers of processor cores.&nbsp; However we showed how to design protocols such that they could be verified in a way that isi ndependent of the number of cores.&nbsp; We immplemented these protocols and experimentally evaluated them to show that verifiability need not cost much performance.</p>\n<p><br />These new protocols were very exciting, because they were the first protocols that were verifiable and \"flat\", in that there was one manager and a large number of peers cores.&nbsp; Prior work by the PI showed how to design verifiable hierarchical protocols that were organized as tall, skinny trees (each parent could have only two children).&nbsp; These two classes of verifiable protocols are extremes, and we decided we wanted arbitrary hierarchies of protocols.&nbsp; To do this, we had to develop a new theory that proves, mathematically, why such protocols could be verified in a scalable fashion.</p>\n<p>The results of this research project are very exciting.&nbsp; Previously, nobody had shown how to design realistic protocols that could be verified for arbitrary numbers of processor cores.&nbsp; Industry had been using testing to find bugs (which is an incomplete process) and formal verification only on tiny system models with only a handful of cores. Industry already spends more money on verification than design and they still have bugs; our work shows a path towards verifiability, and we expect it to change how the industry designs protocols.</p>\n<p><br />This inter-disciplinary research--in both computer architecture and verification--has had numerous broader impacts.&nbsp; The research, both inarchitecture and theory, was disseminated to both research communities in their top conferences.&nbsp; The technology was transferred to industry in two respects.&nbsp; First, the lead graduate student, Dr. Opeoluwa Matthews, spent an internship at Intel in a verification group. Seccond, we worked with colleagues at Intel on our new theory.&nbsp; The project trained Dr. Matthews, an under-represented minority, in research and communication, and he is now pursuing a postdoc at Princeton University, with a goal of becoming a professor.&nbsp; If successful, Dr. Matthews would become one of a very small number of black faculty in computer architecture.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/03/2018<br>\n\t\t\t\t\tModified by: Daniel&nbsp;Sorin</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nOne of the most difficult aspects of designing a computer processor is verifying that the design is correct.  Processors are extremely complicated and it is often difficult, if not impossible, to fully verify that the design is bug-free.  Typically, computer architects design the processors so as to maximize performance and minimize power consumption, and then the verification team tries to find as many bugs as possible before shipping the product.\nIn this project, we have made verifiability a key goal, such that we are designing the processors so as to be provably verifiable.  Our goal is formal (mathematical) verification that the processor is bug-free, and not simply testing in search of bugs, which is never complete for systems this complicated.  Initially, we assumed that we were starting with the best available formal theory and tools for formal verification, and we figured out how to design parts of the processor such that they could be verified with existing tools.  We focused on protocols, both for power management and for cache coherence, which is a mechanism for keeping data up-to-date in the many small on-chip memories.  Protocols are notoriously difficult to verify, particularly for large numbers of processor cores.  However we showed how to design protocols such that they could be verified in a way that isi ndependent of the number of cores.  We immplemented these protocols and experimentally evaluated them to show that verifiability need not cost much performance.\n\n\nThese new protocols were very exciting, because they were the first protocols that were verifiable and \"flat\", in that there was one manager and a large number of peers cores.  Prior work by the PI showed how to design verifiable hierarchical protocols that were organized as tall, skinny trees (each parent could have only two children).  These two classes of verifiable protocols are extremes, and we decided we wanted arbitrary hierarchies of protocols.  To do this, we had to develop a new theory that proves, mathematically, why such protocols could be verified in a scalable fashion.\n\nThe results of this research project are very exciting.  Previously, nobody had shown how to design realistic protocols that could be verified for arbitrary numbers of processor cores.  Industry had been using testing to find bugs (which is an incomplete process) and formal verification only on tiny system models with only a handful of cores. Industry already spends more money on verification than design and they still have bugs; our work shows a path towards verifiability, and we expect it to change how the industry designs protocols.\n\n\nThis inter-disciplinary research--in both computer architecture and verification--has had numerous broader impacts.  The research, both inarchitecture and theory, was disseminated to both research communities in their top conferences.  The technology was transferred to industry in two respects.  First, the lead graduate student, Dr. Opeoluwa Matthews, spent an internship at Intel in a verification group. Seccond, we worked with colleagues at Intel on our new theory.  The project trained Dr. Matthews, an under-represented minority, in research and communication, and he is now pursuing a postdoc at Princeton University, with a goal of becoming a professor.  If successful, Dr. Matthews would become one of a very small number of black faculty in computer architecture.\n\n\t\t\t\t\tLast Modified: 08/03/2018\n\n\t\t\t\t\tSubmitted by: Daniel Sorin"
 }
}