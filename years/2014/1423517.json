{
 "awd_id": "1423517",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SEL: Small: Crowdsourced Software Engineering using Gamification",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2014-09-01",
 "awd_exp_date": "2018-12-31",
 "tot_intn_awd_amt": 475000.0,
 "awd_amount": 475000.0,
 "awd_min_amd_letter_date": "2014-06-13",
 "awd_max_amd_letter_date": "2018-07-20",
 "awd_abstract_narration": "Software engineering becomes more economically crucial every day, cutting across virtually all industries and scientific disciplines. Indeed, it has become so crucial that there are more tasks in software design, development, testing, maintenance, and analysis than our existing software engineering workforce can hope to accomplish.  Various solutions have been proposed: for example, making programmers more productive, making programmers less error prone, training programmers more effectively, training programmers from a younger age, and so on.  All innovations in this space can be characterized as either tools that assist skilled professionals or innovations that help train novices to be skilled professionals.\r\n\r\nA novel hybrid approach is proposed: Tools that assist skilled professionals while simultaneously training novices to be skilled professionals.  In short, it is proposed to build interfaces that make it possible to crowdsource software engineering tasks.  Such interfaces would assist skilled software engineers by allowing them to discharge some of their professional workload; and it would assist the unskilled crowd by paying them to become more skillful at solving software engineering problems.  A principle technique proposed in crowdsourcing is gamification.   Crowdsourcing will consist of two mutually dependent parts: 1) a gaming interface that allows human beings to leverage their natural problem-solving abilities on the engineering task at hand, and 2) automated pre-processing and post-processing algorithms for tasks such as decomposing the problem into smaller pieces, combining solutions, or helping with automated code generation.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "William",
   "pi_last_name": "Griswold",
   "pi_mid_init": "G",
   "pi_sufx_name": "",
   "pi_full_name": "William G Griswold",
   "pi_email_addr": "wgg@cs.ucsd.edu",
   "nsf_id": "000202359",
   "pi_start_date": "2014-06-13",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Sorin",
   "pi_last_name": "Lerner",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Sorin Lerner",
   "pi_email_addr": "lerner@cs.ucsd.edu",
   "nsf_id": "000068847",
   "pi_start_date": "2014-06-13",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-San Diego",
  "inst_street_address": "9500 GILMAN DR",
  "inst_street_address_2": "",
  "inst_city_name": "LA JOLLA",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "8585344896",
  "inst_zip_code": "920930021",
  "inst_country_name": "United States",
  "cong_dist_code": "50",
  "st_cong_dist_code": "CA50",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, SAN DIEGO",
  "org_prnt_uei_num": "",
  "org_uei_num": "UYTTZT6G9DT1"
 },
 "perf_inst": {
  "perf_inst_name": "University of California-San Diego",
  "perf_str_addr": "9500 Gilman Drive",
  "perf_city_name": "La Jolla",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "920930404",
  "perf_ctry_code": "US",
  "perf_cong_dist": "50",
  "perf_st_cong_dist": "CA50",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 475000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software engineering becomes more economically crucial every day,   cutting across virtually all industries and scientific disciplines.   Indeed, it has become so crucial that there are more tasks in software   design, development, testing, maintenance, and analysis than our existing software engineering workforce can hope to accomplish.</p>\n<p>This  project explored the possibility of \"crowdsourcing\" software   engineering tasks to people of any walk of life by turning the tasks   into engaging computer games supported by sophisticated computing   infrastructure.&nbsp; The primary result of this project is that complex   software engineering tasks -- with some assumptions -- can be gamified.&nbsp;   This was demonstrated in a series of four projects, summarized below.</p>\n<p>1.  Proof Game. It was shown that simple mathematical proofs could be   achieved by play a puzzle piece game.&nbsp; The shapes of the pieces  entailed  logical properties, and when assembled properly constituted  the proof,  winning the game.&nbsp; Experiments showed that high school  students could  successfully play the game without knowing the  underlying logical  system.</p>\n<p>2. Minecraft Programming Environment.&nbsp; It was demonstrated  that an  existing exploratory gaming environment, Minecraft, could be  turned  into a programming environment for school-age children, by adapting a   prexisting drag-and-drop \"blocks\" language to use Minecraft   primitives.&nbsp; Complex structures could be built in the Minecraft world   through the use of iterative constructs.</p>\n<p>3. Programming Game.&nbsp; It  was demonstrated that it was possible to synthesize a computer program  by playing a game.&nbsp; The game was a bit like a Mario Brothers scroller,  but at your own pace.&nbsp; The object of the game was, given a set of  initial numbers (\"inputs\"), to go through a set of game steps that would  produce a set of goal numbers (\"outputs\").&nbsp; A critial insight was how  to synthesize recursion (a form of looping), which was necessary to be  able to concisely process or produce a list of values.&nbsp; This was  achieved by dropping through a worm hole that landing the player in  another instance, or level, of the game.&nbsp; Solving this level synthesized  the base case of the recursion.</p>\n<p>4. Invariants Game.&nbsp; A  game was developed in which players  unwittingly provide a loop invariant  -- a property that holds over every  iteration of a loop.&nbsp; The idea was  to execute the loop and show the  player the data from several  iterations, then having the player write a  simple algebraic formula  describing any observed patterns.&nbsp; Players do  not see the code itself.&nbsp;  Players reruited online were able to find  loop invariants that  best-in-class automated tools could not.&nbsp; A  competitive multi-player  version of this game was found to be very  engaging for the players.</p>\n<p>The project generated a number of broader impacts.&nbsp; The project trained  four graduate students in the techniques of crowdsourcing, gamification,  and program verfication.&nbsp; One student wrote a masters thesis on the  topic. Two others wrote Ph.D. dissertations on the topic of gamification  of software engineering.&nbsp; One of these students is the co-founder and CEO of an after-school computer science education company, ThoughtSTEM.&nbsp; The project also mentored four  undergraduates, and gave one Ph.D. student training in student mentoring.&nbsp; Finally, the invariants game was published on Facebook games,  exposing the general public to our work.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 04/09/2019<br>\n\t\t\t\t\tModified by: William&nbsp;G&nbsp;Griswold</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware engineering becomes more economically crucial every day,   cutting across virtually all industries and scientific disciplines.   Indeed, it has become so crucial that there are more tasks in software   design, development, testing, maintenance, and analysis than our existing software engineering workforce can hope to accomplish.\n\nThis  project explored the possibility of \"crowdsourcing\" software   engineering tasks to people of any walk of life by turning the tasks   into engaging computer games supported by sophisticated computing   infrastructure.  The primary result of this project is that complex   software engineering tasks -- with some assumptions -- can be gamified.    This was demonstrated in a series of four projects, summarized below.\n\n1.  Proof Game. It was shown that simple mathematical proofs could be   achieved by play a puzzle piece game.  The shapes of the pieces  entailed  logical properties, and when assembled properly constituted  the proof,  winning the game.  Experiments showed that high school  students could  successfully play the game without knowing the  underlying logical  system.\n\n2. Minecraft Programming Environment.  It was demonstrated  that an  existing exploratory gaming environment, Minecraft, could be  turned  into a programming environment for school-age children, by adapting a   prexisting drag-and-drop \"blocks\" language to use Minecraft   primitives.  Complex structures could be built in the Minecraft world   through the use of iterative constructs.\n\n3. Programming Game.  It  was demonstrated that it was possible to synthesize a computer program  by playing a game.  The game was a bit like a Mario Brothers scroller,  but at your own pace.  The object of the game was, given a set of  initial numbers (\"inputs\"), to go through a set of game steps that would  produce a set of goal numbers (\"outputs\").  A critial insight was how  to synthesize recursion (a form of looping), which was necessary to be  able to concisely process or produce a list of values.  This was  achieved by dropping through a worm hole that landing the player in  another instance, or level, of the game.  Solving this level synthesized  the base case of the recursion.\n\n4. Invariants Game.  A  game was developed in which players  unwittingly provide a loop invariant  -- a property that holds over every  iteration of a loop.  The idea was  to execute the loop and show the  player the data from several  iterations, then having the player write a  simple algebraic formula  describing any observed patterns.  Players do  not see the code itself.   Players reruited online were able to find  loop invariants that  best-in-class automated tools could not.  A  competitive multi-player  version of this game was found to be very  engaging for the players.\n\nThe project generated a number of broader impacts.  The project trained  four graduate students in the techniques of crowdsourcing, gamification,  and program verfication.  One student wrote a masters thesis on the  topic. Two others wrote Ph.D. dissertations on the topic of gamification  of software engineering.  One of these students is the co-founder and CEO of an after-school computer science education company, ThoughtSTEM.  The project also mentored four  undergraduates, and gave one Ph.D. student training in student mentoring.  Finally, the invariants game was published on Facebook games,  exposing the general public to our work.\n\n\t\t\t\t\tLast Modified: 04/09/2019\n\n\t\t\t\t\tSubmitted by: William G Griswold"
 }
}