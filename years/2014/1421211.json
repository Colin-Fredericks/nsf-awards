{
 "awd_id": "1421211",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Generation of Scientific Software Libraries",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927841",
 "po_email": "sgreensp@nsf.gov",
 "po_sign_block_name": "Sol Greenspan",
 "awd_eff_date": "2014-07-15",
 "awd_exp_date": "2020-06-30",
 "tot_intn_awd_amt": 515517.0,
 "awd_amount": 515517.0,
 "awd_min_amd_letter_date": "2014-07-10",
 "awd_max_amd_letter_date": "2019-05-02",
 "awd_abstract_narration": "Making experts more productive is critically important to software development.  This is particularly so in Scientific Computing (SC) where experts are rare and whose task is to develop software libraries on which SC research in academia, government labs, and industry depends. This project strives to create programming practices and tools that will revolutionize library development in SC.  By encoding expert knowledge about the science, mathematics, and software of a domain, a transformative approach called Design by Transformation (DxT) can automatically generate software that experts would have to write manually. DxT-generation is faster, cheaper, and produces better-trusted code.  In dense linear algebra libraries, DxT has exposed errors in manually-written code and found faster algorithms than those produced by experts. \r\n\r\nThis research applies DxT to three new software domains: fault-tolerant dense linear algebra, graph analysis, and tensor computation.  While improving the performance of their software libraries will itself have an impact in national labs and industry, the lessons learned about automating software development will have broad effects.  SC software is growing more complicated as hardware complexity evolves (e.g., multi-core, many-core, co-processors, and GPUs). Automatic generation will aid experts in being more productive in this increasingly complicated engineering endeavor. It will enable American scientists and engineers to maintain their advantage in scientific library engineering.  Further, there is evidence that the DxT approach to engineering has a pedagogical value in teaching students and new engineers about software.  Encoding new domains will test these benefits.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Don",
   "pi_last_name": "Batory",
   "pi_mid_init": "S",
   "pi_sufx_name": "",
   "pi_full_name": "Don S Batory",
   "pi_email_addr": "batory@cs.utexas.edu",
   "nsf_id": "000279420",
   "pi_start_date": "2014-07-10",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Robert",
   "pi_last_name": "van de Geijn",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Robert A van de Geijn",
   "pi_email_addr": "rvdg@cs.utexas.edu",
   "nsf_id": "000336892",
   "pi_start_date": "2014-07-10",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "101 E. 27th Street, Suite 5.300",
  "perf_city_name": "Austin",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787121532",
  "perf_ctry_code": "US",
  "perf_cong_dist": "25",
  "perf_st_cong_dist": "TX25",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "689200",
   "pgm_ele_name": "CI REUSE"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7433",
   "pgm_ref_txt": "CyberInfra Frmwrk 21st (CIF21)"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 515517.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p><strong>1.&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>Uniform Random Sampling of SPL Configuration Spaces</strong></p>\n<p>A <strong>feature </strong>is an increment in product functionality. Every&nbsp;<strong>software product line (SPL)</strong>&nbsp;has a \"feature model\" that defines all legal combinations of features called&nbsp;<strong>configurations</strong>.&nbsp; Commercial SPLs have colossal product spaces; BusyBox (UNIX utilities for embedded Linux) has a space of 10^240 configurations.&nbsp; That's 10^149 greater than the estimated number of photons in the universe (10^91).</p>\n<p>Why is counting the size of configuration spaces important?&nbsp; Ans:&nbsp;<strong>&nbsp;</strong>Because we can use it to U<strong>niformly Random Sample (URS)</strong> SPL configurations. If C is the configuration space for an SPL and |C| is the size of this space, we can generate a random number j in [1..|C|], where all numbers in this interval are equally likely to be selected.&nbsp; The trick was to create a 1-to-1 mapping with numbers in [1..|C|] and configurations in C.&nbsp; (See papers for details).</p>\n<p>Why is&nbsp;URS&nbsp;important?&nbsp; URS provides accurate mathematical predictions about properties of a space. Most configuration space-sampling algorithms are NOT uniform.&nbsp; Yes, statistics can indeed be collected from such sampling efforts, but if samples are biased, so too are the results.&nbsp; URS is a scientific way to produce accurate estimates with accurate bounds.</p>\n<p>How can URS be used? Ex: How does one find a near-optimal configuration in a colossal 10^100 space?&nbsp; Probability tells us that n uniform samples will be (on average) distributed evenly in a space.&nbsp; We have proven that best performing sample out of n will be in the top 1/(n+1) percentile of all configurations on average --&nbsp;<strong>no matter how large the space</strong>.&nbsp; So, if one takes n=99 samples, the best performing sample will be on average in the top 1% of the space.&nbsp;</p>\n<p>Our extended analysis defines the sample set size for a given accuracy and confidence. For example: we have proven that the best-performing configuration in n=149 samples is in the top 2% of all configurations with 95% confidence --&nbsp;<strong>no matter how large the space.</strong>&nbsp;We believe this work will be basic to the area of sampling SPL configuration spaces.</p>\n<p><strong>2.&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>A Pure-Java Replacement for OCL and Model Transformation Languages for MDE</strong></p>\n<p>A central issue in&nbsp;<strong>Model Driven Engineering (MDE)</strong>&nbsp;is tooling: How can MDE tools be easier to use, maintain, and learn?&nbsp; OCL is a standard language in MDE to express metamodel constraints. Since its inception, OCL has been rightly criticized for being complicated, over-engineered, and difficult to learn. We discovered that an equally-powerful and syntactically similar language based on relational algebra can replace OCL. We call this language Aocl.</p>\n<p>Aocl is a Java package that is MDE-generated from the class diagram of the target MDE metamodel.&nbsp; Aocl can be used to write OCL-like constraints and model transformations in pure-Java using a standard Java IDE. The theoretical foundation for Aocl is Category Theory. Aocl was central to the next and last topic addressed.</p>\n<p><strong>3.&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>Verification of MDE Refactorings</strong></p>\n<p>An MDE metamodel M is an ordered pair [C,A], where C is a class diagram and A denotes Aocl constraints that must be satisfied by C instances. A metamodel refactoring R transforms one metamodel M0=[C0,A0] to another M1=[C1,A1], R(M0)=M1, by refactoring its class diagram, R(C0)=C1, and its constraints R(A0)=A1.&nbsp; Further, every refactoring R is an&nbsp;<strong>identity</strong>&nbsp;in the universe of metamodels.&nbsp; We say R translates M0 (defined at time 0) to M1 (defined at time 1), and the inverse of R translates M1 at time 1 to M0 at time 0.</p>\n<p>We used the Coq theorem prover to verify common MDE class diagram refactorings (pullup, move attribute, split-class, etc.)&nbsp; The key to the proofs is model data preservation and that every refactoring has an inverse.</p>\n<p>Refactoring constraints was harder.&nbsp; Refactorings remove classes, associations, and attributes and add others.&nbsp; Because UML class diagrams are static, dynamically restoring elements removed by refactorings is hard (unlike database systems where reproducing tables that were removed by a refactoring is easy).&nbsp; So instead of refactoring a constraint A0 forward in time to A1, we instead translate an M1 database m1 backwards in time to m0=R^-1(m1) so that A0 can be evaluated on m0.&nbsp; We call this&nbsp;<strong><em>time travel</em></strong>.</p>\n<p>A history of M0 is a sequence of refactorings R1, R2, &hellip; Rn that maps M0 to Mn, which we have demonstrated time travel.&nbsp; We have also generalized a history to interleave edits (class, association, and attribute insertions and deletions) with refactorings.</p>\n<p>Why couldn&rsquo;t we transform constraints from a prior time (A0) to a future time (An)?&nbsp; Refactorings remove classes, associations, and attributes and replace them with other classes, associations, and attributes.&nbsp; Unlike relational algebra where tables removed-by-refactoring can be recomputed on-demand, class diagrams are static; they do not admit dynamically created elements.&nbsp; Given this limitation, it was difficult to emulate dynamically created elements.&nbsp; We gave up because found it was too hard.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/09/2020<br>\n\t\t\t\t\tModified by: Don&nbsp;S&nbsp;Batory</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\n1.    Uniform Random Sampling of SPL Configuration Spaces\n\nA feature is an increment in product functionality. Every software product line (SPL) has a \"feature model\" that defines all legal combinations of features called configurations.  Commercial SPLs have colossal product spaces; BusyBox (UNIX utilities for embedded Linux) has a space of 10^240 configurations.  That's 10^149 greater than the estimated number of photons in the universe (10^91).\n\nWhy is counting the size of configuration spaces important?  Ans:  Because we can use it to Uniformly Random Sample (URS) SPL configurations. If C is the configuration space for an SPL and |C| is the size of this space, we can generate a random number j in [1..|C|], where all numbers in this interval are equally likely to be selected.  The trick was to create a 1-to-1 mapping with numbers in [1..|C|] and configurations in C.  (See papers for details).\n\nWhy is URS important?  URS provides accurate mathematical predictions about properties of a space. Most configuration space-sampling algorithms are NOT uniform.  Yes, statistics can indeed be collected from such sampling efforts, but if samples are biased, so too are the results.  URS is a scientific way to produce accurate estimates with accurate bounds.\n\nHow can URS be used? Ex: How does one find a near-optimal configuration in a colossal 10^100 space?  Probability tells us that n uniform samples will be (on average) distributed evenly in a space.  We have proven that best performing sample out of n will be in the top 1/(n+1) percentile of all configurations on average -- no matter how large the space.  So, if one takes n=99 samples, the best performing sample will be on average in the top 1% of the space. \n\nOur extended analysis defines the sample set size for a given accuracy and confidence. For example: we have proven that the best-performing configuration in n=149 samples is in the top 2% of all configurations with 95% confidence -- no matter how large the space. We believe this work will be basic to the area of sampling SPL configuration spaces.\n\n2.    A Pure-Java Replacement for OCL and Model Transformation Languages for MDE\n\nA central issue in Model Driven Engineering (MDE) is tooling: How can MDE tools be easier to use, maintain, and learn?  OCL is a standard language in MDE to express metamodel constraints. Since its inception, OCL has been rightly criticized for being complicated, over-engineered, and difficult to learn. We discovered that an equally-powerful and syntactically similar language based on relational algebra can replace OCL. We call this language Aocl.\n\nAocl is a Java package that is MDE-generated from the class diagram of the target MDE metamodel.  Aocl can be used to write OCL-like constraints and model transformations in pure-Java using a standard Java IDE. The theoretical foundation for Aocl is Category Theory. Aocl was central to the next and last topic addressed.\n\n3.    Verification of MDE Refactorings\n\nAn MDE metamodel M is an ordered pair [C,A], where C is a class diagram and A denotes Aocl constraints that must be satisfied by C instances. A metamodel refactoring R transforms one metamodel M0=[C0,A0] to another M1=[C1,A1], R(M0)=M1, by refactoring its class diagram, R(C0)=C1, and its constraints R(A0)=A1.  Further, every refactoring R is an identity in the universe of metamodels.  We say R translates M0 (defined at time 0) to M1 (defined at time 1), and the inverse of R translates M1 at time 1 to M0 at time 0.\n\nWe used the Coq theorem prover to verify common MDE class diagram refactorings (pullup, move attribute, split-class, etc.)  The key to the proofs is model data preservation and that every refactoring has an inverse.\n\nRefactoring constraints was harder.  Refactorings remove classes, associations, and attributes and add others.  Because UML class diagrams are static, dynamically restoring elements removed by refactorings is hard (unlike database systems where reproducing tables that were removed by a refactoring is easy).  So instead of refactoring a constraint A0 forward in time to A1, we instead translate an M1 database m1 backwards in time to m0=R^-1(m1) so that A0 can be evaluated on m0.  We call this time travel.\n\nA history of M0 is a sequence of refactorings R1, R2, &hellip; Rn that maps M0 to Mn, which we have demonstrated time travel.  We have also generalized a history to interleave edits (class, association, and attribute insertions and deletions) with refactorings.\n\nWhy couldn\u2019t we transform constraints from a prior time (A0) to a future time (An)?  Refactorings remove classes, associations, and attributes and replace them with other classes, associations, and attributes.  Unlike relational algebra where tables removed-by-refactoring can be recomputed on-demand, class diagrams are static; they do not admit dynamically created elements.  Given this limitation, it was difficult to emulate dynamically created elements.  We gave up because found it was too hard.\n\n \n\n\t\t\t\t\tLast Modified: 08/09/2020\n\n\t\t\t\t\tSubmitted by: Don S Batory"
 }
}