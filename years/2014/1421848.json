{
 "awd_id": "1421848",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "CIF:Small:Collaborative Research:Efficient Codes and their Performance Limits for Distributed Storage Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032922981",
 "po_email": "pregalia@nsf.gov",
 "po_sign_block_name": "Phillip Regalia",
 "awd_eff_date": "2014-09-01",
 "awd_exp_date": "2019-08-31",
 "tot_intn_awd_amt": 162699.0,
 "awd_amount": 162699.0,
 "awd_min_amd_letter_date": "2014-07-22",
 "awd_max_amd_letter_date": "2019-05-16",
 "awd_abstract_narration": "The explosive growth of data being generated and collected has rekindled interest in efficient means of storing such data.  Large data centers and distributed storage systems have become more widespread, playing an ever-increasing role in our everyday computational tasks.  While a data center should never lose data, disk failures occur on a daily basis as confirmed by the industry statistics. Methods and ideas from error correcting codes developed in this project enable the system to provide better guarantees against data loss as well as to reduce the amount of data that needs to be moved in order to enable recovery of information lost due to disk failures. Another related goal of this project is the reduction of storage overhead needed to support the recovery procedures. These goals are accomplished by relying on algebraic methods of constructing the data encoding procedures as well as on novel algorithms of data exchange and recovery. Overall the research performed in the course of this project contributes to the development of more efficient data management procedures in large-scale distributed storage systems.\r\n\r\nThis project puts forward new algebraic procedures for data encoding and recovery that enables one to achieve tradeoff between overhead and repair bandwidth based on the concept of local recovery.  The project studies both the case of recovering from a single disk loss, which is the most frequent problem in systems, as well as from the failure of multiple disks, addressing the problem of correcting one erasure as well as multiple erasures in data encoding. New bounds on the distance of codes with the locality requirement derived in this research are attained with new constructions of optimal locally recoverable codes equipped with simple recovery procedures. The project also addresses the problem of simultaneous recovery of data from multiple locations, enhancing data availability in large-scale distributed storage systems which are a key backbone component of the 21st century economy.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "P. Vijay",
   "pi_last_name": "Kumar",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "P. Vijay Kumar",
   "pi_email_addr": "vijayk@usc.edu",
   "nsf_id": "000468293",
   "pi_start_date": "2014-07-22",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Southern California",
  "inst_street_address": "3720 S FLOWER ST FL 3",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "2137407762",
  "inst_zip_code": "90033",
  "inst_country_name": "United States",
  "cong_dist_code": "34",
  "st_cong_dist_code": "CA34",
  "org_lgl_bus_name": "UNIVERSITY OF SOUTHERN CALIFORNIA",
  "org_prnt_uei_num": "",
  "org_uei_num": "G88KLJR3KYT5"
 },
 "perf_inst": {
  "perf_inst_name": "University of Southern California",
  "perf_str_addr": "3740 McClintock Avenue",
  "perf_city_name": "Los Angeles",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "900892565",
  "perf_ctry_code": "US",
  "perf_cong_dist": "37",
  "perf_st_cong_dist": "CA37",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779700",
   "pgm_ele_name": "Comm & Information Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7935",
   "pgm_ref_txt": "COMM & INFORMATION THEORY"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 162699.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This NSF project is concerned with coding for distributed storage, a field of research originating in the 2008 time frame.&nbsp; Research under the project has contributed significantly to advancing the field.&nbsp; &nbsp;There are two broad classes of codes for distributed storage: regenerating codes and codes with locality.&nbsp; &nbsp;Both are concerned with the storage of large amounts of data as takes place in a large-scale data center.&nbsp; The concern here is that while traditional erasure codes are efficient at recovering the entire codeword in the presence of symbol erasures, they are not quite that efficient when it comes to the erasure of a single code symbol.&nbsp; In the setting of a data center, this would correspond to the failure of a single node or storage unit.&nbsp; Each storage unit could store Terabytes of data.&nbsp;&nbsp;</p>\n<p>Efficiency of node repair is measured in terms of several parameters.&nbsp; The two principal parameters are the repair bandwidth and the repair degree.&nbsp; The repair bandwidth is a reference to the total number of symbols that need to be downloaded to repair a failed node.&nbsp; &nbsp;The repair degree is the total number of nodes that need to be contacted for node repair.&nbsp; Regenerating codes (RGC) are codes that offer the least possible repair bandwidth while locally recoverable codes (LRC) offer the least possible repair degree.&nbsp; &nbsp;RGCs are codes over a vector alphabet, thus each code symbol is a vector of \"a\" symbols over a finite field.&nbsp; The parameter \"a\" is called the sub-packetization level.&nbsp; There is interest within the class of regenerating codes in minimizing both \"a\" as well as the number of symbols accessed at a helper node.&nbsp;&nbsp;</p>\n<p>Principal results of the project include making progress (in stages) at constructing efficient high-rate regenerating codes culminating in the construction of the Clay code, that is optimal in four respects: simultaneously achieving least-possible values of storage overhead, repair bandwidth, sub-packetization level and number of symbols accessed.&nbsp; The Clay code was first discovered by Ye and Barg and then subsequently by our team independently two months later.&nbsp; Both teams collaborated in a successful submission to the FAST 2018 conference.&nbsp; There has been interest in the Clay code from industry including from Uber and Salesforce.&nbsp; Our team has been able to incorporate the Clay code as an erasure-code plugin for a development version of Ceph (please see <a href=\"https://docs.ceph.com/docs/master/rados/operations/erasure-code-clay/\">https://docs.ceph.com/docs/master/rados/operations/erasure-code-clay/</a>).&nbsp;</p>\n<p>A tight upper bound on the sub-packetization level of an optimal-access RGC developed under this project was used to prove optimality with respect to sub-packetization level of the Clay code.&nbsp;</p>\n<p>In the direction of LRC, work under the project led to the development of hierarchical LRC.&nbsp; These codes allow the concept of LRC to scale with block length.&nbsp; &nbsp; The group contributed significantly to the development of the theory of LRC for two erasures, leading to a publication on the topic in the IEEE Transactions on Information Theory.&nbsp; In the general case of multiple erasures, the group pioneered the construction of codes with sequential recovery leading to the proof of a conjecture and a tight upper bound with matching constructions for codes with sequential recovery.&nbsp; This paper was a finalist for the 2017 IEEE International Symposium on Information Theory's (ISIT) Jack Wolf Student Paper Award.&nbsp;</p>\n<p>Work carried out under the project is well cited, and has been widely disseminated.&nbsp; There was an invited (plenary) talk at ISIT 2015, and at workshops worldwide including: Gothenberg, Adelaide, London, Atlanta and Paris.&nbsp; An invited&nbsp; 45-page survey article on the topic has also appeared in Science China Information Sciences.&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2019<br>\n\t\t\t\t\tModified by: P. Vijay&nbsp;Kumar</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis NSF project is concerned with coding for distributed storage, a field of research originating in the 2008 time frame.  Research under the project has contributed significantly to advancing the field.   There are two broad classes of codes for distributed storage: regenerating codes and codes with locality.   Both are concerned with the storage of large amounts of data as takes place in a large-scale data center.  The concern here is that while traditional erasure codes are efficient at recovering the entire codeword in the presence of symbol erasures, they are not quite that efficient when it comes to the erasure of a single code symbol.  In the setting of a data center, this would correspond to the failure of a single node or storage unit.  Each storage unit could store Terabytes of data.  \n\nEfficiency of node repair is measured in terms of several parameters.  The two principal parameters are the repair bandwidth and the repair degree.  The repair bandwidth is a reference to the total number of symbols that need to be downloaded to repair a failed node.   The repair degree is the total number of nodes that need to be contacted for node repair.  Regenerating codes (RGC) are codes that offer the least possible repair bandwidth while locally recoverable codes (LRC) offer the least possible repair degree.   RGCs are codes over a vector alphabet, thus each code symbol is a vector of \"a\" symbols over a finite field.  The parameter \"a\" is called the sub-packetization level.  There is interest within the class of regenerating codes in minimizing both \"a\" as well as the number of symbols accessed at a helper node.  \n\nPrincipal results of the project include making progress (in stages) at constructing efficient high-rate regenerating codes culminating in the construction of the Clay code, that is optimal in four respects: simultaneously achieving least-possible values of storage overhead, repair bandwidth, sub-packetization level and number of symbols accessed.  The Clay code was first discovered by Ye and Barg and then subsequently by our team independently two months later.  Both teams collaborated in a successful submission to the FAST 2018 conference.  There has been interest in the Clay code from industry including from Uber and Salesforce.  Our team has been able to incorporate the Clay code as an erasure-code plugin for a development version of Ceph (please see https://docs.ceph.com/docs/master/rados/operations/erasure-code-clay/). \n\nA tight upper bound on the sub-packetization level of an optimal-access RGC developed under this project was used to prove optimality with respect to sub-packetization level of the Clay code. \n\nIn the direction of LRC, work under the project led to the development of hierarchical LRC.  These codes allow the concept of LRC to scale with block length.    The group contributed significantly to the development of the theory of LRC for two erasures, leading to a publication on the topic in the IEEE Transactions on Information Theory.  In the general case of multiple erasures, the group pioneered the construction of codes with sequential recovery leading to the proof of a conjecture and a tight upper bound with matching constructions for codes with sequential recovery.  This paper was a finalist for the 2017 IEEE International Symposium on Information Theory's (ISIT) Jack Wolf Student Paper Award. \n\nWork carried out under the project is well cited, and has been widely disseminated.  There was an invited (plenary) talk at ISIT 2015, and at workshops worldwide including: Gothenberg, Adelaide, London, Atlanta and Paris.  An invited  45-page survey article on the topic has also appeared in Science China Information Sciences. \n\n\t\t\t\t\tLast Modified: 11/30/2019\n\n\t\t\t\t\tSubmitted by: P. Vijay Kumar"
 }
}