{
 "awd_id": "1350344",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "CAREER: Static-Analysis-Driven Engineering of Modern Software Systems",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2014-02-01",
 "awd_exp_date": "2020-01-31",
 "tot_intn_awd_amt": 449994.0,
 "awd_amount": 449994.0,
 "awd_min_amd_letter_date": "2014-01-23",
 "awd_max_amd_letter_date": "2018-05-29",
 "awd_abstract_narration": "Users of software are all too familiar with its shortcomings: software\r\nis slow, software is buggy and software is insecure.  When a complex\r\nsoftware system fails, it is unhelpfully simplistic to blame the\r\nimplementors of the system as incompetent.  The truth is that software\r\nengineers are uniquely disadvantaged among the traditional engineering\r\ndisciplines because they lack a viable predictive model for the\r\nsystems they design and build. That is, a software engineer cannot\r\npredict the behavior of software in practice in the same way that a\r\ncivil engineer can predict the behavior of a bridge under load. The\r\nprimary intellectual merit of this research is that it lays the\r\ncritical, systematic foundations for the science of prediction for\r\nsoftware. The broader impacts are to enable engineers to build better\r\nsoftware with the aid of predictivity. Moreover, this research also\r\nseeks to develop courses and educational material to train the next\r\ngeneration of software engineers in the art of constructing fast,\r\nsafe, reliable and secure software in this fashion.  As this research\r\ntransfers into practice and engineers adopt this methodology, it will\r\nsignificantly strengthen the foundation of national\r\ncyberinfrastructure.\r\n\r\nThe core technical thrust of this research is the development of a\r\nsystematic method for the synthesis of static analyzers for complex,\r\nmodern programming languages.  It also explores whether or not this\r\nmethodology can be automated in whole or in part. To motivate the\r\ndevelopment of this method, this research applies the method to the\r\nsynthesis of intensional static analyzers for popular scripting\r\nlanguages such as JavaScript, Perl, PHP, Ruby and Python?many of which\r\nhappen to be the languages powering modern, web-based software.  The\r\nfoundational technical concept of this research is the systematic\r\ntransformation of small-step interpreters into static analyzers.\r\nSmall-step analyzers promise unique advantages over traditional\r\ntechniques, including more opportunities for optimizing speed and\r\nprecision, and clearer, easier reasoning about the soundness of the\r\nresults of the analysis.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Matthew",
   "pi_last_name": "Might",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Matthew Might",
   "pi_email_addr": "might@cs.utah.edu",
   "nsf_id": "000068857",
   "pi_start_date": "2014-01-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Utah",
  "inst_street_address": "201 PRESIDENTS CIR",
  "inst_street_address_2": "",
  "inst_city_name": "SALT LAKE CITY",
  "inst_state_code": "UT",
  "inst_state_name": "Utah",
  "inst_phone_num": "8015816903",
  "inst_zip_code": "841129049",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "UT01",
  "org_lgl_bus_name": "UNIVERSITY OF UTAH",
  "org_prnt_uei_num": "",
  "org_uei_num": "LL8GLEVH6MG3"
 },
 "perf_inst": {
  "perf_inst_name": "University of Utah",
  "perf_str_addr": "75 South 2000 East",
  "perf_city_name": "Salt Lake City",
  "perf_st_code": "UT",
  "perf_st_name": "Utah",
  "perf_zip_code": "841128930",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "UT01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  },
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "1045",
   "pgm_ref_txt": "CAREER-Faculty Erly Career Dev"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9150",
   "pgm_ref_txt": "EXP PROG TO STIM COMP RES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 85136.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 87521.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 89953.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 92429.0
  },
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 94955.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p class=\"p1\">&nbsp;<strong>Broader impact</strong></p>\n<p class=\"p1\">&nbsp;</p>\n<p class=\"p2\">Conducting automated reasoning about how programs will behave when they run (static program analysis) is essential to improving their security; enhancing their performance; and ensuring their reliability.<span>&nbsp; </span>This effort focused on improving the ability to conduct such automated reasoning about program behavior, especially in the context of modern programming languages (with complex features such as higher-order functions) and languages used for specific domains or tasks (of which there has been a rapid proliferation and for which few to no automated reasoners exist).</p>\n<p class=\"p1\">&nbsp;</p>\n<p class=\"p2\"><strong>Intellectual merit</strong></p>\n<p class=\"p1\">Unfortunately, fundamental principles in computer science make fully automated reasoning about programs in general challenging. (For example, it?s impossible to create an automated reasoner that can guaranteeably predict whether a program will halt, and this in turn makes many interesting questions about program behavior also unpredictable.)&nbsp; Fortunately, frameworks such as abstract interpretation provide an approach under which program behavior can be <em>approximated</em> or conservatively bounded (if not predicted precisely).&nbsp;</p>\n<p class=\"p1\">Whereas <em>concrete</em>&nbsp;interpreters provide the precise meaning of a program in a language in the form of a concrete semantics, abstract interpreters establish an <em>abstract</em>&nbsp;semantics that approximates all possible behaviors of a program.&nbsp; However, constructing abstract interpreters and proving their soundness is itself a complex, manual engineering process.&nbsp;</p>\n<p class=\"p1\">This effort created a methodology for developing static program analyzers for programs in a given language in a principled way, given only the specification (the semantics) of the language to begin.&nbsp; This methodology - rooted in the concept of \"abstracting abstract machines\" - provides a direct way shorten the engineering process involved. &nbsp;</p>\n<p class=\"p1\">In addition, the effort found that this methodology could be enriched in ways that enhance precision or performance (such as pushdown analysis or abstract garbage collection) in an nearly orthogonal fashion, again simplifying the engineering process of abstract interpreters themselves.</p>\n<p class=\"p2\">By developing this richer methodology, it has become possible to rapidly engineer static analyzers for more complex but widely used languages (such as JavaScript) as well as for novel domain-specific languages in fields such as biomedical informatics.</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 08/12/2022<br>\n\t\t\t\t\tModified by: Matthew&nbsp;Might</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "Broader impact\n \nConducting automated reasoning about how programs will behave when they run (static program analysis) is essential to improving their security; enhancing their performance; and ensuring their reliability.  This effort focused on improving the ability to conduct such automated reasoning about program behavior, especially in the context of modern programming languages (with complex features such as higher-order functions) and languages used for specific domains or tasks (of which there has been a rapid proliferation and for which few to no automated reasoners exist).\n \nIntellectual merit\nUnfortunately, fundamental principles in computer science make fully automated reasoning about programs in general challenging. (For example, it?s impossible to create an automated reasoner that can guaranteeably predict whether a program will halt, and this in turn makes many interesting questions about program behavior also unpredictable.)  Fortunately, frameworks such as abstract interpretation provide an approach under which program behavior can be approximated or conservatively bounded (if not predicted precisely). \nWhereas concrete interpreters provide the precise meaning of a program in a language in the form of a concrete semantics, abstract interpreters establish an abstract semantics that approximates all possible behaviors of a program.  However, constructing abstract interpreters and proving their soundness is itself a complex, manual engineering process. \nThis effort created a methodology for developing static program analyzers for programs in a given language in a principled way, given only the specification (the semantics) of the language to begin.  This methodology - rooted in the concept of \"abstracting abstract machines\" - provides a direct way shorten the engineering process involved.  \nIn addition, the effort found that this methodology could be enriched in ways that enhance precision or performance (such as pushdown analysis or abstract garbage collection) in an nearly orthogonal fashion, again simplifying the engineering process of abstract interpreters themselves.\nBy developing this richer methodology, it has become possible to rapidly engineer static analyzers for more complex but widely used languages (such as JavaScript) as well as for novel domain-specific languages in fields such as biomedical informatics.\n\n \n\n\t\t\t\t\tLast Modified: 08/12/2022\n\n\t\t\t\t\tSubmitted by: Matthew Might"
 }
}