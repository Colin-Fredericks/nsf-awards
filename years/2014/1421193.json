{
 "awd_id": "1421193",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: SMALL: NONSTANDARD COMPUTATIONAL MODELS OF LINEAR LOGIC",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2014-09-01",
 "awd_exp_date": "2019-08-31",
 "tot_intn_awd_amt": 450000.0,
 "awd_amount": 458000.0,
 "awd_min_amd_letter_date": "2014-07-23",
 "awd_max_amd_letter_date": "2016-05-11",
 "awd_abstract_narration": "TItle: SHF: Small: Nonstandard Computational Models of Linear Logic\r\n\r\nMuch of the interesting software being developed today relies on mathematical underpinnings that can best be expressed in terms of linear algebra (e.g. large scale matrices or graph data) and statistics (e.g. machine learning algorithms or \"big data\" analysis). Current programming languages aren't especially suited to working with such kinds of data, and so provide little built-in support to help scientists and software developers.  Conversely, many powerful mathematical techniques have been developed in the contexts of linear algebra and statistics, but those techniques have not been applicable to problems in programming language semantics.  This research project seeks to develop a theoretical foundation that connects the seemingly disparate topics of programming languages and these mathematical domains.\r\n\r\nThe technical approach taken in this work is to develop \"nonstandard\" models of linear logic, which is an expressive and low-level framework for understanding program semantics.  The intellectual merits are found in developing novel connections between well-established, but distinct, mathematical domains, connecting proof theory and program semantics to representations in vector spaces and categories of probability measures.  The broader impacts of this work are best understood through its potential long-term applications, which include: smooth integration of programming language constructs for working with numerical data (like Matlab) with support for higher-order functions and abstract datatypes; new techniques for proof search based on numerical methods; and, better programming languages for expressing machine learning or probabilistic algorithm.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Stephan",
   "pi_last_name": "Zdancewic",
   "pi_mid_init": "A",
   "pi_sufx_name": "",
   "pi_full_name": "Stephan A Zdancewic",
   "pi_email_addr": "stevez@cis.upenn.edu",
   "nsf_id": "000220116",
   "pi_start_date": "2014-07-23",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Pennsylvania",
  "inst_street_address": "3451 WALNUT ST STE 440A",
  "inst_street_address_2": "",
  "inst_city_name": "PHILADELPHIA",
  "inst_state_code": "PA",
  "inst_state_name": "Pennsylvania",
  "inst_phone_num": "2158987293",
  "inst_zip_code": "191046205",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "PA03",
  "org_lgl_bus_name": "TRUSTEES OF THE UNIVERSITY OF PENNSYLVANIA, THE",
  "org_prnt_uei_num": "GM1XX56LEP58",
  "org_uei_num": "GM1XX56LEP58"
 },
 "perf_inst": {
  "perf_inst_name": "University of Pennsylvania",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "PA",
  "perf_st_name": "Pennsylvania",
  "perf_zip_code": "191046205",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "PA03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 450000.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 8000.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project conducted basic research into computational models of linear logic.Linear logic is a framework for desribing and reasoning about systems that have \"consumable\" resources.&nbsp; In this setting, a computational model is a semantics for linear logic that describes the kinds of algorithmic operations executableby a computer.</p>\n<p><br />The main outcomes of this project were threefold.&nbsp; First, we developed mathematical machinery needed to understand the connection between linear-logic based semantics and ordinary semantics.&nbsp; We showed how to frame this connection as a linear--nonlinear adjunction, which gives a mathematical explanation for how to embed a linear semantics into an ordinary semantics (and vice versa).Second, we using this abstract connection as a basis, we explored two implementations of these ideas.&nbsp; One, for the Haskell programming language, shows how to embed linear sublanguages as libraries that provide strong resource usage guarantees.&nbsp; The other implementation demonstrated how to embed a linear language into the Coq interactive theorem prover.</p>\n<p><br />The third outcome of this project was the development of QWIRE, a programming language for quantum computation circuits.&nbsp; It turns out that one natural computational model of linear logic is closely connected to mathematical models (called density matrices) that physicists use to describe the evolution of quantum systems.&nbsp; Our computational model of linear logic therefor provides anatural programming language with which to express quantum computations.&nbsp; QWIRE is an implementation of those ideas in the Coq theorem prover, a design that allows us to model and formally prove properties of quantum algorithms.&nbsp; This is a particularly compelling idea because quantum computers are (at least in thenear term) going to be expensive to construct, and they don't easily permit usual software-development methodologies such as testing or simulation.&nbsp; Formal verification of the correctness of quantum circuits provides a way to obtain higher confidence that the quantum computers are giving us reliable outputs.</p>\n<p>&nbsp;</p>\n<p>Beyond the deep theoretical questions that this proejct explored, it has creaded several other impacts.&nbsp; The QWIRE programming language is under active development and there is a growing community of researchers interested in the intersection of quantum computing and programming languages.&nbsp; This project also provided led to two Ph.D. theses.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/05/2019<br>\n\t\t\t\t\tModified by: Stephan&nbsp;A&nbsp;Zdancewic</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis project conducted basic research into computational models of linear logic.Linear logic is a framework for desribing and reasoning about systems that have \"consumable\" resources.  In this setting, a computational model is a semantics for linear logic that describes the kinds of algorithmic operations executableby a computer.\n\n\nThe main outcomes of this project were threefold.  First, we developed mathematical machinery needed to understand the connection between linear-logic based semantics and ordinary semantics.  We showed how to frame this connection as a linear--nonlinear adjunction, which gives a mathematical explanation for how to embed a linear semantics into an ordinary semantics (and vice versa).Second, we using this abstract connection as a basis, we explored two implementations of these ideas.  One, for the Haskell programming language, shows how to embed linear sublanguages as libraries that provide strong resource usage guarantees.  The other implementation demonstrated how to embed a linear language into the Coq interactive theorem prover.\n\n\nThe third outcome of this project was the development of QWIRE, a programming language for quantum computation circuits.  It turns out that one natural computational model of linear logic is closely connected to mathematical models (called density matrices) that physicists use to describe the evolution of quantum systems.  Our computational model of linear logic therefor provides anatural programming language with which to express quantum computations.  QWIRE is an implementation of those ideas in the Coq theorem prover, a design that allows us to model and formally prove properties of quantum algorithms.  This is a particularly compelling idea because quantum computers are (at least in thenear term) going to be expensive to construct, and they don't easily permit usual software-development methodologies such as testing or simulation.  Formal verification of the correctness of quantum circuits provides a way to obtain higher confidence that the quantum computers are giving us reliable outputs.\n\n \n\nBeyond the deep theoretical questions that this proejct explored, it has creaded several other impacts.  The QWIRE programming language is under active development and there is a growing community of researchers interested in the intersection of quantum computing and programming languages.  This project also provided led to two Ph.D. theses.\n\n\t\t\t\t\tLast Modified: 12/05/2019\n\n\t\t\t\t\tSubmitted by: Stephan A Zdancewic"
 }
}