{
 "awd_id": "1421412",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Collaborative Research: Compiler Coaching",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2014-07-01",
 "awd_exp_date": "2018-12-31",
 "tot_intn_awd_amt": 316433.0,
 "awd_amount": 316433.0,
 "awd_min_amd_letter_date": "2014-07-02",
 "awd_max_amd_letter_date": "2014-07-02",
 "awd_abstract_narration": "Title: SHF: Small: Collaborative Research: Compiler Coaching\r\n\r\nThe ``Compiler Coaching'' (Dialog) project represents an investment in programming language tools and technology.  Software engineers use high-level programming languages on a daily basis to produce the apps and applications that everyone uses and that control everybody's lives. Once a programming language translator accepts a program as grammatically correct, it creates impenetrable computer codes without informing the programmer how well (fast or slow, small or large, energy hogging or efficient) these codes will work.  Indeed, modern programming languages employ increasingly sophisticated translation techniques and have become obscure black boxes to the working engineer.  The goal of the Dialog project is to create channels of communication between these translation processes and software engineers, with the expectation that the latter can use this new source of\r\ninformation to improve the speed, size, or energy consumption of their software.\r\n\r\nThe PIs will explore the Dialog idea in two optimizing compiler settings, one on the conventional side and one on the modern one: for the Racket language, a teaching and research vehicle that they can modify as needed to create the desired channel, and the JavaScript programming language, the standardized tool for existing Web applications. The intellectual merits concern the fundamental principles of creating such communication channels and frameworks for gathering empirical evidence on how these channels benefit the working software engineer.  These results should enable the developers of any programming language to implement similar channels of communication to help their clients. The broader impacts are twofold. On one hand, the project is likely to positively impact the lives of working software engineers as industrial programming language creators adapt the Dialog idea. On the other hand, the project will contribute to a two-decades old, open-source programming language project with a large and longstanding history of educational outreach at multiple levels. The project has influenced hundreds of thousands of high school students in the past and is likely to do so in the future.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Matthias",
   "pi_last_name": "Felleisen",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Matthias Felleisen",
   "pi_email_addr": "matthias@ccs.neu.edu",
   "nsf_id": "000286813",
   "pi_start_date": "2014-07-02",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Northeastern University",
  "inst_street_address": "360 HUNTINGTON AVE",
  "inst_street_address_2": "",
  "inst_city_name": "BOSTON",
  "inst_state_code": "MA",
  "inst_state_name": "Massachusetts",
  "inst_phone_num": "6173735600",
  "inst_zip_code": "021155005",
  "inst_country_name": "United States",
  "cong_dist_code": "07",
  "st_cong_dist_code": "MA07",
  "org_lgl_bus_name": "NORTHEASTERN UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HLTMVS2JZBS6"
 },
 "perf_inst": {
  "perf_inst_name": "Northeastern University",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "MA",
  "perf_st_name": "Massachusetts",
  "perf_zip_code": "021155005",
  "perf_ctry_code": "US",
  "perf_cong_dist": "07",
  "perf_st_cong_dist": "MA07",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "689200",
   "pgm_ele_name": "CI REUSE"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7433",
   "pgm_ref_txt": "CyberInfra Frmwrk 21st (CIF21)"
  },
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 316433.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>Software engineers develop computer code in high-level programminglanguages and use compilers to translate their programs into instructionsfor a computer. Like a human translator, a compiler can choose from a(large) range of different translations. While each of them faithfullyreflects the meaning of the oroginal program, some of them finish much morequickly than others---and people tend to prefer getting results rathersooner or later. However, the complexity of the compiler makes it hard forsoftware engineers to predict the performance characteristics of their code.&nbsp;</p>\n<p><br />This project investigated how a compiler could be supplemented withsoftware tools to explain its approach to translating programs. Theresearchers expected that these explanations would help software engineersto improve their understanding of a program's performance characteristicsand improve the performance itself. The project had two outcomes.&nbsp;</p>\n<p><br />The first outcome is a tool that tells a software engineer when thecompiler could have chosen a \"fast\" translation if the program had beenwritten slightly differently. Using this information, a software engineercan decide whether the proposed change affects the meaning of the programin a significant way and, if not, accept the compiler's proposedimprovements.&nbsp;</p>\n<p><br />The second outcome is a novel idea of how to analyze the performance ofprograms. Existing performance analysis tools gather information during aprogram run that helps them highlight the most expensive individual linesor small contiguous segments of code. While this information is useful,modern programming languages offer features (concepts like groups of nounsor verbs) that cause slowdowns if used the wrong way but whose cost cannotbe understood in terms of a small number of contiguous lines of code. Theproject's \"feature specific\" performance analysis remedies this situation.The research term assisted Mozilla to adapt the idea of a feature-specificprofiler for its Firefox developer tool suite.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 02/07/2019<br>\n\t\t\t\t\tModified by: Matthias&nbsp;Felleisen</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nSoftware engineers develop computer code in high-level programminglanguages and use compilers to translate their programs into instructionsfor a computer. Like a human translator, a compiler can choose from a(large) range of different translations. While each of them faithfullyreflects the meaning of the oroginal program, some of them finish much morequickly than others---and people tend to prefer getting results rathersooner or later. However, the complexity of the compiler makes it hard forsoftware engineers to predict the performance characteristics of their code. \n\n\nThis project investigated how a compiler could be supplemented withsoftware tools to explain its approach to translating programs. Theresearchers expected that these explanations would help software engineersto improve their understanding of a program's performance characteristicsand improve the performance itself. The project had two outcomes. \n\n\nThe first outcome is a tool that tells a software engineer when thecompiler could have chosen a \"fast\" translation if the program had beenwritten slightly differently. Using this information, a software engineercan decide whether the proposed change affects the meaning of the programin a significant way and, if not, accept the compiler's proposedimprovements. \n\n\nThe second outcome is a novel idea of how to analyze the performance ofprograms. Existing performance analysis tools gather information during aprogram run that helps them highlight the most expensive individual linesor small contiguous segments of code. While this information is useful,modern programming languages offer features (concepts like groups of nounsor verbs) that cause slowdowns if used the wrong way but whose cost cannotbe understood in terms of a small number of contiguous lines of code. Theproject's \"feature specific\" performance analysis remedies this situation.The research term assisted Mozilla to adapt the idea of a feature-specificprofiler for its Firefox developer tool suite.\n\n \n\n \n\n \n\n\t\t\t\t\tLast Modified: 02/07/2019\n\n\t\t\t\t\tSubmitted by: Matthias Felleisen"
 }
}