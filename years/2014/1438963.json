{
 "awd_id": "1438963",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "XPS: EXPL: CCA: Collaborative Research: Nixing Scale Bugs in HPC Applications",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2014-09-01",
 "awd_exp_date": "2017-08-31",
 "tot_intn_awd_amt": 150000.0,
 "awd_amount": 166128.0,
 "awd_min_amd_letter_date": "2014-08-06",
 "awd_max_amd_letter_date": "2015-05-12",
 "awd_abstract_narration": "Large-scale simulation is a fundamental component of modern science and engineering. Unfortunately, programs written to perform simulations on large-scale parallel computers frequently suffer from software defects that result from the sheer scale and the variety of parallelization approaches employed. Especially egregious are software bugs that occur when large resource allocations (e.g., memory requests) are made. Formally based active-testing techniques are essential to locate such defects. However, these testing tools are themselves seldom run on parallel machines, let alone at large scale, making it difficult and very time consuming to find scale bugs with high assurance. \r\n\r\nEfforts to parallelize verification tools should reuse existing technology for easy parallelization, result collection, and fault handling. Key innovations of this project include the insight that large-scale verification runs can be described through work-flows, which makes it possible to take advantage of already available distributed computing platforms, in particular Swift/T from Argonne. The complementary backgrounds of the PIs are well matched with the need to push both formal aspects and distributed verification in the context of three widely-used concurrency models, namely MPI, OpenMP, and CUDA. \r\n\r\nThis work will help create a public distributed formal active testing framework. The tools and case-study software driving this research will be maintained by the PIs and released freely under open-source licenses through websites and repositories. They will facilitate large-scale debugging of scientific simulation codes by researchers and software developers in academia, government labs, and industry. \r\n\r\nThe project will also generate pedagogical material and best practices, helping educate students in the use of existing work-flow based problem solving approaches. It will help train present and future scientists, engineers, and programmers, thus assisting in maintaining our nation's leadership in computing, homeland and energy security, and STEM education.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Martin",
   "pi_last_name": "Burtscher",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Martin Burtscher",
   "pi_email_addr": "burtscher@txstate.edu",
   "nsf_id": "000572212",
   "pi_start_date": "2014-08-06",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Texas State University - San Marcos",
  "inst_street_address": "601 UNIVERSITY DR",
  "inst_street_address_2": "",
  "inst_city_name": "SAN MARCOS",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5122452314",
  "inst_zip_code": "786664684",
  "inst_country_name": "United States",
  "cong_dist_code": "15",
  "st_cong_dist_code": "TX15",
  "org_lgl_bus_name": "TEXAS STATE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "HS5HWWK1AAU5"
 },
 "perf_inst": {
  "perf_inst_name": "Texas State University - San Marcos",
  "perf_str_addr": "601 University Drive",
  "perf_city_name": "San Marcos",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "786664684",
  "perf_ctry_code": "US",
  "perf_cong_dist": "15",
  "perf_st_cong_dist": "TX15",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "164000",
   "pgm_ele_name": "Information Technology Researc"
  },
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  },
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  },
  {
   "pgm_ref_code": "9251",
   "pgm_ref_txt": "REU SUPP-Res Exp for Ugrd Supp"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 150000.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 16128.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>High-performance computing (HPC) is of key importance to our nation. For example, it is used for weather forecasting, medicine development, and renewable energy design. One of the central prerequisites for achieving meaningful scientific computing is the ability to track down and eliminate programming errors. Doing so on highly parallel systems that may consist of different types of processors is challenging. After all, literally trillions of operations can execute on modern HPC systems between the time an incorrect action takes place (e.g., a wrong value is computed) and the time when this action triggers an observable error (e.g., a crash or an erroneous program output). Since it is generally unknown when an error occurs and when it will manifest itself, software developers would like to be able to capture the entire program&rsquo;s behavior for later analysis. However, doing so in computers with millions of processing cores is a daunting task because recording just a little information per second on each core might already generate more data than the file system can handle in terms of throughput and possibly also in terms of available storage capacity.</p>\n<p>To make &ldquo;always-on&rdquo; program tracing and debugging possible even for large-scale HPC codes, we developed a first-of-its-kind low-overhead tracing technique. It is based on a custom data compression approach that we designed specifically for this purpose. It compresses the trace not only well and quickly but also in an incremental manner, meaning that it compresses the data right when they are produced and before they are stored. As a consequence, the resulting program traces are small, thus greatly reducing the required storage capacity, and the rate at which trace data need to be recorded is low, thus greatly reducing the required bandwidth. We developed such a compression approach both for the main processors (CPUs) as well as for compute accelerators (GPUs). We also wrote corresponding decompression algorithms and a trace viewer.</p>\n<p>Our measurements show that just recording a unique 16-bit identifier for every function call and return when running a set of scientific applications on the Stampede supercomputer results in about 2 MB/s of trace data per core on average. Extrapolating this value to all 102,400 cores (not counting the accelerators) yields 205 GB/s of data, which exceeds the filesystem&rsquo;s write performance of 150 GB/s. In contrast, our compression-based tracing method reduces the emitted data by a factor of 100 on average, a ratio that is quite stable with respect to scaling, making it possible to trace full-scale programs while leaving over 98% of the I/O bandwidth to the application. Importantly, using compression typically lowers the tracing overhead in spite of the burden of having to run the extra compression code because so much less data have to be moved through the system.</p>\n<p>The nation&rsquo;s ability to conduct advanced scientific research depends on HPC. The results of this project directly contribute to speeding up the creation, improving the quality, and lowering the cost of the corresponding software. Moreover, it helps make it possible to successfully develop more advanced software. Thus, our work indirectly enables other transformative research through an increase in exploitable computing performance. Clearly, making it possible to solve important problems faster can help all of humanity, perhaps by discovering cures for cancer or other devastating health conditions, running more accurate hurricane and tsunami predictions to provide earlier and more precise warnings, building more efficient and resilient power grids, etc.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/18/2017<br>\n\t\t\t\t\tModified by: Martin&nbsp;Burtscher</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nHigh-performance computing (HPC) is of key importance to our nation. For example, it is used for weather forecasting, medicine development, and renewable energy design. One of the central prerequisites for achieving meaningful scientific computing is the ability to track down and eliminate programming errors. Doing so on highly parallel systems that may consist of different types of processors is challenging. After all, literally trillions of operations can execute on modern HPC systems between the time an incorrect action takes place (e.g., a wrong value is computed) and the time when this action triggers an observable error (e.g., a crash or an erroneous program output). Since it is generally unknown when an error occurs and when it will manifest itself, software developers would like to be able to capture the entire program?s behavior for later analysis. However, doing so in computers with millions of processing cores is a daunting task because recording just a little information per second on each core might already generate more data than the file system can handle in terms of throughput and possibly also in terms of available storage capacity.\n\nTo make \"always-on\" program tracing and debugging possible even for large-scale HPC codes, we developed a first-of-its-kind low-overhead tracing technique. It is based on a custom data compression approach that we designed specifically for this purpose. It compresses the trace not only well and quickly but also in an incremental manner, meaning that it compresses the data right when they are produced and before they are stored. As a consequence, the resulting program traces are small, thus greatly reducing the required storage capacity, and the rate at which trace data need to be recorded is low, thus greatly reducing the required bandwidth. We developed such a compression approach both for the main processors (CPUs) as well as for compute accelerators (GPUs). We also wrote corresponding decompression algorithms and a trace viewer.\n\nOur measurements show that just recording a unique 16-bit identifier for every function call and return when running a set of scientific applications on the Stampede supercomputer results in about 2 MB/s of trace data per core on average. Extrapolating this value to all 102,400 cores (not counting the accelerators) yields 205 GB/s of data, which exceeds the filesystem?s write performance of 150 GB/s. In contrast, our compression-based tracing method reduces the emitted data by a factor of 100 on average, a ratio that is quite stable with respect to scaling, making it possible to trace full-scale programs while leaving over 98% of the I/O bandwidth to the application. Importantly, using compression typically lowers the tracing overhead in spite of the burden of having to run the extra compression code because so much less data have to be moved through the system.\n\nThe nation?s ability to conduct advanced scientific research depends on HPC. The results of this project directly contribute to speeding up the creation, improving the quality, and lowering the cost of the corresponding software. Moreover, it helps make it possible to successfully develop more advanced software. Thus, our work indirectly enables other transformative research through an increase in exploitable computing performance. Clearly, making it possible to solve important problems faster can help all of humanity, perhaps by discovering cures for cancer or other devastating health conditions, running more accurate hurricane and tsunami predictions to provide earlier and more precise warnings, building more efficient and resilient power grids, etc.\n\n\t\t\t\t\tLast Modified: 11/18/2017\n\n\t\t\t\t\tSubmitted by: Martin Burtscher"
 }
}