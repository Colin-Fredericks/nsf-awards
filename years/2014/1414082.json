{
 "awd_id": "1414082",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Continuing Grant",
 "awd_titl_txt": "TWC: Frontier: Collaborative: CORE: Center for Encrypted Functionalities",
 "cfda_num": "47.070",
 "org_code": "05050000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2014-10-01",
 "awd_exp_date": "2020-09-30",
 "tot_intn_awd_amt": 950372.0,
 "awd_amount": 950372.0,
 "awd_min_amd_letter_date": "2014-07-31",
 "awd_max_amd_letter_date": "2018-07-18",
 "awd_abstract_narration": "The Center for Encrypted Functionalities (CORE) tackles the deep and far-reaching problem of general-purpose \"program obfuscation,\" which aims to enhance cybersecurity by making an arbitrary computer program unintelligible while preserving its functionality. This can in turn enable a host of applications, such as hiding from potential adversaries the existence of vulnerabilities that may have been introduced through human error in the design/development process, thereby preventing tampering or deterring reverse engineering, or hiding cryptographic keys within software, thereby strengthening encryption and information transfer. \r\n \r\nAt the heart of the Center's research activities is the development of new and rigorous mathematical techniques to build faster and more secure general-purpose mechanisms enabling such software. In pursuit of this goal, the CORE team tackles many technical questions: Can secure general-purpose mechanisms avoid the inefficiency overhead that arises from Barrington's Theorem? Can the security of these mechanisms be proven to hold against idealized adversaries, or be based on natural non-interactive hardness assumptions? Can these approaches be securely leveraged to protect data from rogue insiders, who must be able to access some data in the clear? Finally, can these mechanisms be used to reduce the level of interaction required to accomplish secure communication and computation tasks? In addition to its direct research program, the Center organizes retreats and workshops to bring together researchers to carry out the Center's mission. The Center also engages in high-impact outreach efforts, such as the development of free Massive Open Online Courses (MOOCs).",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CNS",
 "org_div_long_name": "Division Of Computer and Network Systems",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Brent",
   "pi_last_name": "Waters",
   "pi_mid_init": "R",
   "pi_sufx_name": "",
   "pi_full_name": "Brent R Waters",
   "pi_email_addr": "bwaters@cs.utexas.edu",
   "nsf_id": "000518000",
   "pi_start_date": "2014-07-31",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Texas at Austin",
  "inst_street_address": "110 INNER CAMPUS DR",
  "inst_street_address_2": "",
  "inst_city_name": "AUSTIN",
  "inst_state_code": "TX",
  "inst_state_name": "Texas",
  "inst_phone_num": "5124716424",
  "inst_zip_code": "787121139",
  "inst_country_name": "United States",
  "cong_dist_code": "25",
  "st_cong_dist_code": "TX25",
  "org_lgl_bus_name": "UNIVERSITY OF TEXAS AT AUSTIN",
  "org_prnt_uei_num": "",
  "org_uei_num": "V6AFQPN18437"
 },
 "perf_inst": {
  "perf_inst_name": "University of Texas at Austin",
  "perf_str_addr": "",
  "perf_city_name": "",
  "perf_st_code": "TX",
  "perf_st_name": "Texas",
  "perf_zip_code": "787121532",
  "perf_ctry_code": "US",
  "perf_cong_dist": "25",
  "perf_st_cong_dist": "TX25",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "806000",
   "pgm_ele_name": "Secure &Trustworthy Cyberspace"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7433",
   "pgm_ref_txt": "CyberInfra Frmwrk 21st (CIF21)"
  },
  {
   "pgm_ref_code": "7434",
   "pgm_ref_txt": "CNCI"
  },
  {
   "pgm_ref_code": "8087",
   "pgm_ref_txt": "Frontiers in SaTC"
  },
  {
   "pgm_ref_code": "8251",
   "pgm_ref_txt": "Math Sci Innovation Incubator"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0116",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001617DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0117",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001718DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0118",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001819DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 369558.0
  },
  {
   "fund_oblg_fiscal_yr": 2016,
   "fund_oblg_amt": 187906.0
  },
  {
   "fund_oblg_fiscal_yr": 2017,
   "fund_oblg_amt": 193516.0
  },
  {
   "fund_oblg_fiscal_yr": 2018,
   "fund_oblg_amt": 199392.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p id=\"docs-internal-guid-208d3639-7fff-c21a-b9d1-b4e154b66773\" style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">Program obfuscation is the ability to take a computer program or function P and run it through an obfuscator which itself outputs a program. The new program should (A) be functionally equivalent to the original (i.e. on any input x the original and the newly obfuscated program give the same output) and (B) reveal the minimal amount of information possible of the original program.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">This project explores the applications and foundations of indistinguishability obfuscation which is a form of obfuscation that guarantees that it is intractable to distinguish obfuscations of two functionally equivalent programs. Highlights of results in this program include:</span></p>\n<p><br /><br /></p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">* Initial constructions for indistinguishability obfuscation were given in the circuit model where the size of the obfuscated program grew with the running time of the program. Our work showed how to move from obfuscating circuits to obfuscating general programs where we could obfuscate programs with descriptions that are much smaller than their running time. Unlike other works, there were no restrictions on the size of the programs.</span></p>\n<p>&nbsp;</p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">* A primitive known as &ldquo;lockable obfuscation&rdquo; was introduced. In lockable obfuscation a program</span></p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">P is obfuscated alongside a lock value &lsquo;a&rsquo;. An evaluator that has input x can learn if P(x)=a. However, if &lsquo;a&rsquo; is chosen randomly, then no information about the program will be revealed. Our work showed how to construct this primitive from the Learning with Errors assumption. Moreover, we showed several applications of this including the ability to hide the recipient of *any* public key encryption system.</span></p>\n<p>&nbsp;</p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">* The project&nbsp; also provided results showing the limits of obfuscation. In particular, we showed that a notion known as Differing Inputs Obfuscation was impossible for the Turing Machine model.</span></p>\n<p>&nbsp;</p>\n<p style=\"line-height: 1.38; margin-top: 0pt; margin-bottom: 0pt;\" dir=\"ltr\"><span style=\"font-size: 11pt; font-family: Arial; color: #000000; background-color: transparent; font-weight: 400; font-style: normal; font-variant: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap;\">* Our work also provided a Learning with Errors realization for a problem known as Traitor Tracing. In such a system a party can trace the source of a corrupted decryption device *even if the corrupted device is itself obfuscated. This result was the first one to accomplish this for any system with short parameters.</span></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 11/30/2020<br>\n\t\t\t\t\tModified by: Brent&nbsp;R&nbsp;Waters</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "Program obfuscation is the ability to take a computer program or function P and run it through an obfuscator which itself outputs a program. The new program should (A) be functionally equivalent to the original (i.e. on any input x the original and the newly obfuscated program give the same output) and (B) reveal the minimal amount of information possible of the original program. \n\n \nThis project explores the applications and foundations of indistinguishability obfuscation which is a form of obfuscation that guarantees that it is intractable to distinguish obfuscations of two functionally equivalent programs. Highlights of results in this program include:\n\n\n\n\n* Initial constructions for indistinguishability obfuscation were given in the circuit model where the size of the obfuscated program grew with the running time of the program. Our work showed how to move from obfuscating circuits to obfuscating general programs where we could obfuscate programs with descriptions that are much smaller than their running time. Unlike other works, there were no restrictions on the size of the programs.\n\n \n* A primitive known as \"lockable obfuscation\" was introduced. In lockable obfuscation a program\nP is obfuscated alongside a lock value \u2018a\u2019. An evaluator that has input x can learn if P(x)=a. However, if \u2018a\u2019 is chosen randomly, then no information about the program will be revealed. Our work showed how to construct this primitive from the Learning with Errors assumption. Moreover, we showed several applications of this including the ability to hide the recipient of *any* public key encryption system.\n\n \n* The project  also provided results showing the limits of obfuscation. In particular, we showed that a notion known as Differing Inputs Obfuscation was impossible for the Turing Machine model.\n\n \n* Our work also provided a Learning with Errors realization for a problem known as Traitor Tracing. In such a system a party can trace the source of a corrupted decryption device *even if the corrupted device is itself obfuscated. This result was the first one to accomplish this for any system with short parameters.\n\n\t\t\t\t\tLast Modified: 11/30/2020\n\n\t\t\t\t\tSubmitted by: Brent R Waters"
 }
}