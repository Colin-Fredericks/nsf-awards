{
 "awd_id": "1420175",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Relational Parametricity for Program Verification",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2014-09-15",
 "awd_exp_date": "2018-08-31",
 "tot_intn_awd_amt": 377083.0,
 "awd_amount": 450474.0,
 "awd_min_amd_letter_date": "2014-06-13",
 "awd_max_amd_letter_date": "2015-05-15",
 "awd_abstract_narration": "Title: SHF: Small: Relational Parametricity for Program Verification\r\n\r\nThe software market is currently estimated at $500 billion per year, and this figure is likely to grow significantly in real terms as software becomes ever more ubiquitous. One crucial aspect of software is that it be correct, i.e., that software does what's intended and does not go wrong. Even failures of everyday devices like iPods and mobile phones are inconvenient and frustrating, but software leaking credit card details or voting records, causing an airplane to crash, launching nuclear weapons without authorization, or compromising the global financial sector can lead to unprecedented and clearly unacceptable global uncertainties. The ever-growing size and sophistication of programs makes formal verification methods --- which use mathematical techniques to ensure that programs actually perform the computations they are designed to carry out and do not perform unintended ones --- increasingly critical for building truly secure and reliable software. The broader impact of this research is to make possible the development of better and more widely applicable formal program verification methods, and, thereby, to help ensure that even large and sophisticated software systems are provably correct.\r\n\r\nRelational parametricity is a key technique for formally verifying properties of software systems. Logical relations, upon which relational parametricity is based, provide a means of proving properties of a software system directly from the system itself. Logical relations have by now been developed for core fragments of many modern programming languages and verification systems. However, this has been accomplished by way of an enormous constellation of complicated and non-reusable logical relations, rather than by appealing to their uniform construction and transferrable development from fundamental principles. This research aims to improve the current state-of-the-art by providing an axiomatic framework for the construction of logical relations. The framework is principled, conceptually simple, comprehensive, uniform, and predictive. The intellectual merit of this research lies in its exposition and use of essential structures from category theory (\"fibrations\") to address the significant technical problems of constructing logical relations, and conceptualizing relational parametricity in sophisticated settings. It also lies in the novel and uniform formulation of parametricity to which this research will lead, and the application of this new framework to specific state-of-the-art computational problems. To ensure its uptake, a logic and tool support for the new framework will be provided. While the tool will permit users to experiment with the framework, the feedback from their practical experiences will further fortify the new foundations for parametricity.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Patricia",
   "pi_last_name": "Johann",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Patricia Johann",
   "pi_email_addr": "johannp@appstate.edu",
   "nsf_id": "000659322",
   "pi_start_date": "2014-06-13",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Appalachian State University",
  "inst_street_address": "438 ACADEMY ST",
  "inst_street_address_2": "",
  "inst_city_name": "BOONE",
  "inst_state_code": "NC",
  "inst_state_name": "North Carolina",
  "inst_phone_num": "8282627459",
  "inst_zip_code": "286080001",
  "inst_country_name": "United States",
  "cong_dist_code": "05",
  "st_cong_dist_code": "NC05",
  "org_lgl_bus_name": "APPALACHIAN STATE UNIVERSITY",
  "org_prnt_uei_num": "",
  "org_uei_num": "F1NAKY5L1425"
 },
 "perf_inst": {
  "perf_inst_name": "Appalachian State University",
  "perf_str_addr": "287 Rivers St.",
  "perf_city_name": "Boone",
  "perf_st_code": "NC",
  "perf_st_name": "North Carolina",
  "perf_zip_code": "286082068",
  "perf_ctry_code": "US",
  "perf_cong_dist": "05",
  "perf_st_cong_dist": "NC05",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  },
  {
   "app_code": "0115",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001516DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 377083.0
  },
  {
   "fund_oblg_fiscal_yr": 2015,
   "fund_oblg_amt": 73391.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>In this project we corrected a rather large technical problem with a framework previously thought to guarantee type-uniformity in polymorphic programming languages. We discovered the problem with the existing framework, corrected it, showed that the corrected theory has as a direct instance type-uniformity for the language for which it was originally developed nearly 50 years ago, and showed that the corrected theory also extends to higher dimensions (and thus to languages supporting very sophisticated forms of type-uniformity). Showing that the corrected theory is also extensible to languages supporting more \"real-world\" features, such as algebraic effects, is ongoing work. Our framework for type-uniformity is a true framework, in the sense that it is developed once but used over and over again in different computational settings. For settings that are instances, our framework ensures that programs claiming to be type-uniform really do operate independently of their types, gives well-defined computational and mathematical meanings to algebraic data types, derives programming idioms and program transformations that can improve the performance of programs and be integrated into optimizing compilers, and provides strong correctness guarantees for programs that improve program verification.</p>\n<p>On the non-technical side, this project brought the first-ever post-doctoral researchers, and the first world-class research, to a primarily undergraduate department at a regional state university. It also involved an undergraduate researcher in some coding in support of the project.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 10/07/2018<br>\n\t\t\t\t\tModified by: Patricia&nbsp;Johann</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nIn this project we corrected a rather large technical problem with a framework previously thought to guarantee type-uniformity in polymorphic programming languages. We discovered the problem with the existing framework, corrected it, showed that the corrected theory has as a direct instance type-uniformity for the language for which it was originally developed nearly 50 years ago, and showed that the corrected theory also extends to higher dimensions (and thus to languages supporting very sophisticated forms of type-uniformity). Showing that the corrected theory is also extensible to languages supporting more \"real-world\" features, such as algebraic effects, is ongoing work. Our framework for type-uniformity is a true framework, in the sense that it is developed once but used over and over again in different computational settings. For settings that are instances, our framework ensures that programs claiming to be type-uniform really do operate independently of their types, gives well-defined computational and mathematical meanings to algebraic data types, derives programming idioms and program transformations that can improve the performance of programs and be integrated into optimizing compilers, and provides strong correctness guarantees for programs that improve program verification.\n\nOn the non-technical side, this project brought the first-ever post-doctoral researchers, and the first world-class research, to a primarily undergraduate department at a regional state university. It also involved an undergraduate researcher in some coding in support of the project.\n\n\t\t\t\t\tLast Modified: 10/07/2018\n\n\t\t\t\t\tSubmitted by: Patricia Johann"
 }
}