{
 "awd_id": "1421161",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "AF:Small:Scheduling and Routing: Algorithms with novel cost measures",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Tracy Kimbrel",
 "awd_eff_date": "2014-09-01",
 "awd_exp_date": "2018-08-31",
 "tot_intn_awd_amt": 417277.0,
 "awd_amount": 417277.0,
 "awd_min_amd_letter_date": "2014-08-14",
 "awd_max_amd_letter_date": "2014-08-14",
 "awd_abstract_narration": "Computers, computer systems and the computational infrastructure provided by the internet are now essential for many aspects of modern life.\u00a0 It is well-known and well-documented that, even as computing power and network bandwidth increase at a rapid rate, users and applications increase their demand for computation and their use of networks at roughly the same pace.\u00a0 Thus, no matter how much progress is made on the hardware and network ends, efficient algorithms to manage these resources are essential. These efficient algorithms will lead to tremendous savings in both time and money and will have a positive environmental impact. They will also contribute to the decisions that are being made presently about the next generation of the internet, in particular in the design of routing protocols and the management of data centers.\r\n\r\nIt is now well-understood that time and space are not the only resources that need to be carefully managed.\u00a0 For the past few decades, there has been a growing emphasis on other concerns such as accuracy of solution, availability of information, use of cache, management of disk, etc.\u00a0 More recently, there has been a growing understanding that energy and power management are also resources that should be carefully managed.\u00a0 In this project, the PI will study several algorithmic problems that arise in applications such as computer systems and networks.\u00a0 For each of these, the PI will focus on algorithms for better managing the technologies, and that have objectives that go beyond time or solution quality.\u00a0 In particular, the project will study energy consumption in both computers and networks, and we will also consider environments in which other resources must be managed, such as minimizing the number of changes to a solution over time. The problem areas studied include power management in routing, power management in scheduling, extending speed scaling to other domains, and online problems with a reassignment cost. The PI will design efficient solutions to important practical problems, and the research will have broader impact.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Clifford",
   "pi_last_name": "Stein",
   "pi_mid_init": "S",
   "pi_sufx_name": "",
   "pi_full_name": "Clifford S Stein",
   "pi_email_addr": "cliff@ieor.columbia.edu",
   "nsf_id": "000193678",
   "pi_start_date": "2014-08-14",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Columbia University",
  "inst_street_address": "615 W 131ST ST",
  "inst_street_address_2": "MC 8741",
  "inst_city_name": "NEW YORK",
  "inst_state_code": "NY",
  "inst_state_name": "New York",
  "inst_phone_num": "2128546851",
  "inst_zip_code": "100277922",
  "inst_country_name": "United States",
  "cong_dist_code": "13",
  "st_cong_dist_code": "NY13",
  "org_lgl_bus_name": "THE TRUSTEES OF COLUMBIA UNIVERSITY IN THE CITY OF NEW YORK",
  "org_prnt_uei_num": "",
  "org_uei_num": "F4N1QNPB95M4"
 },
 "perf_inst": {
  "perf_inst_name": "Columbia University",
  "perf_str_addr": "2960 Broadway",
  "perf_city_name": "New York",
  "perf_st_code": "NY",
  "perf_st_name": "New York",
  "perf_zip_code": "100276902",
  "perf_ctry_code": "US",
  "perf_cong_dist": "13",
  "perf_st_cong_dist": "NY13",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779600",
   "pgm_ele_name": "Algorithmic Foundations"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7926",
   "pgm_ref_txt": "ALGORITHMS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0114",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001415DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2014,
   "fund_oblg_amt": 417277.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>This project addressed several problems in scheduling, routing and related problems.&nbsp; The goal was to move beyond traditional measures of evaluating an algorithm by worst case performance on .a static input on one computer.&nbsp; We made progress on several fronts.&nbsp;&nbsp;</p>\n<p>&nbsp;</p>\n<p>One basic problem we studied is understanding how many machines are necessary in order to process a given amount of computation.&nbsp; Consider work that arrives over time, and each task has a deadline.&nbsp; One can ask how many machines are needed to complete all the tasks, or similarly, how many human workers would be needed to complete the tasks.&nbsp; The problem is complicated by not knowing the future -- one needs to provision enough machines or enough workers without knowing exactly when the work is coming.&nbsp; We show how to give significantly better estimates on the number of machines needed for such tasks.</p>\n<p>&nbsp;</p>\n<p>A second problem is to understand how to maintain networks as they evolve over time.&nbsp; If one considers a network, be it a network of devices, or a network of people (with connections representing human connections), it is common that this network evolves over time.&nbsp; As the network evolves, one must update information about the network.&nbsp; One basic problem is to maintain a matching, which is a pairing of related nodes.&nbsp; We show how to update a matching significantly faster than was previously known.</p>\n<p>&nbsp;</p>\n<p>We also consider computing matchings in extremely large graphs.&nbsp; When you have such a massive graph, you cannot store it on one machine, but rather, have to distribute the graph on multiple computers.&nbsp; Computation becomes much trickiers, as one has to coordinate the work of different computers and communicate betwen them.&nbsp; We give algorithms that use significantly less communication than previous ones.</p>\n<p>&nbsp;</p>\n<p>We also consider scheduling problems where communication occurs via posted prices.&nbsp; An example of such a mechanism are parking systems where the price varies over time, and is sensitive to congestion and demand.&nbsp; In our context,&nbsp; machines post jobs and jobs go to machines, making their decisions based on prices, and without a central coordination mechanism. &nbsp;We showed that having such an algorithm is actually equivalent to having an online algorithm that is immediate dispatch, that is, when a job arrives, it immediately assigns it to a machine.&nbsp; &nbsp;Using this equivalnce, we are able to schedule our systems more efficiently.&nbsp;</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 12/06/2018<br>\n\t\t\t\t\tModified by: Clifford&nbsp;S&nbsp;Stein</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThis project addressed several problems in scheduling, routing and related problems.  The goal was to move beyond traditional measures of evaluating an algorithm by worst case performance on .a static input on one computer.  We made progress on several fronts.  \n\n \n\nOne basic problem we studied is understanding how many machines are necessary in order to process a given amount of computation.  Consider work that arrives over time, and each task has a deadline.  One can ask how many machines are needed to complete all the tasks, or similarly, how many human workers would be needed to complete the tasks.  The problem is complicated by not knowing the future -- one needs to provision enough machines or enough workers without knowing exactly when the work is coming.  We show how to give significantly better estimates on the number of machines needed for such tasks.\n\n \n\nA second problem is to understand how to maintain networks as they evolve over time.  If one considers a network, be it a network of devices, or a network of people (with connections representing human connections), it is common that this network evolves over time.  As the network evolves, one must update information about the network.  One basic problem is to maintain a matching, which is a pairing of related nodes.  We show how to update a matching significantly faster than was previously known.\n\n \n\nWe also consider computing matchings in extremely large graphs.  When you have such a massive graph, you cannot store it on one machine, but rather, have to distribute the graph on multiple computers.  Computation becomes much trickiers, as one has to coordinate the work of different computers and communicate betwen them.  We give algorithms that use significantly less communication than previous ones.\n\n \n\nWe also consider scheduling problems where communication occurs via posted prices.  An example of such a mechanism are parking systems where the price varies over time, and is sensitive to congestion and demand.  In our context,  machines post jobs and jobs go to machines, making their decisions based on prices, and without a central coordination mechanism.  We showed that having such an algorithm is actually equivalent to having an online algorithm that is immediate dispatch, that is, when a job arrives, it immediately assigns it to a machine.   Using this equivalnce, we are able to schedule our systems more efficiently. \n\n\t\t\t\t\tLast Modified: 12/06/2018\n\n\t\t\t\t\tSubmitted by: Clifford S Stein"
 }
}