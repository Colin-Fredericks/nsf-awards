{
 "awd_id": "1162331",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Medium: Collaborative Research: Specification and Mathematics Engineering for the Verified Software End-Game",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927991",
 "po_email": "namla@nsf.gov",
 "po_sign_block_name": "Nina Amla",
 "awd_eff_date": "2012-07-01",
 "awd_exp_date": "2016-06-30",
 "tot_intn_awd_amt": 476066.0,
 "awd_amount": 476066.0,
 "awd_min_amd_letter_date": "2012-06-20",
 "awd_max_amd_letter_date": "2012-06-20",
 "awd_abstract_narration": "Software is remarkably important to modern life.  The correct and secure behavior of software that controls nearly all major machines and communications systems, from aircraft and cars to medical records and financial transactions, is mission-critical and often can be a matter of life and death.  The current industry-standard method for assessing correctness of software, known as \"software testing\", is not foolproof.  This research project will combine the interdisciplinary expertise of the investigators in software engineering and mathematical logic to support a paradigm shift toward \"verified software\": programs that have been entirely and mechanically proved, using formal mathematical logic, to be correct relative to full behavioral specifications of what they are supposed to do and what they are not supposed to do.  Given the broad benefits of correct software to society and its impact on national competitiveness, a strong U.S. presence in verified software research and education must be a national priority.\r\n\r\nWhile transition of research ideas to practice will take time, the idea of a verifying compiler for sequential, object-based software is tantalizingly close to reality.  In what can be properly described as the \"end game\", extensive empirical studies of Verification Conditions (VCs) for correct software already have been undertaken.  VCs are assertions that establish that a program is correct if and only if they can be proved.  It has been observed that when VCs are not provable mechanically, the obstacles lie in proving VCs that are \"obvious\" to mathematicians, and in engineering specifications and supporting mathematics so they lead to VCs that are also \"obvious\" to automated provers.  The expected results of this project are programming language- and tool-independent improvements in automated software verification that will be widely applicable.  Another key project goal is integration of new concepts and tools supporting verified software into undergraduate and graduate Computer Science courses.  These efforts will contribute to development of a superior next-generation software engineering workforce.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Bruce",
   "pi_last_name": "Weide",
   "pi_mid_init": "W",
   "pi_sufx_name": "",
   "pi_full_name": "Bruce W Weide",
   "pi_email_addr": "bwweide@gmail.com",
   "nsf_id": "000279349",
   "pi_start_date": "2012-06-20",
   "pi_end_date": null
  },
  {
   "pi_role": "Co-Principal Investigator",
   "pi_first_name": "Harvey",
   "pi_last_name": "Friedman",
   "pi_mid_init": "M",
   "pi_sufx_name": "",
   "pi_full_name": "Harvey M Friedman",
   "pi_email_addr": "friedman@math.ohio-state.edu",
   "nsf_id": "000312906",
   "pi_start_date": "2012-06-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "Ohio State University",
  "inst_street_address": "1960 KENNY RD",
  "inst_street_address_2": "",
  "inst_city_name": "COLUMBUS",
  "inst_state_code": "OH",
  "inst_state_name": "Ohio",
  "inst_phone_num": "6146888735",
  "inst_zip_code": "432101016",
  "inst_country_name": "United States",
  "cong_dist_code": "03",
  "st_cong_dist_code": "OH03",
  "org_lgl_bus_name": "OHIO STATE UNIVERSITY, THE",
  "org_prnt_uei_num": "MN4MDDMN8529",
  "org_uei_num": "DLWBSLWAJWR1"
 },
 "perf_inst": {
  "perf_inst_name": "Ohio State University",
  "perf_str_addr": "2015 Neil Ave.",
  "perf_city_name": "Columbus",
  "perf_st_code": "OH",
  "perf_st_name": "Ohio",
  "perf_zip_code": "432101277",
  "perf_ctry_code": "US",
  "perf_cong_dist": "03",
  "perf_st_cong_dist": "OH03",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7924",
   "pgm_ref_txt": "MEDIUM PROJECT"
  },
  {
   "pgm_ref_code": "7944",
   "pgm_ref_txt": "SOFTWARE ENG & FORMAL METHODS"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 476066.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>A recent grand-challenge problem for the computer science research community has been to develop a \"verifying compiler\". &nbsp;The idea is that there must be two separate descriptions of each piece of software: a mathematical specification describing <em>what</em> it should (and should not) do, and a program text describing <em>how</em> that behavior should be achieved by the computer. &nbsp;A verifying compiler is software that essentially has to decide whether these two descriptions agree before it can declare the program text to be \"correct\" for the given specification. &nbsp;It does this by <em>automatically constructing a mathematical proof</em> that the two descriptions agree.</p>\n<p>The importance of verified-as-correct software to U.S. national security and infrastructure is apparent. &nbsp;The critical and growing role of correct software to our society at large, where medical images are interpreted and transportation systems are controlled by software, cannot be overstated. &nbsp;In addition, most so-called \"security\" problems with software are actually the result of \"hackers\" taking advantage of routine software defects that could have been detected and prevented by a verifying compiler.</p>\n<p>The intellectual merit of the project's outcomes lies primarily in overcoming the difficulties of developing correct software in the first place, of proving mathematically that it is correct given arbitrary resources including human intelligence, and of making the latter process practical by replacing the human intelligence seemingly required for the proof by a fully automated process done in software (i.e., a verifying compiler). &nbsp;This project's primary technical outcomes include advances in the mathematical foundations underlying a verifying compiler for a research programming language (Resolve) with features very similar to those widely used in commercial practice (e.g., Java, C#); a set of mathematical specification techniques that, when followed, make it easier for the verifying compiler to prove, without human involvement in the proof process, that software is correct; and a suite of &nbsp;software tools that permit well-designed software systems of essentially arbitrary size to be automatically proved correct, one software component at a time (i.e., a verifying compiler).</p>\n<p>The broader impacts of the project's outcomes lie primarily in how our research on these problems has affected education for future computer scientists. &nbsp;For over 20 years, undergraduate computer science majors at Ohio State have learned how to use mathematical specifications of the intended behavior of software in order to say exactly what that software is supposed to do (and not do). &nbsp;Dozens of software components in Java that were developed as research prototypes during this project have recently made their way into the classroom, where over 1000 students per year are learning from these examples and related assignments the principles underlying \"software design for verification\". &nbsp;As these students graduate and take industry positions, their good habits of software design and leadership abilities should help make large categories of the software defects we see today a thing of the past.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 09/01/2016<br>\n\t\t\t\t\tModified by: Bruce&nbsp;W&nbsp;Weide</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nA recent grand-challenge problem for the computer science research community has been to develop a \"verifying compiler\".  The idea is that there must be two separate descriptions of each piece of software: a mathematical specification describing what it should (and should not) do, and a program text describing how that behavior should be achieved by the computer.  A verifying compiler is software that essentially has to decide whether these two descriptions agree before it can declare the program text to be \"correct\" for the given specification.  It does this by automatically constructing a mathematical proof that the two descriptions agree.\n\nThe importance of verified-as-correct software to U.S. national security and infrastructure is apparent.  The critical and growing role of correct software to our society at large, where medical images are interpreted and transportation systems are controlled by software, cannot be overstated.  In addition, most so-called \"security\" problems with software are actually the result of \"hackers\" taking advantage of routine software defects that could have been detected and prevented by a verifying compiler.\n\nThe intellectual merit of the project's outcomes lies primarily in overcoming the difficulties of developing correct software in the first place, of proving mathematically that it is correct given arbitrary resources including human intelligence, and of making the latter process practical by replacing the human intelligence seemingly required for the proof by a fully automated process done in software (i.e., a verifying compiler).  This project's primary technical outcomes include advances in the mathematical foundations underlying a verifying compiler for a research programming language (Resolve) with features very similar to those widely used in commercial practice (e.g., Java, C#); a set of mathematical specification techniques that, when followed, make it easier for the verifying compiler to prove, without human involvement in the proof process, that software is correct; and a suite of  software tools that permit well-designed software systems of essentially arbitrary size to be automatically proved correct, one software component at a time (i.e., a verifying compiler).\n\nThe broader impacts of the project's outcomes lie primarily in how our research on these problems has affected education for future computer scientists.  For over 20 years, undergraduate computer science majors at Ohio State have learned how to use mathematical specifications of the intended behavior of software in order to say exactly what that software is supposed to do (and not do).  Dozens of software components in Java that were developed as research prototypes during this project have recently made their way into the classroom, where over 1000 students per year are learning from these examples and related assignments the principles underlying \"software design for verification\".  As these students graduate and take industry positions, their good habits of software design and leadership abilities should help make large categories of the software defects we see today a thing of the past.\n\n\t\t\t\t\tLast Modified: 09/01/2016\n\n\t\t\t\t\tSubmitted by: Bruce W Weide"
 }
}