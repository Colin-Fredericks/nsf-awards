{
 "awd_id": "1147680",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SI2-SSE Collaborative Research: SPIKE-An Implementation of a Recursive Divide-and-Conquer Parallel Strategy for Solving  Large  Systems of Linear Equations",
 "cfda_num": "47.070",
 "org_code": "05090000",
 "po_phone": null,
 "po_email": "",
 "po_sign_block_name": "Rajiv Ramnath",
 "awd_eff_date": "2012-06-01",
 "awd_exp_date": "2015-05-31",
 "tot_intn_awd_amt": 117710.0,
 "awd_amount": 117710.0,
 "awd_min_amd_letter_date": "2012-06-20",
 "awd_max_amd_letter_date": "2012-06-20",
 "awd_abstract_narration": "Drs. Negrut, Sameh, and Knepley will investigate, produce, and maintain a methodology and its software implementation that leverage emerging heterogeneous hardware architectures to solve billion-unknowns linear systems in a robust, scalable, and efficient fashion. The two classes of problems targeted under this project are banded dense and sparse general linear systems.\r\n\r\nThis project is motivated by the observation that the task of solving a linear system is one of the most ubiquitous ingredients in the numerical solution of Applied Mathematics problems. It is relied upon for the implicit integration of Ordinary Differential Equation (ODE) and Differential Algebraic Equation (DAE) problems, in the numerical solution of Partial Differential Equation (PDE) problems, in interior point optimization methods, in least squares approximations, in solving eigenvalue problems, and in data analysis. In fact, the vast majority of nonlinear problems in Scientific Computing are solved iteratively by drawing on local linearizations of nonlinear operators and the solution of linear systems. Recent advances in (a) hardware architecture; i.e., the emergence of General Purpose Graphics Processing Unit (GP-GPU) cards, and (b) scalable solution algorithms, provide an opportunity to develop a new class of parallel algorithms, called SPIKE, which can robustly and efficiently solve very large linear systems of equations.\r\n\r\nDrawing on its divide-and-conquer paradigm, SPIKE builds on several algorithmic primitives: matrix reordering strategies, dense linear algebra operations, sparse direct solvers, and Krylov subspace methods. It provides a scalable solution that can be deployed in a heterogeneous hardware ecosystem and has the potential to solve billion-unknown linear systems in the cloud or on tomorrow?s exascale supercomputers. Its high degree of scalability and improved efficiency stem from (i) optimized memory access pattern owing to an aggressive pre-processing stage that reduces a generic sparse matrix to a banded one through a novel reordering strategy; (ii) good exposure of coarse and fine grain parallelism owing to a recursive, divide-and-conquer solution strategy; (iii) efficient vectorization in evaluating the coupling terms in the divide-and-conquer stage owing to a CPU+GPU heterogeneous computing approach; and (iv) algorithmic polymorphism, given that SPIKE can serve both as a direct solver or an effective preconditioner in an iterative Krylov-type method.\r\n\r\nIn Engineering, SPIKE will provide the Computer Aided Engineering (CAE) community with a key component; i.e., fast solution of linear systems, required by the analysis of complex problems through computer simulation. Examples of applications that would benefit from this technology are Structural Mechanics problems (Finite Element Analysis in car crash simulation), Computational Fluid Dynamics problems (solving Navier-Stokes equations in the simulation of turbulent flow around a wing profile), and Computational Multibody Dynamics problems (solving Newton-Euler equations in large granular dynamics problems).\r\n\r\nSPIKE will also be interfaced to the Portable, Extensible Toolkit for Scientific Computation (PETSc), a two decades old flexible and scalable framework for solving Science and Engineering problems on supercomputers. Through PETSc, SPIKE will be made available to a High Performance Computing user community with more than 20,000 members worldwide. PETSc users will be able to run SPIKE without any modifications on vastly different supercomputer architectures such as the IBM BlueGene/P and BlueGene/Q, or the Cray XT5. SPIKE will thus run scalably on the largest machines in the world and will be tuned for very different network and hardware topologies while maintaining a simple code base.\r\n\r\nThe experience collected and lessons learned in this project will augment a graduate level class, ?High Performance Computing for Engineering Applications? taught at the University of Wisconsin-Madison. A SPIKE tutorial and research outcomes will be presented each year at the International Conference for High Performance Computing, Networking, Storage and Analysis. A one day High Performance Computing Boot Camp will be organized each year in conjunction with the American Society of Mechanical Engineers (ASME) conference and used to disseminate the software outcomes of this effort. Finally, this project will shape the research agendas of two graduate students working on advanced degrees in Computational Science.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "OAC",
 "org_div_long_name": "Office of Advanced Cyberinfrastructure (OAC)",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Matthew",
   "pi_last_name": "Knepley",
   "pi_mid_init": "G",
   "pi_sufx_name": "",
   "pi_full_name": "Matthew G Knepley",
   "pi_email_addr": "knepley@buffalo.edu",
   "nsf_id": "000503185",
   "pi_start_date": "2012-06-20",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of Chicago",
  "inst_street_address": "5801 S ELLIS AVE",
  "inst_street_address_2": "",
  "inst_city_name": "CHICAGO",
  "inst_state_code": "IL",
  "inst_state_name": "Illinois",
  "inst_phone_num": "7737028669",
  "inst_zip_code": "606375418",
  "inst_country_name": "United States",
  "cong_dist_code": "01",
  "st_cong_dist_code": "IL01",
  "org_lgl_bus_name": "UNIVERSITY OF CHICAGO",
  "org_prnt_uei_num": "ZUE9HKT2CLC9",
  "org_uei_num": "ZUE9HKT2CLC9"
 },
 "perf_inst": {
  "perf_inst_name": "The University of Chicago",
  "perf_str_addr": "5735 South Ellis",
  "perf_city_name": "Chicago",
  "perf_st_code": "IL",
  "perf_st_name": "Illinois",
  "perf_zip_code": "606371433",
  "perf_ctry_code": "US",
  "perf_cong_dist": "01",
  "perf_st_cong_dist": "IL01",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "125300",
   "pgm_ele_name": "OFFICE OF MULTIDISCIPLINARY AC"
  },
  {
   "pgm_ele_code": "747800",
   "pgm_ele_name": "DYNAMICAL SYSTEMS"
  },
  {
   "pgm_ele_code": "800400",
   "pgm_ele_name": "Software Institutes"
  },
  {
   "pgm_ele_code": "806900",
   "pgm_ele_name": "CDS&E-MSS"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7433",
   "pgm_ref_txt": "CyberInfra Frmwrk 21st (CIF21)"
  },
  {
   "pgm_ref_code": "8005",
   "pgm_ref_txt": "Scientific Software Elements"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 117710.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>As computers become larger and more integrated, meaning that computational cores are packed more tightly, latency has become a major factor in the overall performance of important algorithms for simulation, such as the simulation of fluid flow, mechanical movement, granular mechanics, or protein binding.</p>\n<p>Latency means waiting time, and can arise from many different causes. It takes a finite time for electric signals to propagate across a large chip. There are only a few pipes from memory to cores, so that any given core might have to wait for values from memory to be delivered before it can continue computing. Synchronization among tasks on different cores might mean that tasks finishing first will have to wait for slower tasks. The operating system or other system level software can intrude into the operation of a simulation, causing waiting time to increase unpredictably.</p>\n<p>In this project, we are concerned with the operation of Krylov methods, a very popular solver for systems of linear equations, in an environment with both high and unpredictable latency. A drawback of Krylov methods is that they contain many synchronization points, arising from vctor dot products, which limit the performance and scalability in the presence of high latencies. Krylov method variants, called asynchronous Krylov methods, which are latency tolerant have been previously proposed and shown to perform well in high latency environments. However, no performance analysis has been done, so that we may predict such performance. Moreover, the prior work has not taken into account the random nature of the waiting times.</p>\n<p>Our group developed a stochastic model of the latency in a Krylov method, meaning we assume that the waiting times are random and cna be described as arising from some theoretical distribution. For a given distribution of waiting times, we could calculate the improvement in performance when using asynchronous Krylov methods as opposed to the normal method. This characterization of the speedup allowed us to run a large number of Krylov solves on a supercomputer, and calculate the probable distributions for the latency, whereas a direct characterization of the latency itself would be either too complex or unobtainable.</p>\n<p>Using this tool, we were able to demonstrate a misconception about the supercomputing environment and algorithmic performance. It is clear that the latency or waiting times on a large computer are not small, random, uncorrelated events, but instead follow distributions with long tails, meaning long waiting times occur much more often that we suspected. This means that the asynchrous Krylov methods can achieve a greater speedup on avergage than has been reported in the literature. We suspect that this is due to the fact that most people select the fastest runs when reporting performance to a journal, rather than using all runs including those that are anomalously slow. However, it is important to include all runs since this gives the most accurate picture for the average scientist or engineer who will eventually use these methods to carry out their research. Hopefully, our mathematical characterization of performance can be used now to design more efficient and scalable methods for this complex environment, and can be extended to heterogeneous computing platforms, meaning those with different kinds of cores such as regular CPUs combined with GPUs or other co-processors and accelerators.</p><br>\n<p>\n\t\t\t\t      \tLast Modified: 09/24/2015<br>\n\t\t\t\t\tModified by: Matthew&nbsp;Knepley</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nAs computers become larger and more integrated, meaning that computational cores are packed more tightly, latency has become a major factor in the overall performance of important algorithms for simulation, such as the simulation of fluid flow, mechanical movement, granular mechanics, or protein binding.\n\nLatency means waiting time, and can arise from many different causes. It takes a finite time for electric signals to propagate across a large chip. There are only a few pipes from memory to cores, so that any given core might have to wait for values from memory to be delivered before it can continue computing. Synchronization among tasks on different cores might mean that tasks finishing first will have to wait for slower tasks. The operating system or other system level software can intrude into the operation of a simulation, causing waiting time to increase unpredictably.\n\nIn this project, we are concerned with the operation of Krylov methods, a very popular solver for systems of linear equations, in an environment with both high and unpredictable latency. A drawback of Krylov methods is that they contain many synchronization points, arising from vctor dot products, which limit the performance and scalability in the presence of high latencies. Krylov method variants, called asynchronous Krylov methods, which are latency tolerant have been previously proposed and shown to perform well in high latency environments. However, no performance analysis has been done, so that we may predict such performance. Moreover, the prior work has not taken into account the random nature of the waiting times.\n\nOur group developed a stochastic model of the latency in a Krylov method, meaning we assume that the waiting times are random and cna be described as arising from some theoretical distribution. For a given distribution of waiting times, we could calculate the improvement in performance when using asynchronous Krylov methods as opposed to the normal method. This characterization of the speedup allowed us to run a large number of Krylov solves on a supercomputer, and calculate the probable distributions for the latency, whereas a direct characterization of the latency itself would be either too complex or unobtainable.\n\nUsing this tool, we were able to demonstrate a misconception about the supercomputing environment and algorithmic performance. It is clear that the latency or waiting times on a large computer are not small, random, uncorrelated events, but instead follow distributions with long tails, meaning long waiting times occur much more often that we suspected. This means that the asynchrous Krylov methods can achieve a greater speedup on avergage than has been reported in the literature. We suspect that this is due to the fact that most people select the fastest runs when reporting performance to a journal, rather than using all runs including those that are anomalously slow. However, it is important to include all runs since this gives the most accurate picture for the average scientist or engineer who will eventually use these methods to carry out their research. Hopefully, our mathematical characterization of performance can be used now to design more efficient and scalable methods for this complex environment, and can be extended to heterogeneous computing platforms, meaning those with different kinds of cores such as regular CPUs combined with GPUs or other co-processors and accelerators.\n\n\t\t\t\t\tLast Modified: 09/24/2015\n\n\t\t\t\t\tSubmitted by: Matthew Knepley"
 }
}