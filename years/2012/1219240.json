{
 "awd_id": "1219240",
 "agcy_id": "NSF",
 "tran_type": "Grant",
 "awd_istr_txt": "Standard Grant",
 "awd_titl_txt": "SHF: Small: Typed Self-Application",
 "cfda_num": "47.070",
 "org_code": "05010000",
 "po_phone": "7032927885",
 "po_email": "abanerje@nsf.gov",
 "po_sign_block_name": "Anindya Banerjee",
 "awd_eff_date": "2012-09-01",
 "awd_exp_date": "2018-02-28",
 "tot_intn_awd_amt": 493612.0,
 "awd_amount": 493612.0,
 "awd_min_amd_letter_date": "2012-07-10",
 "awd_max_amd_letter_date": "2012-07-10",
 "awd_abstract_narration": "Static type checking has brought us more reliable software.  Types make programs more readable, prevent entire classes of mistakes, and help compilers optimize data layout and data access.  Types also make it easier to use libraries and to design interfaces, and they make it harder to misuse data and write bad programs.  An entirely different trend is as old as programming: self-application.  In particular, self-application is popular in the form of implementing a language in itself.  When the trends of types and self-application meet, a fundamental challenge for type systems arises.  For example, what is the type of an interpreter that can interpret a representation of itself?  And what is the type of a compiler that can compile a representation of itself?  The goal of the project is to enable the next generation of typed, self-applicable interpreters, compilers, and partial evaluators.  This next generation will guarantee that the output represents a typed program, and that the type of the output program is related to the type of the input program.  The result will be self-applicable meta-programs that are more reliable and have all the benefits of static type checking.\r\n\r\nMany popular languages have a self-interpreter, that is, an interpreter for the language written in itself; examples include Standard ML, Haskell, Scheme, JavaScript, Python, and Ruby.  Similarly, many languages have self-compilers, that is, a compiler for the language written in itself.  Also, some languages have a virtual machine written in itself, including Java and Self.  The project will bring static type checking to self-applicable interpreters, compilers, and partial evaluators, and take such meta-programs to a higher level of reliability by ensuring that the output programs type check and therefore cannot contain entire classes of mistakes.  The investigator will teach the results to students as part of existing undergraduate and graduate courses.",
 "awd_arra_amount": 0.0,
 "dir_abbr": "CSE",
 "org_dir_long_name": "Directorate for Computer and Information Science and Engineering",
 "div_abbr": "CCF",
 "org_div_long_name": "Division of Computing and Communication Foundations",
 "awd_agcy_code": "4900",
 "fund_agcy_code": "4900",
 "pi": [
  {
   "pi_role": "Principal Investigator",
   "pi_first_name": "Jens",
   "pi_last_name": "Palsberg",
   "pi_mid_init": "",
   "pi_sufx_name": "",
   "pi_full_name": "Jens Palsberg",
   "pi_email_addr": "palsberg@ucla.edu",
   "nsf_id": "000105676",
   "pi_start_date": "2012-07-10",
   "pi_end_date": null
  }
 ],
 "inst": {
  "inst_name": "University of California-Los Angeles",
  "inst_street_address": "10889 WILSHIRE BLVD STE 700",
  "inst_street_address_2": "",
  "inst_city_name": "LOS ANGELES",
  "inst_state_code": "CA",
  "inst_state_name": "California",
  "inst_phone_num": "3107940102",
  "inst_zip_code": "900244200",
  "inst_country_name": "United States",
  "cong_dist_code": "36",
  "st_cong_dist_code": "CA36",
  "org_lgl_bus_name": "UNIVERSITY OF CALIFORNIA, LOS ANGELES",
  "org_prnt_uei_num": "",
  "org_uei_num": "RN64EPNH8JC6"
 },
 "perf_inst": {
  "perf_inst_name": "UCLA Computer Science",
  "perf_str_addr": "4531K Boelter Hall",
  "perf_city_name": "Los Angeles",
  "perf_st_code": "CA",
  "perf_st_name": "California",
  "perf_zip_code": "900951596",
  "perf_ctry_code": "US",
  "perf_cong_dist": "36",
  "perf_st_cong_dist": "CA36",
  "perf_ctry_name": "United States",
  "perf_ctry_flag": "1"
 },
 "pgm_ele": [
  {
   "pgm_ele_code": "779800",
   "pgm_ele_name": "Software & Hardware Foundation"
  }
 ],
 "pgm_ref": [
  {
   "pgm_ref_code": "7923",
   "pgm_ref_txt": "SMALL PROJECT"
  },
  {
   "pgm_ref_code": "7943",
   "pgm_ref_txt": "PROGRAMMING LANGUAGES"
  }
 ],
 "app_fund": [
  {
   "app_code": "0112",
   "app_name": "NSF RESEARCH & RELATED ACTIVIT",
   "app_symb_id": "040100",
   "fund_code": "01001213DB",
   "fund_name": "NSF RESEARCH & RELATED ACTIVIT",
   "fund_symb_id": "040100"
  }
 ],
 "oblg_fy": [
  {
   "fund_oblg_fiscal_yr": 2012,
   "fund_oblg_amt": 493612.0
  }
 ],
 "por": {
  "por_cntn": "<div class=\"porColContainerWBG\">\n<div class=\"porContentCol\"><p>The project produced three big jumps forward in how to do typed meta-programming. &nbsp;First, it showed that a piece of conventional wisdom is wrong and went ahead and defined a self-interpreter for a terminating functional language. This was previously thought to be impossible because of the presence of a so-called diagonalization gadget. &nbsp;The key to the new result is to use a well-known type system to ensure that such diagonalization gadgets are impossible. Second, the project showed how to define typed self-interpreters, self-evaluators, and self-applicable partial evaluators. &nbsp;The foundation for those programs is a new approach to representing a typed program as a typed data structure. &nbsp;The results open the door to a new era in which types go from being good for programmers to also being good for meta-programmers. &nbsp;Third, the project created<span>&nbsp;the first Jones-optimal and self-applicable partial evaluator whose type guarantees that it always generates type-correct code. &nbsp;Together those properties guarantee efficiency, versatility, and quality, via good design and by automatically type checking the partial evaluator. &nbsp;In summary, the results of the project point to a future in which programmers may prefer to write self-applicable meta-programs in typed languages. &nbsp;This will contribute to a more reliable software infrastructure in society.</span></p><br>\n<p>\n\t\t\t\t      \tLast Modified: 05/04/2018<br>\n\t\t\t\t\tModified by: Jens&nbsp;Palsberg</p>\n</div>\n<div class=\"porSideCol\"></div>\n</div>",
  "por_txt_cntn": "\nThe project produced three big jumps forward in how to do typed meta-programming.  First, it showed that a piece of conventional wisdom is wrong and went ahead and defined a self-interpreter for a terminating functional language. This was previously thought to be impossible because of the presence of a so-called diagonalization gadget.  The key to the new result is to use a well-known type system to ensure that such diagonalization gadgets are impossible. Second, the project showed how to define typed self-interpreters, self-evaluators, and self-applicable partial evaluators.  The foundation for those programs is a new approach to representing a typed program as a typed data structure.  The results open the door to a new era in which types go from being good for programmers to also being good for meta-programmers.  Third, the project created the first Jones-optimal and self-applicable partial evaluator whose type guarantees that it always generates type-correct code.  Together those properties guarantee efficiency, versatility, and quality, via good design and by automatically type checking the partial evaluator.  In summary, the results of the project point to a future in which programmers may prefer to write self-applicable meta-programs in typed languages.  This will contribute to a more reliable software infrastructure in society.\n\n\t\t\t\t\tLast Modified: 05/04/2018\n\n\t\t\t\t\tSubmitted by: Jens Palsberg"
 }
}